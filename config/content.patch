diff -r fec90cbfbaad browser/base/content/baseMenuOverlay.xul
--- a/browser/base/content/baseMenuOverlay.xul	Thu Apr 09 22:57:56 2015 -0400
+++ b/browser/base/content/baseMenuOverlay.xul	Thu Feb 11 17:49:41 2016 +0100
@@ -101,7 +101,7 @@
              key="&preferencesCmdMac.commandkey;"
              modifiers="accel"/>
         <key id="key_hideThisAppCmdMac"
-             key="&hideThisAppCmdMac2.commandkey;"
+             key="&hideThisAppCmdMac.commandkey;"
              modifiers="accel"/>
         <key id="key_hideOtherAppsCmdMac"
              key="&hideOtherAppsCmdMac.commandkey;"
diff -r fec90cbfbaad browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd
--- a/browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd	Thu Apr 09 22:57:56 2015 -0400
+++ b/browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd	Thu Feb 11 17:49:41 2016 +0100
@@ -44,7 +44,7 @@
 <!ENTITY servicesMenuMac.label          "Services">
 
 <!ENTITY hideThisAppCmdMac2.label       "Hide &brandShorterName;">
-<!ENTITY hideThisAppCmdMac2.commandkey  "H">
+<!ENTITY hideThisAppCmdMac.commandkey  "H">
 
 <!ENTITY hideOtherAppsCmdMac.label      "Hide Others">
 <!ENTITY hideOtherAppsCmdMac.commandkey "H">
diff -r fec90cbfbaad caps/nsScriptSecurityManager.cpp
--- a/caps/nsScriptSecurityManager.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/caps/nsScriptSecurityManager.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -748,6 +748,7 @@
                              &hasFlags);
     NS_ENSURE_SUCCESS(rv, rv);
     if (hasFlags) {
+        return NS_OK;
         if (aFlags & nsIScriptSecurityManager::ALLOW_CHROME) {
 
             // For now, don't change behavior for resource:// or moz-icon:// and
@@ -805,6 +806,7 @@
                              &hasFlags);
     NS_ENSURE_SUCCESS(rv, rv);
     if (hasFlags) {
+        return NS_OK;
         // Allow domains that were whitelisted in the prefs. In 99.9% of cases,
         // this array is empty.
         for (size_t i = 0; i < mFileURIWhitelist.Length(); ++i) {
diff -r fec90cbfbaad docshell/base/nsDocShell.cpp
--- a/docshell/base/nsDocShell.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/docshell/base/nsDocShell.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -2011,6 +2011,7 @@
   }
 #endif
 
+
   // We don't want to send a location change when we're displaying an error
   // page, and we don't want to change our idea of "current URI" either
   if (mLoadType == LOAD_ERROR_PAGE) {
diff -r fec90cbfbaad dom/base/nsCopySupport.cpp
--- a/dom/base/nsCopySupport.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/base/nsCopySupport.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -135,7 +135,8 @@
 
   // The mime type is ultimately text/html if the encoder successfully encoded
   // the selection as text/html.
-  bool encodedTextHTML = mimeType.EqualsLiteral(kHTMLMime);
+  bool encodedTextHTML = mimeType.EqualsLiteral(kHTMLMime) ||
+                         mimeType.EqualsLiteral("application/xhtml+xml");;
 
   // First, prepare the text/plain clipboard flavor.
   nsAutoString textPlainBuf;
@@ -513,8 +514,9 @@
 
   // init encoder with document and node
   rv = docEncoder->NativeInit(document, NS_LITERAL_STRING(kHTMLMime),
-                              nsIDocumentEncoder::OutputAbsoluteLinks |
-                              nsIDocumentEncoder::OutputEncodeW3CEntities);
+                              Preferences::GetBool("clipboard.absoluteLinks", true)
+                                ? nsIDocumentEncoder::OutputEncodeCharacterEntities | nsIDocumentEncoder::OutputAbsoluteLinks
+                                : nsIDocumentEncoder::OutputEncodeCharacterEntities);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = docEncoder->SetNativeNode(aDOMNode);
diff -r fec90cbfbaad dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/base/nsDocument.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -7572,6 +7572,13 @@
 }
 
 NS_IMETHODIMP
+nsDocument::GetHasXMLDeclaration(bool *aHasXMLDeclaration)
+{
+  *aHasXMLDeclaration = mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsDocument::GetDocumentURI(nsAString& aDocumentURI)
 {
   nsString temp;
diff -r fec90cbfbaad dom/base/nsDocumentEncoder.cpp
--- a/dom/base/nsDocumentEncoder.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/base/nsDocumentEncoder.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -118,6 +118,11 @@
       }
 
       if (content) {
+        nsIAtom *tag = content->NodeInfo()->NameAtom();
+        if (tag == nsGkAtoms::script
+            || tag == nsGkAtoms::style) {
+          return true;
+        }
         nsIFrame* frame = content->GetPrimaryFrame();
         if (!frame) {
           if (aNode->IsNodeOfType(nsINode::eTEXT)) {
@@ -1330,7 +1335,9 @@
 
   // Make all links absolute when copying
   // (see related bugs #57296, #41924, #58646, #32768)
-  mFlags = aFlags | OutputAbsoluteLinks;
+  mFlags = Preferences::GetBool("clipboard.absoluteLinks", true)
+             ? aFlags | nsIDocumentEncoder::OutputAbsoluteLinks
+             : aFlags;
 
   if (!mDocument->IsScriptEnabled())
     mFlags |= OutputNoScriptContent;
@@ -1393,7 +1400,7 @@
 
   // also consider ourselves in a text widget if we can't find an html document
   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
-  if (!(htmlDoc && mDocument->IsHTMLDocument())) {
+  if (!htmlDoc) {
     mIsTextWidget = true;
     mSelection = aSelection;
     // mMimeType is set to text/plain when encoding starts.
@@ -1414,9 +1421,10 @@
     range->CloneRange(getter_AddRefs(myRange));
     NS_ENSURE_TRUE(myRange, NS_ERROR_FAILURE);
 
+    // BLUEGRIFFON, do not promote ranges for copy
     // adjust range to include any ancestors who's children are entirely selected
-    rv = PromoteRange(myRange);
-    NS_ENSURE_SUCCESS(rv, rv);
+    /*rv = PromoteRange(myRange);
+    NS_ENSURE_SUCCESS(rv, rv);*/
     
     rv = mSelection->AddRange(myRange);
     NS_ENSURE_SUCCESS(rv, rv);
diff -r fec90cbfbaad dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/base/nsFocusManager.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -2549,21 +2549,6 @@
     }
   }
   else {
-#ifdef MOZ_XUL
-    if (aType != MOVEFOCUS_CARET) {
-      // if there is no focus, yet a panel is open, focus the first item in
-      // the panel
-      nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
-      if (pm)
-        popupFrame = pm->GetTopPopup(ePopupTypePanel);
-    }
-#endif
-    if (popupFrame) {
-      rootContent = popupFrame->GetContent();
-      NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
-      startContent = rootContent;
-    }
-    else {
       // Otherwise, for content shells, start from the location of the caret.
       if (docShell->ItemType() != nsIDocShellTreeItem::typeChrome) {
         nsCOMPtr<nsIContent> endSelectionContent;
@@ -2593,6 +2578,20 @@
           ignoreTabIndex = true;
         }
       }
+#ifdef MOZ_XUL
+    else {
+      // if there is no focus, yet a panel is open, focus the first item in
+      // the panel
+      nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
+      if (pm)
+        popupFrame = pm->GetTopPopup(ePopupTypePanel);
+      if (popupFrame) {
+        rootContent = popupFrame->GetContent();
+        NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
+        startContent = rootContent;
+      }
+    }
+#endif
 
       if (!startContent) {
         // otherwise, just use the root content as the starting point
@@ -2600,7 +2599,6 @@
         NS_ENSURE_TRUE(startContent, NS_OK);
       }
     }
-  }
 
   NS_ASSERTION(startContent, "starting content not set");
 
diff -r fec90cbfbaad dom/base/nsHTMLContentSerializer.cpp
--- a/dom/base/nsHTMLContentSerializer.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/base/nsHTMLContentSerializer.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -194,101 +194,110 @@
   nsIAtom *name = content->NodeInfo()->NameAtom();
   int32_t ns = content->GetNameSpaceID();
 
-  bool lineBreakBeforeOpen = LineBreakBeforeOpen(ns, name);
+  bool hideTag = false;
+  if (ns != kNameSpaceID_XHTML) {
+    nsAutoString nsStr;
+    nsresult rv = nsContentUtils::NameSpaceManager()->GetNameSpaceURI(ns, nsStr);
+    hideTag = ( NS_SUCCEEDED(rv) && nsStr.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon"));
+  }
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    if (mColPos && lineBreakBeforeOpen) {
-      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    else {
-      NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    if (!mColPos) {
-      NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
+  if (!hideTag) {
+    bool lineBreakBeforeOpen = LineBreakBeforeOpen(ns, name);
+
+    if (((mDoFormat || forceFormat) && !PreLevel()) || mDoRaw) {
+      if (mColPos && lineBreakBeforeOpen) {
+        NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+        mMayIgnoreLineBreakSequence = PR_FALSE;
+      }
+      else {
+        NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);;
+      }
+      if (!mColPos && !mDoRaw) {
+        NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);;;
+      }
+      else if (mAddSpace) {
+        NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);;;
+        mAddSpace = false;
+      }
+   }
     else if (mAddSpace) {
       bool result = AppendToString(char16_t(' '), aStr);
       mAddSpace = false;
       NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
     }
-  }
-  else if (mAddSpace) {
-    bool result = AppendToString(char16_t(' '), aStr);
-    mAddSpace = false;
-    NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
-  }
-  else {
-    NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
-  // called
-  mAddNewlineForRootNode = false;
+    else {
+      NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
+    }
+    // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
+    // called
+    mAddNewlineForRootNode = false;
 
-  NS_ENSURE_TRUE(AppendToString(kLessThan, aStr), NS_ERROR_OUT_OF_MEMORY);
+    NS_ENSURE_TRUE(AppendToString(kLessThan, aStr), NS_ERROR_OUT_OF_MEMORY);
 
-  NS_ENSURE_TRUE(AppendToString(nsDependentAtomString(name), aStr), NS_ERROR_OUT_OF_MEMORY);
+    NS_ENSURE_TRUE(AppendToString(nsDependentAtomString(name), aStr), NS_ERROR_OUT_OF_MEMORY);
 
-  MaybeEnterInPreContent(content);
+    MaybeEnterInPreContent(content);
 
-  // for block elements, we increase the indentation
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel())
-    NS_ENSURE_TRUE(IncrIndentation(name), NS_ERROR_OUT_OF_MEMORY);
+    // for block elements, we increase the indentation
+    if ((mDoFormat || forceFormat) && !PreLevel() && !mDoRaw)
+      NS_ENSURE_TRUE(IncrIndentation(name), NS_ERROR_OUT_OF_MEMORY);
 
-  // Need to keep track of OL and LI elements in order to get ordinal number 
-  // for the LI.
-  if (mIsCopying && name == nsGkAtoms::ol && ns == kNameSpaceID_XHTML){
-    // We are copying and current node is an OL;
-    // Store its start attribute value in olState->startVal.
-    nsAutoString start;
-    int32_t startAttrVal = 0;
+    // Need to keep track of OL and LI elements in order to get ordinal number
+    // for the LI.
+    if (mIsCopying && name == nsGkAtoms::ol && ns == kNameSpaceID_XHTML){
+      // We are copying and current node is an OL;
+      // Store its start attribute value in olState->startVal.
+      nsAutoString start;
+      int32_t startAttrVal = 0;
 
-    aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::start, start);
-    if (!start.IsEmpty()){
-      nsresult rv = NS_OK;
-      startAttrVal = start.ToInteger(&rv);
-      //If OL has "start" attribute, first LI element has to start with that value
-      //Therefore subtracting 1 as all the LI elements are incrementing it before using it;
-      //In failure of ToInteger(), default StartAttrValue to 0.
-      if (NS_SUCCEEDED(rv))
-        startAttrVal--; 
-      else
-        startAttrVal = 0;
+      aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::start, start);
+      if (!start.IsEmpty()){
+        nsresult rv = NS_OK;
+        startAttrVal = start.ToInteger(&rv);
+        //If OL has "start" attribute, first LI element has to start with that value
+        //Therefore subtracting 1 as all the LI elements are incrementing it before using it;
+        //In failure of ToInteger(), default StartAttrValue to 0.
+        if (NS_SUCCEEDED(rv))
+          startAttrVal--;
+        else
+          startAttrVal = 0;
+      }
+      mOLStateStack.AppendElement(olState(startAttrVal, true));
     }
-    mOLStateStack.AppendElement(olState(startAttrVal, true));
-  }
 
-  if (mIsCopying && name == nsGkAtoms::li && ns == kNameSpaceID_XHTML) {
-    mIsFirstChildOfOL = IsFirstChildOfOL(aOriginalElement);
-    if (mIsFirstChildOfOL){
-      // If OL is parent of this LI, serialize attributes in different manner.
-      NS_ENSURE_TRUE(SerializeLIValueAttribute(aElement, aStr), NS_ERROR_OUT_OF_MEMORY);
+    if (mIsCopying && name == nsGkAtoms::li && ns == kNameSpaceID_XHTML) {
+      mIsFirstChildOfOL = IsFirstChildOfOL(aOriginalElement);
+      if (mIsFirstChildOfOL){
+        // If OL is parent of this LI, serialize attributes in different manner.
+        NS_ENSURE_TRUE(SerializeLIValueAttribute(aElement, aStr), NS_ERROR_OUT_OF_MEMORY);
+      }
     }
-  }
 
-  // Even LI passed above have to go through this 
-  // for serializing attributes other than "value".
-  nsAutoString dummyPrefix;
-  NS_ENSURE_TRUE(SerializeHTMLAttributes(content,
-                                         aOriginalElement,
-                                         dummyPrefix,
-                                         EmptyString(),
-                                         name,
-                                         ns,
-                                         aStr), NS_ERROR_OUT_OF_MEMORY);
+    // Even LI passed above have to go through this
+    // for serializing attributes other than "value".
+    nsAutoString dummyPrefix;
+    NS_ENSURE_TRUE(SerializeHTMLAttributes(content,
+                                           aOriginalElement,
+                                           dummyPrefix,
+                                           EmptyString(),
+                                           name,
+                                           ns,
+                                           aStr), NS_ERROR_OUT_OF_MEMORY);
 
-  NS_ENSURE_TRUE(AppendToString(kGreaterThan, aStr), NS_ERROR_OUT_OF_MEMORY);
+    NS_ENSURE_TRUE(AppendToString(kGreaterThan, aStr), NS_ERROR_OUT_OF_MEMORY);
 
-  if (ns == kNameSpaceID_XHTML &&
-      (name == nsGkAtoms::script ||
-       name == nsGkAtoms::style ||
-       name == nsGkAtoms::noscript ||
-       name == nsGkAtoms::noframes)) {
-    ++mDisableEntityEncoding;
-  }
+    if (ns == kNameSpaceID_XHTML &&
+        (name == nsGkAtoms::script ||
+         name == nsGkAtoms::style ||
+         name == nsGkAtoms::noscript ||
+         name == nsGkAtoms::noframes)) {
+      ++mDisableEntityEncoding;
+    }
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel() &&
-    LineBreakAfterOpen(ns, name)) {
-    NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+    if ((mDoFormat || forceFormat) && !PreLevel() &&
+      !mDoRaw && LineBreakAfterOpen(ns, name)) {
+      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+    }
   }
 
   NS_ENSURE_TRUE(AfterElementStart(content, aOriginalElement, aStr), NS_ERROR_OUT_OF_MEMORY);
@@ -307,6 +316,13 @@
   nsIAtom *name = content->NodeInfo()->NameAtom();
   int32_t ns = content->GetNameSpaceID();
 
+  if (ns != kNameSpaceID_XHTML) {
+    nsAutoString nsStr;
+    nsresult rv = nsContentUtils::NameSpaceManager()->GetNameSpaceURI(ns, nsStr);
+    if (NS_SUCCEEDED(rv) && nsStr.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon"))
+      return NS_OK;
+  }
+
   if (ns == kNameSpaceID_XHTML &&
       (name == nsGkAtoms::script ||
        name == nsGkAtoms::style ||
@@ -474,7 +490,8 @@
   bool nonBasicEntities =
     !!(mFlags & (nsIDocumentEncoder::OutputEncodeLatin1Entities |
                  nsIDocumentEncoder::OutputEncodeHTMLEntities   |
-                 nsIDocumentEncoder::OutputEncodeW3CEntities));
+                 nsIDocumentEncoder::OutputEncodeW3CEntities    |
+                 nsIDocumentEncoder::OutputEncodeCharacterEntities));
 
   if (!nonBasicEntities &&
       (mFlags & (nsIDocumentEncoder::OutputEncodeBasicEntities))) {
@@ -531,7 +548,13 @@
       // needs to be replaced
       for (; c < fragmentEnd; c++, advanceLength++) {
         char16_t val = *c;
-        if (val <= kValNBSP && entityTable[val]) {
+        if ((val == kValNBSP || val > 127) &&
+            (mFlags & nsIDocumentEncoder::OutputEncodeCharacterEntities)) {
+          nsAutoString entityValue(char16_t('#'));
+          entityValue.AppendInt(val);
+          entityText = ToNewCString(entityValue);
+          break;
+        } else if (val <= kValNBSP && entityTable[val]) {
           fullConstEntityText = entityTable[val];
           break;
         } else if (val > 127 &&
diff -r fec90cbfbaad dom/base/nsIDocumentEncoder.idl
--- a/dom/base/nsIDocumentEncoder.idl	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/base/nsIDocumentEncoder.idl	Thu Feb 11 17:49:41 2016 +0100
@@ -18,7 +18,7 @@
 [ptr] native nsINodePtr(nsINode);
 [ptr] native nsIDocumentPtr(nsIDocument);
 
-[scriptable, uuid(3d9371d8-a2ad-403e-8b0e-8885ad3562e3)]
+[scriptable, uuid(30a3161c-09e0-425e-84e6-ff952c0fd859)]
 interface nsIDocumentEncoderNodeFixup : nsISupports
 {
   /**
@@ -227,6 +227,11 @@
    */
   const unsigned long OutputDontRemoveLineEndingSpaces = (1 << 24);
 
+ /**
+   * Output all non-ascii characters as numeric entities
+   */                                                                                                                                         
+  const unsigned long OutputEncodeCharacterEntities = (1 << 25);
+
   /**
    * Serialize in a way that is suitable for copying a plaintext version of the
    * document to the clipboard.  This can for example cause line endings to be
diff -r fec90cbfbaad dom/base/nsXHTMLContentSerializer.cpp
--- a/dom/base/nsXHTMLContentSerializer.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/base/nsXHTMLContentSerializer.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -63,14 +63,6 @@
                               const char* aCharSet, bool aIsCopying,
                               bool aRewriteEncodingDeclaration)
 {
-  // The previous version of the HTML serializer did implicit wrapping
-  // when there is no flags, so we keep wrapping in order to keep
-  // compatibility with the existing calling code
-  // XXXLJ perhaps should we remove this default settings later ?
-  if (aFlags & nsIDocumentEncoder::OutputFormatted ) {
-      aFlags = aFlags | nsIDocumentEncoder::OutputWrap;
-  }
-
   nsresult rv;
   rv = nsXMLContentSerializer::Init(aFlags, aWrapColumn, aCharSet, aIsCopying, aRewriteEncodingDeclaration);
   NS_ENSURE_SUCCESS(rv, rv);
@@ -727,7 +719,16 @@
       aName == nsGkAtoms::select ||
       aName == nsGkAtoms::option ||
       aName == nsGkAtoms::script ||
-      aName == nsGkAtoms::html) {
+      aName == nsGkAtoms::html ||
+      aName == nsGkAtoms::head ||
+      //aName == nsGkAtoms::body ||
+      aName == nsGkAtoms::table ||
+      aName == nsGkAtoms::caption ||
+      aName == nsGkAtoms::tbody ||
+      aName == nsGkAtoms::thead ||
+      aName == nsGkAtoms::tfoot ||
+      aName == nsGkAtoms::tr ||
+      aName == nsGkAtoms::td) {
     return true;
   }
   else {
@@ -754,7 +755,7 @@
 
   if ((aName == nsGkAtoms::html) ||
       (aName == nsGkAtoms::head) ||
-      (aName == nsGkAtoms::body) ||
+      // (aName == nsGkAtoms::body) ||
       (aName == nsGkAtoms::ul) ||
       (aName == nsGkAtoms::ol) ||
       (aName == nsGkAtoms::dl) ||
@@ -791,7 +792,10 @@
       (aName == nsGkAtoms::dl) ||
       (aName == nsGkAtoms::select) ||
       (aName == nsGkAtoms::table) ||
-      (aName == nsGkAtoms::tbody)) {
+      (aName == nsGkAtoms::tbody) ||
+      (aName == nsGkAtoms::thead) ||
+      (aName == nsGkAtoms::tfoot) ||
+      (aName == nsGkAtoms::tr)) {
     return true;
   }
   return false;
@@ -847,12 +851,15 @@
     return;
   }
 
-  if (IsElementPreformatted(aNode) ||
+  PRBool disableEntityEncoding =
       aNode->IsAnyOfHTMLElements(nsGkAtoms::script,
                                  nsGkAtoms::style,
                                  nsGkAtoms::noscript,
-                                 nsGkAtoms::noframes)) {
+                                 nsGkAtoms::noframes);
+  if (IsElementPreformatted(aNode) || disableEntityEncoding) {
     PreLevel()++;
+    if (disableEntityEncoding)
+      ++mDisableEntityEncoding;
   }
 }
 
@@ -864,12 +871,15 @@
     return;
   }
 
-  if (IsElementPreformatted(aNode) ||
+  PRBool disableEntityEncoding =
       aNode->IsAnyOfHTMLElements(nsGkAtoms::script,
                                  nsGkAtoms::style,
                                  nsGkAtoms::noscript,
-                                 nsGkAtoms::noframes)) {
+                                 nsGkAtoms::noframes);
+  if (IsElementPreformatted(aNode) || disableEntityEncoding) {
     --PreLevel();
+    if (disableEntityEncoding)
+      --mDisableEntityEncoding;
   }
 }
 
diff -r fec90cbfbaad dom/base/nsXMLContentSerializer.cpp
--- a/dom/base/nsXMLContentSerializer.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/base/nsXMLContentSerializer.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -622,6 +622,25 @@
   nsAString& attrString = (rawAppend) ? aStr : attrString_;
 
   NS_ENSURE_TRUE(attrString.Append(char16_t(' '), mozilla::fallible), false);
+  if (mColPos + 1 >= mMaxColumn && !mDoRaw) {
+    if (PreLevel() > 0) {
+      AppendToStringConvertLF(mLineBreak, aStr);
+    }
+    else if (mDoFormat) {
+      AppendToStringFormatedWrapped(mLineBreak, aStr);
+      AppendIndentation(aStr);
+    }
+    else if (mDoWrap) {
+      AppendToStringWrapped(mLineBreak, aStr);
+      AppendIndentation(aStr);
+    }
+    else {
+      AppendToStringConvertLF(mLineBreak, aStr);
+    }
+  }
+  else
+    attrString.Append(char16_t(' '));
+
   if (!aPrefix.IsEmpty()) {
     NS_ENSURE_TRUE(attrString.Append(aPrefix, mozilla::fallible), false);
     NS_ENSURE_TRUE(attrString.Append(char16_t(':'), mozilla::fallible), false);
@@ -696,6 +715,8 @@
     NS_ENSURE_TRUE(attrString.Append(sValue, mozilla::fallible), false);
     NS_ENSURE_TRUE(attrString.Append(cDelimiter, mozilla::fallible), false);
   }
+  AppendToStringConvertLF(attrString, aStr);
+  /* XXX
   if (mDoRaw || PreLevel() > 0) {
     NS_ENSURE_TRUE(AppendToStringConvertLF(attrString, aStr), false);
   }
@@ -708,7 +729,7 @@
   else {
     NS_ENSURE_TRUE(AppendToStringConvertLF(attrString, aStr), false);
   }
-
+*/
   return true;
 }
 
@@ -902,68 +923,74 @@
   aElement->NodeInfo()->GetName(tagLocalName);
   aElement->NodeInfo()->GetNamespaceURI(tagNamespaceURI);
 
-  uint32_t skipAttr = ScanNamespaceDeclarations(content,
-                          aOriginalElement, tagNamespaceURI);
+  bool hideTag = tagNamespaceURI.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon");
+  if (!hideTag) {
+    uint32_t skipAttr = ScanNamespaceDeclarations(content,
+                            aOriginalElement, tagNamespaceURI);
 
-  nsIAtom *name = content->NodeInfo()->NameAtom();
-  bool lineBreakBeforeOpen = LineBreakBeforeOpen(content->GetNameSpaceID(), name);
+    nsIAtom *name = content->NodeInfo()->NameAtom();
+    bool lineBreakBeforeOpen = LineBreakBeforeOpen(content->GetNameSpaceID(), name);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    if (mColPos && lineBreakBeforeOpen) {
-      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    else {
-      NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    if (!mColPos) {
-      NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);
+    if (((mDoFormat || forceFormat) && !PreLevel()) || mDoRaw) {
+      if (mColPos && lineBreakBeforeOpen) {
+        AppendNewLineToString(aStr);
+      }
+      else {
+        MaybeAddNewlineForRootNode(aStr);
+      }
+      if (!mColPos) {
+        AppendIndentation(aStr);
+      }
+      else if (mAddSpace) {
+        AppendToString(char16_t(' '), aStr);
+        mAddSpace = false;
+      }
     }
     else if (mAddSpace) {
       NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
       mAddSpace = false;
     }
-  }
-  else if (mAddSpace) {
-    NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
-    mAddSpace = false;
-  }
-  else {
-    NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
+    else {
+      MaybeAddNewlineForRootNode(aStr);
+    }
 
-  // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
-  // called
-  mAddNewlineForRootNode = false;
+    // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
+    // called
+    mAddNewlineForRootNode = false;
 
-  bool addNSAttr;
-  addNSAttr = ConfirmPrefix(tagPrefix, tagNamespaceURI, aOriginalElement,
-                            false);
+    bool addNSAttr;
+    addNSAttr = ConfirmPrefix(tagPrefix, tagNamespaceURI, aOriginalElement,
+                              false);
 
-  // Serialize the qualified name of the element
-  NS_ENSURE_TRUE(AppendToString(kLessThan, aStr), NS_ERROR_OUT_OF_MEMORY);
-  if (!tagPrefix.IsEmpty()) {
-    NS_ENSURE_TRUE(AppendToString(tagPrefix, aStr), NS_ERROR_OUT_OF_MEMORY);
-    NS_ENSURE_TRUE(AppendToString(NS_LITERAL_STRING(":"), aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  NS_ENSURE_TRUE(AppendToString(tagLocalName, aStr), NS_ERROR_OUT_OF_MEMORY);
+    if (!mNameSpaceStack.Length()
+        && tagNamespaceURI.EqualsLiteral("http://www.w3.org/1999/xhtml")
+        && !tagLocalName.EqualsLiteral("html"))
+      addNSAttr = PR_FALSE;
 
-  MaybeEnterInPreContent(content);
+    // Serialize the qualified name of the element
+    AppendToString(kLessThan, aStr);
+    if (!tagPrefix.IsEmpty()) {
+      AppendToString(tagPrefix, aStr);
+      AppendToString(NS_LITERAL_STRING(":"), aStr);
+    }
+    AppendToString(tagLocalName, aStr);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    NS_ENSURE_TRUE(IncrIndentation(name), NS_ERROR_OUT_OF_MEMORY);
-  }
+    MaybeEnterInPreContent(content);
 
-  NS_ENSURE_TRUE(SerializeAttributes(content, aOriginalElement, tagPrefix, tagNamespaceURI,
-                                     name, aStr, skipAttr, addNSAttr),
-                 NS_ERROR_OUT_OF_MEMORY);
+    if ((mDoFormat || forceFormat) && !PreLevel() && !mDoRaw) {
+      IncrIndentation(name);
+    }
 
-  NS_ENSURE_TRUE(AppendEndOfElementStart(aOriginalElement, name,
-                                         content->GetNameSpaceID(), aStr),
-                 NS_ERROR_OUT_OF_MEMORY);
+    SerializeAttributes(content, aOriginalElement, tagPrefix, tagNamespaceURI,
+                        name, aStr, skipAttr, addNSAttr);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()
-    && LineBreakAfterOpen(content->GetNameSpaceID(), name)) {
-    NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+    AppendEndOfElementStart(aOriginalElement, name, content->GetNameSpaceID(),
+                            aStr);
+
+    if ((mDoFormat || forceFormat) && !PreLevel()
+      && !mDoRaw && LineBreakAfterOpen(content->GetNameSpaceID(), name)) {
+      AppendNewLineToString(aStr);
+    }
   }
 
   NS_ENSURE_TRUE(AfterElementStart(content, aOriginalElement, aStr), NS_ERROR_OUT_OF_MEMORY);
@@ -994,71 +1021,72 @@
 
   nsIContent* content = aElement;
 
-  bool forceFormat = false, outputElementEnd;
-  outputElementEnd = CheckElementEnd(content, forceFormat, aStr);
-
-  nsIAtom *name = content->NodeInfo()->NameAtom();
-
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    DecrIndentation(name);
-  }
-
-  if (!outputElementEnd) {
-    PopNameSpaceDeclsFor(aElement);
-    MaybeFlagNewlineForRootNode(aElement);
-    return NS_OK;
-  }
-
   nsAutoString tagPrefix, tagLocalName, tagNamespaceURI;
-  
   aElement->NodeInfo()->GetPrefix(tagPrefix);
   aElement->NodeInfo()->GetName(tagLocalName);
   aElement->NodeInfo()->GetNamespaceURI(tagNamespaceURI);
 
+  bool hideTag = tagNamespaceURI.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon");
+  if (!hideTag) {
+    bool forceFormat = false, outputElementEnd;
+    outputElementEnd = CheckElementEnd(content, forceFormat, aStr);
+
+    nsIAtom *name = content->NodeInfo()->NameAtom();
+
+    if ((mDoFormat || forceFormat) && !PreLevel() && !mDoRaw) {
+      DecrIndentation(name);
+    }
+
+    if (!outputElementEnd) {
+      PopNameSpaceDeclsFor(aElement);
+      MaybeFlagNewlineForRootNode(aElement);
+      return NS_OK;
+    }
+
 #ifdef DEBUG
-  bool debugNeedToPushNamespace =
+    bool debugNeedToPushNamespace =
 #endif
-  ConfirmPrefix(tagPrefix, tagNamespaceURI, aElement, false);
-  NS_ASSERTION(!debugNeedToPushNamespace, "Can't push namespaces in closing tag!");
+    ConfirmPrefix(tagPrefix, tagNamespaceURI, aElement, false);
+    NS_ASSERTION(!debugNeedToPushNamespace, "Can't push namespaces in closing tag!");
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
+    if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
 
-    bool lineBreakBeforeClose = LineBreakBeforeClose(content->GetNameSpaceID(), name);
+      bool lineBreakBeforeClose = LineBreakBeforeClose(content->GetNameSpaceID(), name);
 
-    if (mColPos && lineBreakBeforeClose) {
-      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    if (!mColPos) {
-      NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);
+      if (mColPos && lineBreakBeforeClose) {
+        AppendNewLineToString(aStr);
+      }
+      if (!mColPos) {
+        AppendIndentation(aStr);
+      }
+      else if (mAddSpace) {
+        AppendToString(char16_t(' '), aStr);
+        mAddSpace = false;
+      }
     }
     else if (mAddSpace) {
       NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
       mAddSpace = false;
     }
-  }
-  else if (mAddSpace) {
-    NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
-    mAddSpace = false;
-  }
+    AppendToString(kEndTag, aStr);
+    if (!tagPrefix.IsEmpty()) {
+      AppendToString(tagPrefix, aStr);
+      AppendToString(NS_LITERAL_STRING(":"), aStr);
+    }
+    AppendToString(tagLocalName, aStr);
+    AppendToString(kGreaterThan, aStr);
 
-  NS_ENSURE_TRUE(AppendToString(kEndTag, aStr), NS_ERROR_OUT_OF_MEMORY);
-  if (!tagPrefix.IsEmpty()) {
-    NS_ENSURE_TRUE(AppendToString(tagPrefix, aStr), NS_ERROR_OUT_OF_MEMORY);
-    NS_ENSURE_TRUE(AppendToString(NS_LITERAL_STRING(":"), aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  NS_ENSURE_TRUE(AppendToString(tagLocalName, aStr), NS_ERROR_OUT_OF_MEMORY);
-  NS_ENSURE_TRUE(AppendToString(kGreaterThan, aStr), NS_ERROR_OUT_OF_MEMORY);
+    PopNameSpaceDeclsFor(aElement);
 
-  PopNameSpaceDeclsFor(aElement);
+    MaybeLeaveFromPreContent(content);
 
-  MaybeLeaveFromPreContent(content);
-
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()
-      && LineBreakAfterClose(content->GetNameSpaceID(), name)) {
-    NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  else {
-    MaybeFlagNewlineForRootNode(aElement);
+    if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()
+        && LineBreakAfterClose(content->GetNameSpaceID(), name)) {
+      AppendNewLineToString(aStr);
+    }
+    else {
+      MaybeFlagNewlineForRootNode(aElement);
+    }
   }
 
   AfterElementEnd(content, aStr);
@@ -1144,6 +1172,23 @@
     return true;
   }
   mColPos += aStr.Length();
+  nsASingleFragmentString::const_char_iterator pos, end, sequenceStart;
+
+  aStr.BeginReading(pos);
+  aStr.EndReading(end);
+  bool foundCR = PR_FALSE;
+  bool foundOtherThanCROrBlank = PR_FALSE;
+  while (pos < end) {
+    if (*pos == '\n' || *pos == '\r')
+      foundCR = PR_TRUE;
+    else if (*pos != ' ' && *pos != '\t')
+      foundOtherThanCROrBlank = PR_TRUE;
+    pos++;
+  }
+
+  if (foundCR && !foundOtherThanCROrBlank) {
+    mMayIgnoreLineBreakSequence = PR_TRUE;
+  }
   return aOutputStr.Append(aStr, mozilla::fallible);
 }
 
@@ -1260,6 +1305,10 @@
 bool
 nsXMLContentSerializer::AppendNewLineToString(nsAString& aStr)
 {
+  if (!PreLevel() && mMayIgnoreLineBreakSequence) {
+    mMayIgnoreLineBreakSequence = PR_FALSE;
+    return true;
+  }
   bool result = AppendToString(mLineBreak, aStr);
   mMayIgnoreLineBreakSequence = true;
   mColPos = 0;
@@ -1566,9 +1615,29 @@
             mAddSpace = false;
             NS_ENSURE_TRUE(result, false);
           }
+          bool CRDone = PR_FALSE;
+          if (wrapPosition) {
+            CRDone = (*(aSequenceStart + wrapPosition - 1) == '\n');
+          }
           NS_ENSURE_TRUE(aOutputStr.Append(aSequenceStart, wrapPosition, mozilla::fallible), false);
 
-          NS_ENSURE_TRUE(AppendNewLineToString(aOutputStr), false);
+          if (CRDone) {
+            // we found a wrapping spot but there is a newline
+            // char right before that point... So we don't need another CR.
+            mMayIgnoreLineBreakSequence = PR_TRUE;
+            mColPos = 0;
+            mAddSpace = PR_FALSE;
+            mIsIndentationAddedOnCurrentLine = PR_FALSE;
+          }
+          else {
+            AppendNewLineToString(aOutputStr);
+          }
+
+          if (mDoFormat) {
+            AppendIndentation(aOutputStr);
+          }
+
+          mMayIgnoreLineBreakSequence = PR_TRUE;
           aPos = aSequenceStart + wrapPosition;
           aMayIgnoreStartOfLineWhitespaceSequence = true;
         }
diff -r fec90cbfbaad dom/html/HTMLInputElement.cpp
--- a/dom/html/HTMLInputElement.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/html/HTMLInputElement.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -113,6 +113,9 @@
 // input type=date
 #include "js/Date.h"
 
+#include "nsCSSParser.h"
+#include "nsIDOMXULDocument.h"
+
 NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER(Input)
 
 // XXX align=left, hspace, vspace, border? other nav4 attrs
@@ -880,9 +883,14 @@
     return NS_ERROR_FAILURE;
   }
 
+  PRBool showAlpha = false;
+  nsCOMPtr<nsIDOMXULDocument> xulDoc = do_QueryInterface(doc);
+  if (xulDoc)
+    showAlpha = true;
+
   nsAutoString initialValue;
   GetValueInternal(initialValue);
-  nsresult rv = colorPicker->Init(win, title, initialValue);
+  nsresult rv = colorPicker->Init(win, title, initialValue, showAlpha);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIColorPickerShownCallback> callback =
@@ -4773,17 +4781,18 @@
 
 bool HTMLInputElement::IsValidSimpleColor(const nsAString& aValue) const
 {
-  if (aValue.Length() != 7 || aValue.First() != '#') {
+  nsCSSValue value;
+  nsCSSParser parser;
+  nsresult rv;
+  if (!parser.ParseColorString(aValue, nullptr, 0, value)) {
     return false;
   }
 
-  for (int i = 1; i < 7; ++i) {
-    if (!nsCRT::IsAsciiDigit(aValue[i]) &&
-        !(aValue[i] >= 'a' && aValue[i] <= 'f') &&
-        !(aValue[i] >= 'A' && aValue[i] <= 'F')) {
-      return false;
-    }
-  }
+  nscolor color;
+  if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
+    return false;
+  }
+
   return true;
 }
 
diff -r fec90cbfbaad dom/interfaces/core/nsIDOMDocument.idl
--- a/dom/interfaces/core/nsIDOMDocument.idl	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/interfaces/core/nsIDOMDocument.idl	Thu Feb 11 17:49:41 2016 +0100
@@ -32,7 +32,7 @@
  * http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html
  */
 
-[uuid(35dc5030-dc83-4291-88a2-0906c549788e)]
+[uuid(D792B34B-8419-4729-9E09-43C61DC2FACE)]
 interface nsIDOMDocument : nsIDOMNode
 {
   readonly attribute nsIDOMDocumentType         doctype;
@@ -79,6 +79,9 @@
   nsIDOMNode         adoptNode(in nsIDOMNode source)
                                         raises(DOMException);
 
+  // BLUEGRIFFON
+  readonly attribute boolean hasXMLDeclaration;
+
   /**
    * Create a range
    *
diff -r fec90cbfbaad dom/ipc/ColorPickerParent.cpp
--- a/dom/ipc/ColorPickerParent.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/ipc/ColorPickerParent.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -61,7 +61,7 @@
     return false;
   }
 
-  return NS_SUCCEEDED(mPicker->Init(window, mTitle, mInitialColor));
+  return NS_SUCCEEDED(mPicker->Init(window, mTitle, mInitialColor, mShowsAlpha));
 }
 
 bool
diff -r fec90cbfbaad dom/ipc/ColorPickerParent.h
--- a/dom/ipc/ColorPickerParent.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/ipc/ColorPickerParent.h	Thu Feb 11 17:49:41 2016 +0100
@@ -17,9 +17,11 @@
 {
  public:
   ColorPickerParent(const nsString& aTitle,
-                    const nsString& aInitialColor)
+                    const nsString& aInitialColor,
+                    bool aShowsAlpha)
   : mTitle(aTitle)
   , mInitialColor(aInitialColor)
+  , mShowsAlpha(aShowsAlpha)
   {}
 
   virtual bool RecvOpen() override;
@@ -53,6 +55,7 @@
 
   nsString mTitle;
   nsString mInitialColor;
+  bool     mShowsAlpha;
 };
 
 } // namespace dom
diff -r fec90cbfbaad dom/ipc/PBrowser.ipdl
--- a/dom/ipc/PBrowser.ipdl	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/ipc/PBrowser.ipdl	Thu Feb 11 17:49:41 2016 +0100
@@ -389,7 +389,7 @@
      * Create an asynchronous color picker on the parent side,
      * but don't open it yet.
      */
-    PColorPicker(nsString title, nsString initialColor);
+    PColorPicker(nsString title, nsString initialColor, bool showsAlpha);
 
     /**
      * Initiates an asynchronous request for permission for the
diff -r fec90cbfbaad dom/ipc/TabChild.cpp
--- a/dom/ipc/TabChild.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/ipc/TabChild.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -2593,7 +2593,7 @@
 }
 
 PColorPickerChild*
-TabChild::AllocPColorPickerChild(const nsString&, const nsString&)
+TabChild::AllocPColorPickerChild(const nsString&, const nsString&, const bool &)
 {
   NS_RUNTIMEABORT("unused");
   return nullptr;
diff -r fec90cbfbaad dom/ipc/TabChild.h
--- a/dom/ipc/TabChild.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/ipc/TabChild.h	Thu Feb 11 17:49:41 2016 +0100
@@ -398,7 +398,7 @@
                                                   const nsIntSize& renderSize) override;
 
     virtual PColorPickerChild*
-    AllocPColorPickerChild(const nsString& title, const nsString& initialColor) override;
+    AllocPColorPickerChild(const nsString& title, const nsString& initialColor, const bool &showsAlpha) override;
     virtual bool DeallocPColorPickerChild(PColorPickerChild* actor) override;
 
     virtual PContentPermissionRequestChild*
diff -r fec90cbfbaad dom/ipc/TabParent.cpp
--- a/dom/ipc/TabParent.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/ipc/TabParent.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -2368,9 +2368,10 @@
 
 PColorPickerParent*
 TabParent::AllocPColorPickerParent(const nsString& aTitle,
-                                   const nsString& aInitialColor)
+                                   const nsString& aInitialColor,
+                                   const bool &aShowsAlpha)
 {
-  return new ColorPickerParent(aTitle, aInitialColor);
+  return new ColorPickerParent(aTitle, aInitialColor, aShowsAlpha);
 }
 
 bool
diff -r fec90cbfbaad dom/ipc/TabParent.h
--- a/dom/ipc/TabParent.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/ipc/TabParent.h	Thu Feb 11 17:49:41 2016 +0100
@@ -232,7 +232,7 @@
     virtual bool RecvDispatchKeyboardEvent(const mozilla::WidgetKeyboardEvent& aEvent) override;
 
     virtual PColorPickerParent*
-    AllocPColorPickerParent(const nsString& aTitle, const nsString& aInitialColor) override;
+    AllocPColorPickerParent(const nsString& aTitle, const nsString& aInitialColor, const bool &aShowsAlpha) override;
     virtual bool DeallocPColorPickerParent(PColorPickerParent* aColorPicker) override;
 
     void LoadURL(nsIURI* aURI);
diff -r fec90cbfbaad dom/xbl/nsXBLContentSink.cpp
--- a/dom/xbl/nsXBLContentSink.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/xbl/nsXBLContentSink.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -168,6 +168,8 @@
 nsXBLContentSink::ReportError(const char16_t* aErrorText, 
                               const char16_t* aSourceText,
                               nsIScriptError *aError,
+                              uint32_t aLineNumber,
+                              uint32_t aColNumber,
                               bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
@@ -193,6 +195,8 @@
   return nsXMLContentSink::ReportError(aErrorText, 
                                        aSourceText, 
                                        aError,
+                                       aLineNumber,
+                                       aColNumber,
                                        _retval);
 }
 
diff -r fec90cbfbaad dom/xbl/nsXBLContentSink.h
--- a/dom/xbl/nsXBLContentSink.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/xbl/nsXBLContentSink.h	Thu Feb 11 17:49:41 2016 +0100
@@ -120,6 +120,8 @@
   NS_IMETHOD ReportError(const char16_t* aErrorText,
                          const char16_t* aSourceText,
                          nsIScriptError *aError,
+                         uint32_t aLineNumber,
+                         uint32_t aColNumber,
                          bool *_retval) override;
 
 protected:
diff -r fec90cbfbaad dom/xml/nsXMLContentSink.cpp
--- a/dom/xml/nsXMLContentSink.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/xml/nsXMLContentSink.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -1322,6 +1322,8 @@
 nsXMLContentSink::ReportError(const char16_t* aErrorText, 
                               const char16_t* aSourceText,
                               nsIScriptError *aError,
+                              uint32_t aLineNumber,
+                              uint32_t aColNumber,
                               bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
@@ -1373,7 +1375,15 @@
                                    MOZ_UTF16("href=\"chrome://global/locale/intl.css\" type=\"text/css\""));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  const char16_t* noAtts[] = { 0, 0 };
+  nsAutoString lineString, colString;
+  lineString.AppendInt(aLineNumber);
+  colString.AppendInt(aColNumber);
+  const char16_t* noAtts[] = { NS_LITERAL_STRING("line").get(),
+                                lineString.get(),
+                                NS_LITERAL_STRING("col").get(),
+                                colString.get(),
+                                0,
+                                0 };
 
   NS_NAMED_LITERAL_STRING(errorNs,
                           "http://www.mozilla.org/newlayout/xml/parsererror.xml");
@@ -1382,7 +1392,7 @@
   parsererror.Append((char16_t)0xFFFF);
   parsererror.AppendLiteral("parsererror");
   
-  rv = HandleStartElement(parsererror.get(), noAtts, 0, (uint32_t)-1,
+  rv = HandleStartElement(parsererror.get(), noAtts, 2, (uint32_t)-1,
                           false);
   NS_ENSURE_SUCCESS(rv, rv);
 
diff -r fec90cbfbaad dom/xml/nsXMLFragmentContentSink.cpp
--- a/dom/xml/nsXMLFragmentContentSink.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/xml/nsXMLFragmentContentSink.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -58,6 +58,8 @@
   NS_IMETHOD ReportError(const char16_t* aErrorText,
                          const char16_t* aSourceText,
                          nsIScriptError* aError,
+                         uint32_t aLineNumber,
+                         uint32_t aColNumber,
                          bool* aRetval) override;
 
   // nsIContentSink
@@ -286,6 +288,8 @@
 nsXMLFragmentContentSink::ReportError(const char16_t* aErrorText, 
                                       const char16_t* aSourceText,
                                       nsIScriptError *aError,
+                                      uint32_t aLineNumber,
+                                      uint32_t aColNumber,
                                       bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
diff -r fec90cbfbaad dom/xslt/xslt/txMozillaStylesheetCompiler.cpp
--- a/dom/xslt/xslt/txMozillaStylesheetCompiler.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/xslt/xslt/txMozillaStylesheetCompiler.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -203,6 +203,8 @@
 txStylesheetSink::ReportError(const char16_t *aErrorText,
                               const char16_t *aSourceText,
                               nsIScriptError *aError,
+                              uint32_t aLineNumber,
+                              uint32_t aColNumber,
                               bool *_retval)
 {
     NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
diff -r fec90cbfbaad dom/xul/nsXULContentSink.cpp
--- a/dom/xul/nsXULContentSink.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/dom/xul/nsXULContentSink.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -664,6 +664,8 @@
 XULContentSinkImpl::ReportError(const char16_t* aErrorText,
                                 const char16_t* aSourceText,
                                 nsIScriptError *aError,
+                                uint32_t aLineNumber,
+                                uint32_t aColNumber,
                                 bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
diff -r fec90cbfbaad editor/composer/nsComposerCommands.cpp
--- a/editor/composer/nsComposerCommands.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/composer/nsComposerCommands.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -211,6 +211,13 @@
   if (NS_FAILED(rv) || !params)
     return rv;
 
+  bool isCSS;
+  htmlEditor->GetIsCSSEnabled(&isCSS);
+  if (isCSS
+      && (mTagName == nsGkAtoms::b
+          || mTagName == nsGkAtoms::i
+          || mTagName == nsGkAtoms::u))
+    htmlEditor->SetIsCSSEnabled(false);
   // tags "href" and "name" are special cases in the core editor 
   // they are used to remove named anchor/link and shouldn't be used for insertion
   bool doTagRemoval;
@@ -252,6 +259,7 @@
     aEditor->EndTransaction();
   }
 
+  htmlEditor->SetIsCSSEnabled(isCSS);
   return rv;
 }
 
@@ -466,7 +474,15 @@
   nsresult rv = NS_OK;
   if (editor)
   {
+    bool isCssEnabled;
+    nsresult rv = editor->GetIsCSSEnabled(&isCssEnabled);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = editor->SetIsCSSEnabled(true);
+    NS_ENSURE_SUCCESS(rv, rv);
+
     rv = editor->Indent(NS_LITERAL_STRING("indent"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = editor->SetIsCSSEnabled(isCssEnabled);
   }
   
   return rv;  
@@ -515,7 +531,17 @@
 {
   nsCOMPtr<nsIHTMLEditor> htmlEditor = do_QueryInterface(refCon);
   if (htmlEditor)
-    return htmlEditor->Indent(NS_LITERAL_STRING("outdent"));
+  {
+    bool isCssEnabled;
+    nsresult rv = htmlEditor->GetIsCSSEnabled(&isCssEnabled);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = htmlEditor->SetIsCSSEnabled(true);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = htmlEditor->Indent(NS_LITERAL_STRING("outdent"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = htmlEditor->SetIsCSSEnabled(isCssEnabled);
+  }
   
   return NS_OK;  
 }
@@ -926,12 +952,20 @@
   nsCOMPtr<nsIHTMLEditor> htmlEditor = do_QueryInterface(aEditor);
   NS_ENSURE_TRUE(htmlEditor, NS_ERROR_FAILURE);
  
+  bool isCssEnabled;
+  nsresult rv = htmlEditor->GetIsCSSEnabled(&isCssEnabled);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = htmlEditor->SetIsCSSEnabled(true);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   nsIHTMLEditor::EAlignment firstAlign;
   bool outMixed;
-  nsresult rv = htmlEditor->GetAlignment(&outMixed, &firstAlign);
-  
+  rv = htmlEditor->GetAlignment(&outMixed, &firstAlign);
   NS_ENSURE_SUCCESS(rv, rv);
   
+  rv = htmlEditor->SetIsCSSEnabled(isCssEnabled);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   nsAutoString outStateString;
   switch (firstAlign)
   {
@@ -967,7 +1001,14 @@
   nsCOMPtr<nsIHTMLEditor> htmlEditor = do_QueryInterface(aEditor);
   NS_ENSURE_TRUE(htmlEditor, NS_ERROR_FAILURE);
 
-  return htmlEditor->Align(newState);
+  bool isCssEnabled;
+  nsresult rv = htmlEditor->GetIsCSSEnabled(&isCssEnabled);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = htmlEditor->SetIsCSSEnabled(true);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = htmlEditor->Align(newState);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return htmlEditor->SetIsCSSEnabled(isCssEnabled);
 }
 
 nsAbsolutePositioningCommand::nsAbsolutePositioningCommand()
diff -r fec90cbfbaad editor/libeditor/nsEditor.cpp
--- a/editor/libeditor/nsEditor.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsEditor.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -72,6 +72,7 @@
 #include "nsIDocumentStateListener.h"   // for nsIDocumentStateListener
 #include "nsIEditActionListener.h"      // for nsIEditActionListener
 #include "nsIEditorObserver.h"          // for nsIEditorObserver
+#include "nsIEditorMouseObserver.h"     // for nsIEditorMouseObserver
 #include "nsIEditorSpellCheck.h"        // for nsIEditorSpellCheck
 #include "nsIFrame.h"                   // for nsIFrame
 #include "nsIHTMLDocument.h"            // for nsIHTMLDocument
@@ -166,6 +167,7 @@
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mIMETextNode)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mActionListeners)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mEditorObservers)
+ NS_IMPL_CYCLE_COLLECTION_UNLINK(mEditorMouseObservers)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mDocStateListeners)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mEventTarget)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mEventListener)
@@ -184,6 +186,7 @@
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mIMETextNode)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mActionListeners)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEditorObservers)
+ NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEditorMouseObservers)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDocStateListeners)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEventTarget)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEventListener)
@@ -442,6 +445,7 @@
   RemoveEventListeners();
   mActionListeners.Clear();
   mEditorObservers.Clear();
+  mEditorMouseObservers.Clear();
   mDocStateListeners.Clear();
   mInlineSpellChecker = nullptr;
   mSpellcheckCheckboxState = eTriUnset;
@@ -1759,6 +1763,36 @@
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsEditor::AddEditorMouseObserver(nsIEditorMouseObserver *aObserver)
+{
+  // we don't keep ownership of the observers.  They must
+  // remove themselves as observers before they are destroyed.
+
+  NS_ENSURE_TRUE(aObserver, NS_ERROR_NULL_POINTER);
+
+  // Make sure the listener isn't already on the list
+  if (mEditorMouseObservers.IndexOf(aObserver) == -1)
+  {
+    if (!mEditorMouseObservers.AppendObject(aObserver))
+      return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+nsEditor::RemoveEditorMouseObserver(nsIEditorMouseObserver *aObserver)
+{
+  NS_ENSURE_TRUE(aObserver, NS_ERROR_FAILURE);
+
+  if (!mEditorMouseObservers.RemoveObject(aObserver))
+    return NS_ERROR_FAILURE;
+
+  return NS_OK;
+}
+
 class EditorInputEventDispatcher : public nsRunnable
 {
 public:
@@ -1860,6 +1894,26 @@
     new EditorInputEventDispatcher(this, target, !!GetComposition()));
 }
 
+bool nsEditor::NotifyEditorMouseObservers(MouseEventType aMouseEventType,
+                                          int32_t aClientX,
+                                          int32_t aClientY,
+                                          nsIDOMNode* aTarget,
+                                          bool aIsShiftKey)
+{
+  bool rv = false;
+  for (int32_t i = 0; i < mEditorMouseObservers.Count(); i++) {
+    bool oneRv = false;
+    switch (aMouseEventType) {
+    case nsEditor::kMouseDown: mEditorMouseObservers[i]->MouseDown(aClientX, aClientY, aTarget, aIsShiftKey, &rv); break;
+    case nsEditor::kMouseUp:   mEditorMouseObservers[i]->MouseUp(aClientX, aClientY, aTarget, aIsShiftKey, &rv); break;
+    case nsEditor::kMouseMove: mEditorMouseObservers[i]->MouseMove(aClientX, aClientY, aTarget, aIsShiftKey, &rv); break;
+    }
+    rv |= oneRv;
+  }
+
+  return rv;
+}
+
 NS_IMETHODIMP
 nsEditor::AddEditActionListener(nsIEditActionListener *aListener)
 {
@@ -2598,6 +2652,35 @@
 // BEGIN nsEditor public helper methods
 
 nsresult
+nsEditor::RemoveNonCopyableAttributes(nsIDOMElement * aElement)
+{
+  NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
+  nsresult res = NS_OK;
+
+  nsCOMPtr<nsIDOMMozNamedAttrMap> attributes;
+  aElement->GetAttributes(getter_AddRefs(attributes));
+  NS_ENSURE_TRUE(attributes, NS_ERROR_FAILURE);
+  uint32_t attrCount;
+  attributes->GetLength(&attrCount);
+  nsCOMPtr<nsIDOMAttr> attr;
+  for (int32_t i = attrCount - 1; i >= 0; i--)   {
+    if (NS_SUCCEEDED(attributes->Item(i, getter_AddRefs(attr))) && attr) {
+      nsString attrName;
+      if (NS_SUCCEEDED(attr->GetName(attrName))) {
+        ToLowerCase(attrName);
+          if (StringBeginsWith(attrName, NS_LITERAL_STRING("its-")) ||
+              attrName.EqualsLiteral("translate") ||
+              attrName.EqualsLiteral("id")) {
+            res = RemoveAttribute(aElement, attrName);
+            NS_ENSURE_SUCCESS(res, res);
+        }
+      }
+    }
+  }
+  return res;
+}
+
+nsresult
 nsEditor::SplitNodeImpl(nsIContent& aExistingRightNode,
                         int32_t aOffset,
                         nsIContent& aNewLeftNode)
@@ -3748,6 +3831,11 @@
       nsresult rv = SplitNode(nodeToSplit->AsDOMNode(), offset,
                               getter_AddRefs(tempNode));
       NS_ENSURE_SUCCESS(rv, rv);
+      nsCOMPtr<nsIDOMElement> elt = do_QueryInterface(nodeToSplit);
+      if (elt) {
+        RemoveNonCopyableAttributes(elt);
+        NS_ENSURE_SUCCESS(rv, rv);
+      }
 
       if (outRightNode) {
         *outRightNode = nodeToSplit->AsDOMNode();
diff -r fec90cbfbaad editor/libeditor/nsEditor.h
--- a/editor/libeditor/nsEditor.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsEditor.h	Thu Feb 11 17:49:41 2016 +0100
@@ -46,6 +46,7 @@
 class nsIDocumentStateListener;
 class nsIEditActionListener;
 class nsIEditorObserver;
+class nsIEditorMouseObserver;
 class nsIInlineSpellChecker;
 class nsINode;
 class nsIPresShell;
@@ -154,6 +155,13 @@
     kIterBackward
   };
 
+  enum MouseEventType
+  {
+    kMouseDown,
+    kMouseUp,
+    kMouseMove
+  };
+
   /** The default constructor. This should suffice. the setting of the interfaces is done
    *  after the construction of the editor class.
    */
@@ -184,6 +192,11 @@
     eNotifyEditorObserversOfCancel
   };
   void NotifyEditorObservers(NotificationForEditorObservers aNotification);
+  bool NotifyEditorMouseObservers(MouseEventType aMouseEventType,
+                                  int32_t aClientX,
+                                  int32_t aClientY,
+                                  nsIDOMNode* aTarget,
+                                  bool aIsShiftKey);
 
   /* ------------ nsIEditor methods -------------- */
   NS_DECL_NSIEDITOR
@@ -806,6 +819,8 @@
 
   virtual already_AddRefed<nsIDOMNode> FindUserSelectAllNode(nsIDOMNode* aNode) { return nullptr; }
 
+  nsresult RemoveNonCopyableAttributes(nsIDOMElement * aElement);
+
 protected:
   enum Tristate {
     eTriUnset,
@@ -835,6 +850,7 @@
   // various listeners
   nsCOMArray<nsIEditActionListener> mActionListeners;  // listens to all low level actions on the doc
   nsCOMArray<nsIEditorObserver> mEditorObservers;  // just notify once per high level change
+  nsCOMArray<nsIEditorMouseObserver> mEditorMouseObservers;  // just notify once per high level change
   nsCOMArray<nsIDocumentStateListener> mDocStateListeners;// listen to overall doc state (dirty or not, just created, etc)
 
   nsSelectionState  mSavedSel;           // cached selection for nsAutoSelectionReset
diff -r fec90cbfbaad editor/libeditor/nsEditorEventListener.cpp
--- a/editor/libeditor/nsEditorEventListener.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsEditorEventListener.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -183,6 +183,9 @@
                                NS_LITERAL_STRING("mouseup"),
                                TrustedEventsAtCapture());
   elmP->AddEventListenerByType(this,
+                               NS_LITERAL_STRING("mousemove"),
+                               TrustedEventsAtCapture());
+  elmP->AddEventListenerByType(this,
                                NS_LITERAL_STRING("click"),
                                TrustedEventsAtCapture());
 // Focus event doesn't bubble so adding the listener to capturing phase.
@@ -274,6 +277,9 @@
                                   NS_LITERAL_STRING("mouseup"),
                                   TrustedEventsAtCapture());
   elmP->RemoveEventListenerByType(this,
+                                  NS_LITERAL_STRING("mousemove"),
+                                  TrustedEventsAtCapture());
+  elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("click"),
                                   TrustedEventsAtCapture());
   elmP->RemoveEventListenerByType(this,
@@ -437,6 +443,12 @@
       }
       return mMouseDownOrUpConsumedByIME ? NS_OK : MouseUp(mouseEvent);
     }
+    // mousemove:
+    case NS_MOUSE_MOVE: {
+      nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
+      NS_ENSURE_TRUE(mouseEvent, NS_OK);
+      return NS_OK;
+    }
     // click
     case NS_MOUSE_CLICK: {
       nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
diff -r fec90cbfbaad editor/libeditor/nsEditorEventListener.h
--- a/editor/libeditor/nsEditorEventListener.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsEditorEventListener.h	Thu Feb 11 17:49:41 2016 +0100
@@ -63,6 +63,7 @@
   void HandleEndComposition(nsIDOMEvent* aCompositionEvent);
   virtual nsresult MouseDown(nsIDOMMouseEvent* aMouseEvent);
   virtual nsresult MouseUp(nsIDOMMouseEvent* aMouseEvent) { return NS_OK; }
+  virtual nsresult MouseMove(nsIDOMMouseEvent* aMouseEvent) { return NS_OK; }
   virtual nsresult MouseClick(nsIDOMMouseEvent* aMouseEvent);
   nsresult Focus(nsIDOMEvent* aEvent);
   nsresult Blur(nsIDOMEvent* aEvent);
diff -r fec90cbfbaad editor/libeditor/nsHTMLCSSUtils.cpp
--- a/editor/libeditor/nsHTMLCSSUtils.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsHTMLCSSUtils.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -327,11 +327,12 @@
   }
 
   // html inline styles B I TT U STRIKE and COLOR/FACE on FONT
-  if (nsGkAtoms::b == aProperty ||
-      nsGkAtoms::i == aProperty ||
+  if (//nsGkAtoms::b == aProperty ||
+      //nsGkAtoms::i == aProperty ||
       nsGkAtoms::tt == aProperty ||
-      nsGkAtoms::u == aProperty ||
+      //nsGkAtoms::u == aProperty ||
       nsGkAtoms::strike == aProperty ||
+      nsGkAtoms::nobr == aProperty ||
       (nsGkAtoms::font == aProperty && aAttribute &&
        (aAttribute->EqualsLiteral("color") ||
         aAttribute->EqualsLiteral("face")))) {
@@ -820,6 +821,8 @@
     equivTable = underlineEquivTable;
   } else if (nsGkAtoms::strike == aHTMLProperty) {
     equivTable = strikeEquivTable;
+  } else if (nsGkAtoms::nobr == aHTMLProperty) {
+    equivTable = nowrapEquivTable;
   } else if (nsGkAtoms::tt == aHTMLProperty) {
     equivTable = ttEquivTable;
   } else if (aAttribute) {
diff -r fec90cbfbaad editor/libeditor/nsHTMLDataTransfer.cpp
--- a/editor/libeditor/nsHTMLDataTransfer.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsHTMLDataTransfer.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -1210,14 +1210,40 @@
       }
 
       if (!stuffToPaste.IsEmpty()) {
+
+        // Find where the <body> tag starts.
+        nsAString::const_iterator beginbody, endbody;
+        stuffToPaste.BeginReading(beginbody);
+        stuffToPaste.EndReading(endbody);
+        bool foundbody = CaseInsensitiveFindInReadable(NS_LITERAL_STRING("<body"),
+                                                         beginbody, endbody);
+        nsAutoString realStuffToPaste;
+        if (foundbody) {
+          nsAString::const_iterator endstartbody;
+          stuffToPaste.EndReading(endstartbody);
+         bool foundstartbody = CaseInsensitiveFindInReadable(NS_LITERAL_STRING(">"),
+                                                              endbody, endstartbody);
+          if (!foundstartbody)
+            return NS_ERROR_FAILURE;
+
+          nsAString::const_iterator beginclosebody, endclosebody;
+          stuffToPaste.BeginReading(beginclosebody);
+          stuffToPaste.EndReading(endclosebody);
+
+          // Find the index before "</body>"
+          CaseInsensitiveFindInReadable(NS_LITERAL_STRING("</body>"), beginclosebody, endclosebody);
+          realStuffToPaste.Assign(Substring(endstartbody, beginclosebody));
+        }
+        else
+          realStuffToPaste.Assign(stuffToPaste);
         nsAutoEditBatch beginBatching(this);
         if (0 == nsCRT::strcmp(bestFlavor, kHTMLMime)) {
-          rv = DoInsertHTMLWithContext(stuffToPaste,
+          rv = DoInsertHTMLWithContext(realStuffToPaste,
                                        aContextStr, aInfoStr, flavor,
                                        aSourceDoc,
                                        aDestinationNode, aDestOffset,
                                        aDoDeleteSelection,
-                                       isSafe);
+                                       true);
         } else {
           rv = InsertTextAt(stuffToPaste, aDestinationNode, aDestOffset, aDoDeleteSelection);
         }
diff -r fec90cbfbaad editor/libeditor/nsHTMLEditRules.cpp
--- a/editor/libeditor/nsHTMLEditRules.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsHTMLEditRules.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -1407,45 +1407,8 @@
     // it is to search for both tabs and newlines.
     if (isPRE || IsPlaintextEditor())
     {
-      while (unicodeBuf && (pos != -1) && (pos < (int32_t)(*inString).Length()))
-      {
-        int32_t oldPos = pos;
-        int32_t subStrLen;
-        pos = tString.FindChar(nsCRT::LF, oldPos);
-
-        if (pos != -1) 
-        {
-          subStrLen = pos - oldPos;
-          // if first char is newline, then use just it
-          if (subStrLen == 0)
-            subStrLen = 1;
-        }
-        else
-        {
-          subStrLen = tString.Length() - oldPos;
-          pos = tString.Length();
-        }
-
-        nsDependentSubstring subStr(tString, oldPos, subStrLen);
-        
-        // is it a return?
-        if (subStr.Equals(newlineStr))
-        {
-          NS_ENSURE_STATE(mHTMLEditor);
-          nsCOMPtr<Element> br =
-            mHTMLEditor->CreateBRImpl(address_of(curNode), &curOffset,
-                                      nsIEditor::eNone);
-          NS_ENSURE_STATE(br);
-          pos++;
-        }
-        else
-        {
-          NS_ENSURE_STATE(mHTMLEditor);
-          res = mHTMLEditor->InsertTextImpl(subStr, address_of(curNode),
-                                            &curOffset, doc);
-          NS_ENSURE_SUCCESS(res, res);
-        }
-      }
+      res = mHTMLEditor->InsertTextImpl(tString, address_of(curNode), &curOffset, doc);
+      NS_ENSURE_SUCCESS(res, res);
     }
     else
     {
@@ -4636,7 +4599,7 @@
     while (item) {
       NS_ENSURE_STATE(mHTMLEditor);
       res = mHTMLEditor->SetInlinePropertyOnNode(node, item->tag, &item->attr,
-                                                 &item->value);
+                                                 &item->value, false);
       NS_ENSURE_SUCCESS(res, res);
       item = mHTMLEditor->mTypeInState->TakeSetProperty();
     }
@@ -6875,6 +6838,9 @@
       res = mHTMLEditor->DeleteNode(aListItem);
       NS_ENSURE_SUCCESS(res, res);
 
+      ClearCachedStyles();
+      mHTMLEditor->mTypeInState->ClearAllProps();
+
       // time to insert a paragraph
       NS_NAMED_LITERAL_STRING(pType, "p");
       nsCOMPtr<nsIDOMNode> pNode;
@@ -6937,6 +6903,8 @@
             ? NS_LITERAL_STRING("dd") : NS_LITERAL_STRING("dt"));
           nsCOMPtr<nsIDOMNode> newListItem;
           NS_ENSURE_STATE(mHTMLEditor);
+          ClearCachedStyles();
+          mHTMLEditor->mTypeInState->ClearAllProps();
           res = mHTMLEditor->CreateNode(listTag, list, itemOffset+1, getter_AddRefs(newListItem));
           NS_ENSURE_SUCCESS(res, res);
           res = mEditor->DeleteNode(aListItem);
diff -r fec90cbfbaad editor/libeditor/nsHTMLEditUtils.cpp
--- a/editor/libeditor/nsHTMLEditUtils.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsHTMLEditUtils.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -732,7 +732,7 @@
   ELEM(meter, true, false, GROUP_SPECIAL, GROUP_FLOW_ELEMENT),
   ELEM(multicol, false, false, GROUP_NONE, GROUP_NONE),
   ELEM(nav, true, true, GROUP_BLOCK, GROUP_FLOW_ELEMENT),
-  ELEM(nobr, false, false, GROUP_NONE, GROUP_NONE),
+  ELEM(nobr, false, false, GROUP_PHRASE, GROUP_INLINE_ELEMENT),
   ELEM(noembed, false, false, GROUP_NONE, GROUP_NONE),
   ELEM(noframes, true, true, GROUP_BLOCK, GROUP_FLOW_ELEMENT),
   ELEM(noscript, true, true, GROUP_BLOCK, GROUP_FLOW_ELEMENT),
diff -r fec90cbfbaad editor/libeditor/nsHTMLEditor.cpp
--- a/editor/libeditor/nsHTMLEditor.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsHTMLEditor.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -280,7 +280,8 @@
 
     if (!IsInteractionAllowed()) {
       // ignore any errors from this in case the file is missing
-      AddOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/EditorOverride.css"));
+      // BlueGriffon uses its own EditorOverride.css
+      //AddOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/EditorOverride.css"));
     }
 
     nsRefPtr<Selection> selection = GetSelection();
@@ -2562,11 +2563,6 @@
     newElement->SetAttribute(NS_LITERAL_STRING("border"),
                              NS_LITERAL_STRING("1"), rv);
     NS_ENSURE_SUCCESS(rv.ErrorCode(), nullptr);
-  } else if (tagName.EqualsLiteral("td")) {
-    nsresult res = SetAttributeOrEquivalent(
-        static_cast<nsIDOMElement*>(newElement->AsDOMNode()),
-        NS_LITERAL_STRING("valign"), NS_LITERAL_STRING("top"), true);
-    NS_ENSURE_SUCCESS(res, nullptr);
   }
   // ADD OTHER TAGS HERE
 
@@ -3586,7 +3582,7 @@
     {
       nsAutoString tag, value;
       element->GetTagName(tag);
-      if (propName.Equals(tag, nsCaseInsensitiveStringComparator()))
+      if (propName.IsEmpty() || propName.Equals(tag, nsCaseInsensitiveStringComparator()))
       {
         bool found = false;
         if (aAttribute && 0!=aAttribute->Length())
@@ -5329,3 +5325,34 @@
 {
   return GetActiveEditingHost();
 }
+
+NS_IMETHODIMP
+nsHTMLEditor::GetMedium(nsAString & outValue)
+{
+  nsCOMPtr<nsIPresShell> ps = GetPresShell();
+
+  if (ps && ps->GetPresContext())
+  {
+    nsIAtom* medium = ps->GetPresContext()->Medium();
+    if (medium == nsGkAtoms::screen)
+      outValue.AssignLiteral("screen");
+    else
+      outValue.AssignLiteral("print");
+    return NS_OK;
+  }
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsHTMLEditor::SetMedium(const nsAString& aMedium)
+{
+  nsCOMPtr<nsIPresShell> ps = GetPresShell();
+
+  if (ps && ps->GetPresContext())
+  {
+    ps->GetPresContext()->SetMedium(aMedium);
+    return NS_OK;
+  }
+  return NS_ERROR_FAILURE;
+}
+
diff -r fec90cbfbaad editor/libeditor/nsHTMLEditor.h
--- a/editor/libeditor/nsHTMLEditor.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsHTMLEditor.h	Thu Feb 11 17:49:41 2016 +0100
@@ -655,11 +655,13 @@
   nsresult SetInlinePropertyOnNode( nsIDOMNode *aNode,
                                     nsIAtom *aProperty, 
                                     const nsAString *aAttribute,
-                                    const nsAString *aValue);
+                                    const nsAString *aValue,
+                                    bool aAvoidNestingForCSS);
   nsresult SetInlinePropertyOnNode(nsIContent* aNode,
                                    nsIAtom* aProperty,
                                    const nsAString* aAttribute,
-                                   const nsAString* aValue);
+                                    const nsAString *aValue,
+                                    bool aAvoidNestingForCSS);
 
   nsresult PromoteInlineRange(nsRange* aRange);
   nsresult PromoteRangeIfStartsOrEndsInNamedAnchor(nsRange* aRange);
@@ -962,7 +964,8 @@
   nsresult SetInlinePropertyOnNodeImpl(nsIContent* aNode,
                                        nsIAtom* aProperty,
                                        const nsAString* aAttribute,
-                                       const nsAString* aValue);
+                                       const nsAString* aValue,
+                                       bool aAvoidNestingForCSS);
   typedef enum { eInserted, eAppended } InsertedOrAppended;
   void DoContentInserted(nsIDocument* aDocument, nsIContent* aContainer,
                          nsIContent* aChild, int32_t aIndexInContainer,
diff -r fec90cbfbaad editor/libeditor/nsHTMLEditorEventListener.cpp
--- a/editor/libeditor/nsHTMLEditorEventListener.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsHTMLEditorEventListener.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -70,10 +70,55 @@
   aMouseEvent->GetClientY(&clientY);
   htmlEditor->MouseUp(clientX, clientY, element);
 
+  bool isShiftKey;
+  rv = aMouseEvent->GetShiftKey(&isShiftKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (htmlEditor->NotifyEditorMouseObservers(nsEditor::kMouseUp,
+                                             clientX, clientY,
+                                             element, isShiftKey)) {
+    aMouseEvent->PreventDefault();
+    return NS_OK;
+  }
+
   return nsEditorEventListener::MouseUp(aMouseEvent);
 }
 
 nsresult
+nsHTMLEditorEventListener::MouseMove(nsIDOMMouseEvent* aMouseEvent)
+{
+  NS_ENSURE_TRUE(mEditor, NS_ERROR_NOT_AVAILABLE);
+
+  if (!aMouseEvent) {
+    //non-ui event passed in.  bad things.
+    return NS_OK;
+  }
+
+  nsHTMLEditor* htmlEditor = GetHTMLEditor();
+
+  nsCOMPtr<nsIDOMEventTarget> target;
+  nsresult res = aMouseEvent->GetExplicitOriginalTarget(getter_AddRefs(target));
+  NS_ENSURE_SUCCESS(res, res);
+  NS_ENSURE_TRUE(target, NS_ERROR_NULL_POINTER);
+  nsCOMPtr<nsIDOMElement> element = do_QueryInterface(target);
+
+  int32_t clientX, clientY;
+  aMouseEvent->GetClientX(&clientX);
+  aMouseEvent->GetClientY(&clientY);
+
+  bool isShiftKey;
+  res = aMouseEvent->GetShiftKey(&isShiftKey);
+  NS_ENSURE_SUCCESS(res, res);
+  if (htmlEditor->NotifyEditorMouseObservers(nsEditor::kMouseMove,
+                                             clientX, clientY,
+                                             element, isShiftKey)) {
+    aMouseEvent->PreventDefault();
+    return NS_OK;
+  }
+
+  return nsEditorEventListener::MouseMove(aMouseEvent);
+}
+
+nsresult
 nsHTMLEditorEventListener::MouseDown(nsIDOMMouseEvent* aMouseEvent)
 {
   nsHTMLEditor* htmlEditor = GetHTMLEditor();
@@ -83,6 +128,10 @@
     return NS_OK;
   }
 
+  int32_t clientX, clientY;
+  aMouseEvent->GetClientX(&clientX);
+  aMouseEvent->GetClientY(&clientY);
+
   // Detect only "context menu" click
   // XXX This should be easier to do!
   // But eDOMEvents_contextmenu and NS_CONTEXTMENU is not exposed in any event
@@ -190,12 +239,20 @@
     }
   } else if (!isContextClick && buttonNumber == 0 && clickCount == 1) {
     // if the target element is an image, we have to display resizers
-    int32_t clientX, clientY;
-    aMouseEvent->GetClientX(&clientX);
-    aMouseEvent->GetClientY(&clientY);
     htmlEditor->MouseDown(clientX, clientY, element, aMouseEvent);
   }
 
+  nsCOMPtr<nsIDOMNode> targetNode = do_QueryInterface(target);
+  bool isShiftKey;
+  rv = aMouseEvent->GetShiftKey(&isShiftKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (htmlEditor->NotifyEditorMouseObservers(nsEditor::kMouseDown,
+                                             clientX, clientY,
+                                             element, isShiftKey)) {
+    aMouseEvent->PreventDefault();
+    return NS_OK;
+  }
+
   return nsEditorEventListener::MouseDown(aMouseEvent);
 }
 
diff -r fec90cbfbaad editor/libeditor/nsHTMLEditorEventListener.h
--- a/editor/libeditor/nsHTMLEditorEventListener.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsHTMLEditorEventListener.h	Thu Feb 11 17:49:41 2016 +0100
@@ -34,6 +34,7 @@
   virtual nsresult MouseDown(nsIDOMMouseEvent* aMouseEvent) override;
   virtual nsresult MouseUp(nsIDOMMouseEvent* aMouseEvent) override;
   virtual nsresult MouseClick(nsIDOMMouseEvent* aMouseEvent) override;
+  virtual nsresult MouseMove(nsIDOMMouseEvent* aMouseEvent) override;
 
   inline nsHTMLEditor* GetHTMLEditor();
 };
diff -r fec90cbfbaad editor/libeditor/nsHTMLEditorStyle.cpp
--- a/editor/libeditor/nsHTMLEditorStyle.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsHTMLEditorStyle.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -223,7 +223,7 @@
       int32_t j;
       for (j = 0; j < listCount; j++) {
         res = SetInlinePropertyOnNode(arrayOfNodes[j], aProperty,
-                                      &aAttribute, &aValue);
+                                      &aAttribute, &aValue, (1 == listCount));
         NS_ENSURE_SUCCESS(res, res);
       }
 
@@ -266,14 +266,17 @@
     return false;
   }
 
+  uint32_t attrCount = aContent->GetAttrCount();
+  bool noAttr = !attrCount
+                || (attrCount == 1 && aContent->GetAttrNameAt(0)->Equals(nsGkAtoms::mozdirty));
   // First check for <b>, <i>, etc.
-  if (element->IsHTMLElement(aProperty) && !element->GetAttrCount() &&
+  if (element->IsHTMLElement(aProperty) && noAttr &&
       (!aAttribute || aAttribute->IsEmpty())) {
     return true;
   }
 
   // Special cases for various equivalencies: <strong>, <em>, <s>
-  if (!element->GetAttrCount() &&
+  if (noAttr &&
       ((aProperty == nsGkAtoms::b &&
         element->IsHTMLElement(nsGkAtoms::strong)) ||
        (aProperty == nsGkAtoms::i &&
@@ -305,7 +308,8 @@
   // style supports it
   if (!mHTMLCSSUtils->IsCSSEditableProperty(element, aProperty, aAttribute) ||
       !element->IsHTMLElement(nsGkAtoms::span) ||
-      element->GetAttrCount() != 1 ||
+      !(attrCount == 1 || (attrCount == 2 && (element->GetAttrNameAt(0)->Equals(nsGkAtoms::mozdirty) ||
+                                              element->GetAttrNameAt(1)->Equals(nsGkAtoms::mozdirty)))) ||
       !element->HasAttr(kNameSpaceID_None, nsGkAtoms::style)) {
     return false;
   }
@@ -400,7 +404,7 @@
   }
   
   // reparent the node inside inline node with appropriate {attribute,value}
-  return SetInlinePropertyOnNode(node, aProperty, aAttribute, aValue);
+  return SetInlinePropertyOnNode(node, aProperty, aAttribute, aValue, false);
 }
 
 
@@ -408,7 +412,8 @@
 nsHTMLEditor::SetInlinePropertyOnNodeImpl(nsIContent* aNode,
                                           nsIAtom* aProperty,
                                           const nsAString* aAttribute,
-                                          const nsAString* aValue)
+                                          const nsAString* aValue,
+                                          bool aAvoidNestingForCSS)
 {
   MOZ_ASSERT(aNode && aProperty);
   MOZ_ASSERT(aValue);
@@ -434,7 +439,7 @@
       int32_t listCount = arrayOfNodes.Count();
       for (int32_t j = 0; j < listCount; ++j) {
         nsresult rv = SetInlinePropertyOnNode(arrayOfNodes[j], aProperty,
-                                              aAttribute, aValue);
+                                              aAttribute, aValue, false);
         NS_ENSURE_SUCCESS(rv, rv);
       }
     }
@@ -480,8 +485,9 @@
     nsCOMPtr<dom::Element> tmp;
     // We only add style="" to <span>s with no attributes (bug 746515).  If we
     // don't have one, we need to make one.
-    if (aNode->IsHTMLElement(nsGkAtoms::span) &&
-        !aNode->AsElement()->GetAttrCount()) {
+    if (aNode->IsElement() &&
+        (aAvoidNestingForCSS ||
+         (aNode->AsElement()->IsHTMLElement(nsGkAtoms::span) && !aNode->AsElement()->GetAttrCount()))) {
       tmp = aNode->AsElement();
     } else {
       tmp = InsertContainerAbove(aNode, nsGkAtoms::span);
@@ -517,7 +523,8 @@
 nsHTMLEditor::SetInlinePropertyOnNode(nsIDOMNode *aNode,
                                       nsIAtom *aProperty,
                                       const nsAString *aAttribute,
-                                      const nsAString *aValue)
+                                      const nsAString *aValue,
+                                      bool aAvoidNestingForCSS)
 {
   // Before setting the property, we remove it if it's already set.
   // RemoveStyleInside might remove the node we're looking at or some of its
@@ -529,14 +536,15 @@
   nsCOMPtr<nsIContent> node = do_QueryInterface(aNode);
   NS_ENSURE_STATE(node);
 
-  return SetInlinePropertyOnNode(node, aProperty, aAttribute, aValue);
+  return SetInlinePropertyOnNode(node, aProperty, aAttribute, aValue, aAvoidNestingForCSS);
 }
 
 nsresult
 nsHTMLEditor::SetInlinePropertyOnNode(nsIContent* aNode,
                                       nsIAtom* aProperty,
                                       const nsAString* aAttribute,
-                                      const nsAString* aValue)
+                                      const nsAString *aValue,
+                                      bool aAvoidNestingForCSS)
 {
   MOZ_ASSERT(aNode);
   MOZ_ASSERT(aProperty);
@@ -552,7 +560,7 @@
   if (aNode->GetParentNode()) {
     // The node is still where it was
     return SetInlinePropertyOnNodeImpl(aNode, aProperty,
-                                       aAttribute, aValue);
+                                       aAttribute, aValue, aAvoidNestingForCSS);
   }
 
   // It's vanished.  Use the old siblings for reference to construct a
@@ -575,7 +583,7 @@
   int32_t nodesToSetCount = nodesToSet.Count();
   for (int32_t k = 0; k < nodesToSetCount; k++) {
     res = SetInlinePropertyOnNodeImpl(nodesToSet[k], aProperty,
-                                      aAttribute, aValue);
+                                      aAttribute, aValue, false);
     NS_ENSURE_SUCCESS(res, res);
   }
 
@@ -1474,7 +1482,7 @@
               // insert a span "inverting" the style
               if (mHTMLCSSUtils->IsCSSInvertable(aProperty, aAttribute)) {
                 nsAutoString value; value.AssignLiteral("-moz-editor-invert-value");
-                SetInlinePropertyOnNode(node, aProperty, aAttribute, &value);
+                SetInlinePropertyOnNode(node, aProperty, aAttribute, &value, false);
               }
             }
           }
diff -r fec90cbfbaad editor/libeditor/nsTableEditor.cpp
--- a/editor/libeditor/nsTableEditor.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsTableEditor.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -25,6 +25,7 @@
 #include "nsIEditor.h"
 #include "nsIFrame.h"
 #include "nsIHTMLEditor.h"
+#include "nsTextEditUtils.h"
 #include "nsINode.h"
 #include "nsIPresShell.h"
 #include "nsISupportsUtils.h"
@@ -2301,6 +2302,7 @@
   nsAutoRules beginRulesSniffing(this, EditAction::deleteNode, nsIEditor::eNext);
 
   // Don't need to merge if cell is empty
+  nsresult res;
   if (!IsEmptyCell(cellToMerge)) {
     // Get index of last child in target cell
     // If we fail or don't have children, 
@@ -2309,7 +2311,8 @@
 
     // Start inserting just after last child
     uint32_t len = targetCell->GetChildCount();
-    if (len == 1 && IsEmptyCell(targetCell)) {
+    bool isTargetCellEmpty = IsEmptyCell(targetCell);
+    if (len == 1 && isTargetCellEmpty) {
       // Delete the empty node
       nsIContent* cellChild = targetCell->GetFirstChild();
       nsresult res = DeleteNode(cellChild->AsDOMNode());
@@ -2317,12 +2320,58 @@
       insertIndex = 0;
     } else {
       insertIndex = (int32_t)len;
+      // Insert a break at the beginning of source cell if we need it.
+      // We need it if both cells are non-empty from a content point of view.
+      if (!isTargetCellEmpty) {
+        // Let's look for the last child of the target cell that is not
+        // an empty text node
+        nsIContent* targetCellChild = targetCell->GetLastChild();
+        nsCOMPtr<nsIDOMNode> targetCellChildNode = targetCellChild->AsDOMNode();
+        bool isEmptyTextNode = false;
+        while (targetCellChildNode
+               && nsEditor::IsTextNode(targetCellChildNode)
+               && (NS_SUCCEEDED(IsEmptyNode(targetCellChildNode, &isEmptyTextNode)) && isEmptyTextNode)) {
+          res = targetCellChildNode->GetPreviousSibling(getter_AddRefs(targetCellChildNode));
+          NS_ENSURE_SUCCESS(res, res);
+        }
+        // we know targetCellChildNode cannot be null at this point because
+        // we tested isTargetCellEmpty above...
+        bool isBlock = false;
+        NodeIsBlock(targetCellChildNode, &isBlock);
+        // Lets check if targetCellChildNode is a block or a break
+        if (!isBlock && !nsTextEditUtils::IsBreak(targetCellChildNode)) {
+          // It's not, we may have to insert a break...
+          // Let's look for the first child of the source cell that is not
+          // an empty text node
+          nsCOMPtr<nsIDOMNode> cellChildNode = cellToMerge->GetFirstChild()->AsDOMNode();
+          while (cellChildNode
+                 && nsEditor::IsTextNode(cellChildNode)
+                 && (NS_SUCCEEDED(IsEmptyNode(cellChildNode, &isEmptyTextNode)) && isEmptyTextNode)) {
+            res = cellChildNode->GetPreviousSibling(getter_AddRefs(cellChildNode));
+            NS_ENSURE_SUCCESS(res, res);
+          }
+          // we also know cellChildNode cannot be null at this point because
+          // we tested IsEmptyCell(cellToMerge) above...
+          isBlock = false;
+          NodeIsBlock(cellChildNode, &isBlock);
+          // Lets check if targetCellChildNode is a block or a break
+          if (!isBlock && !nsTextEditUtils::IsBreak(cellChildNode)) {
+            // so both last visible node of target cell and first visible node of
+            // source cell are not blocks or breaks. We need to insert
+            // a break as first child of source cell so the merged contents
+            // are separated by that break.
+            nsCOMPtr<nsIDOMNode> brNode;
+            res = CreateBR(aCellToMerge, 0, address_of(brNode));
+            NS_ENSURE_SUCCESS(res, res);
+          }
+        }
+      }
     }
 
     // Move the contents
     while (cellToMerge->HasChildren()) {
       nsCOMPtr<nsIDOMNode> cellChild = cellToMerge->GetLastChild()->AsDOMNode();
-      nsresult res = DeleteNode(cellChild);
+      res = DeleteNode(cellChild);
       NS_ENSURE_SUCCESS(res, res);
 
       res = InsertNode(cellChild, aTargetCell, insertIndex);
diff -r fec90cbfbaad editor/libeditor/nsWSRunObject.cpp
--- a/editor/libeditor/nsWSRunObject.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/libeditor/nsWSRunObject.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -502,7 +502,7 @@
 
   // Is there a visible run there or earlier?
   for (; run; run = run->mLeft) {
-    if (run->mType == WSType::normalWS) {
+    if (run->mType == WSType::normalWS || run->mType == WSType::trailingWS) {
       WSPoint point = GetCharBefore(aNode, aOffset);
       if (point.mTextNode) {
         *outVisNode = point.mTextNode;
diff -r fec90cbfbaad editor/moz.build
--- a/editor/moz.build	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/moz.build	Thu Feb 11 17:49:41 2016 +0100
@@ -18,6 +18,7 @@
     'nsIEditor.idl',
     'nsIEditorIMESupport.idl',
     'nsIEditorMailSupport.idl',
+    'nsIEditorMouseObserver.idl',
     'nsIEditorObserver.idl',
     'nsIEditorSpellCheck.idl',
     'nsIEditorStyleSheets.idl',
diff -r fec90cbfbaad editor/nsIEditor.idl
--- a/editor/nsIEditor.idl	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/nsIEditor.idl	Thu Feb 11 17:49:41 2016 +0100
@@ -17,6 +17,7 @@
 interface nsITransactionManager;
 interface nsITransaction;
 interface nsIEditorObserver;
+interface nsIEditorMouseObserver;
 interface nsIEditActionListener;
 interface nsIInlineSpellChecker;
 interface nsITransferable;
@@ -526,6 +527,9 @@
   /** Remove an EditorObserver from the editor's list of observers. */
   void removeEditorObserver(in nsIEditorObserver observer);
 
+  void addEditorMouseObserver(in nsIEditorMouseObserver observer);
+  void removeEditorMouseObserver(in nsIEditorMouseObserver observer);
+
   /** add an EditActionListener to the editors list of listeners. */
   void addEditActionListener(in nsIEditActionListener listener);
 
diff -r fec90cbfbaad editor/nsIEditorMouseObserver.idl
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/editor/nsIEditorMouseObserver.idl	Thu Feb 11 17:49:41 2016 +0100
@@ -0,0 +1,17 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+#include "domstubs.idl"
+
+
+[scriptable, uuid(7A76F573-7512-4051-BB20-E6E279F26F55)]
+
+interface nsIEditorMouseObserver : nsISupports {
+
+  bool MouseDown(in int32_t aClientX, in int32_t aClientY, in nsIDOMNode aTarget, in boolean aShiftKey);
+  bool MouseUp(in int32_t aClientX, in int32_t aClientY, in nsIDOMNode aTarget, in boolean aShiftKey);
+  bool MouseMove(in int32_t aClientX, in int32_t aClientY, in nsIDOMNode aTarget, in boolean aShiftKey);
+};
diff -r fec90cbfbaad editor/nsIHTMLEditor.idl
--- a/editor/nsIHTMLEditor.idl	Thu Apr 09 22:57:56 2015 -0400
+++ b/editor/nsIHTMLEditor.idl	Thu Feb 11 17:49:41 2016 +0100
@@ -22,7 +22,7 @@
 
 [ptr] native Element (mozilla::dom::Element);
 
-[scriptable, uuid(87ee993e-985f-4a43-a974-0d9512da2fb0)]
+[scriptable, uuid(BFA533D9-358C-47CC-92FF-E89D5263D264)]
 interface nsIHTMLEditor : nsISupports
 {
 %{C++
@@ -497,6 +497,9 @@
    */
   attribute boolean isCSSEnabled;
 
+  AString getMedium();
+  void setMedium(in AString aMedium);
+
   /**
    * Add listener for insertion override
    * @param inFilter  function which callers want called during insertion
diff -r fec90cbfbaad gfx/src/nsColor.cpp
--- a/gfx/src/nsColor.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/gfx/src/nsColor.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -214,6 +214,27 @@
   return false;
 }
 
+NS_GFX_(bool) NS_RGBToColorName(nscolor aColor, nsAString& aResult)
+{
+  uint8_t a = NS_GET_A(aColor);
+  if (a < 255)
+    return false;
+  uint8_t r = NS_GET_R(aColor);
+  uint8_t g = NS_GET_G(aColor);
+  uint8_t b = NS_GET_B(aColor);
+  uint32_t colorIndex;
+  for (colorIndex = 0; colorIndex < eColorName_COUNT; colorIndex++) {
+    nscolor matchingColor = kColors[colorIndex];
+    if (NS_GET_R(matchingColor) == r
+        && NS_GET_G(matchingColor) == g
+        && NS_GET_B(matchingColor) == b) {
+      aResult.AppendASCII(kColorNames[colorIndex]);
+      return true;
+    }
+  }
+  return false;
+}
+
 // Returns kColorNames, an array of all possible color names, and sets
 // *aSizeArray to the size of that array. Do NOT call free() on this array.
 NS_GFX_(const char * const *) NS_AllColorNames(size_t *aSizeArray)
diff -r fec90cbfbaad gfx/src/nsColor.h
--- a/gfx/src/nsColor.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/gfx/src/nsColor.h	Thu Feb 11 17:49:41 2016 +0100
@@ -72,6 +72,10 @@
 // otherwise return false.
 NS_GFX_(bool) NS_ColorNameToRGB(const nsAString& aBuf, nscolor* aResult);
 
+// Translate a color to a color name. Return true if it parses ok,
+// otherwise return false.
+NS_GFX_(bool) NS_RGBToColorName(nscolor aColor, nsAString& aResult);
+
 // Returns an array of all possible color names, and sets
 // *aSizeArray to the size of that array. Do NOT call |free()| on this array.
 NS_GFX_(const char * const *) NS_AllColorNames(size_t *aSizeArray);
diff -r fec90cbfbaad gfx/thebes/gfxPlatformMac.cpp
--- a/gfx/thebes/gfxPlatformMac.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/gfx/thebes/gfxPlatformMac.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -572,7 +572,16 @@
 
   mozilla::TimeStamp previousVsync = display->mPreviousTimestamp;
   display->mPreviousTimestamp = nextVsync;
-  MOZ_ASSERT(TimeStamp::Now() > previousVsync);
+  mozilla::TimeStamp now = TimeStamp::Now();
+  MOZ_ASSERT(nextVsync > previousVsync);
+
+  // Bug 1158321 - The VsyncCallback can sometimes execute before the reported
+  // vsync time. In those cases, normalize the timestamp to Now() as sending
+  // timestamps in the future has undefined behavior. See the comment above
+  // OSXDisplay::mPreviousTimestamp
+  if (now < previousVsync) {
+    previousVsync = now;
+  }
 
   display->NotifyVsync(previousVsync);
   return kCVReturnSuccess;
diff -r fec90cbfbaad layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/layout/base/nsPresContext.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -1989,6 +1989,20 @@
     mPrintSettings = aPrintSettings;
 }
 
+void
+nsPresContext::SetMedium(const nsAString& aMedium)
+{
+  if (aMedium.EqualsLiteral("screen")) {
+    mMedium = nsGkAtoms::screen;
+    mType =  eContext_Galley;
+  } else {
+    mMedium = nsGkAtoms::print;
+    mType =  eContext_PageLayout;
+    mPaginated = true;
+  }
+  MediaFeatureValuesChanged(eRestyle_ForceDescendants, NS_STYLE_HINT_REFLOW);
+}
+
 bool
 nsPresContext::EnsureVisible()
 {
diff -r fec90cbfbaad layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/layout/base/nsPresContext.h	Thu Feb 11 17:49:41 2016 +0100
@@ -323,6 +323,7 @@
       return mMedium;
     return mMediaEmulated;
   }
+  void SetMedium(const nsAString& aMedium);
 
   /*
    * Render the document as if being viewed on a device with the specified
diff -r fec90cbfbaad layout/forms/nsColorControlFrame.cpp
--- a/layout/forms/nsColorControlFrame.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/layout/forms/nsColorControlFrame.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -100,6 +100,8 @@
   nsAutoString color;
   nsCOMPtr<nsIDOMHTMLInputElement> elt = do_QueryInterface(mContent);
   elt->GetValue(color);
+  if (color.IsEmpty())
+    return NS_OK;
   MOZ_ASSERT(!color.IsEmpty(),
              "Content node's GetValue() should return a valid color string "
              "(the default color, in case no valid color is set)");
diff -r fec90cbfbaad layout/style/Loader.cpp
--- a/layout/style/Loader.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/layout/style/Loader.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -1121,7 +1121,8 @@
 #endif
 
     bool fromCompleteSheets = false;
-    if (!sheet) {
+    //XXX BlueGriffon force reload of stylesheets each time we need them
+    if (false /*!sheet*/) {
       // Then our per-document complete sheets.
       URIPrincipalReferrerPolicyAndCORSModeHashKey key(aURI, aLoaderPrincipal, aCORSMode, aReferrerPolicy);
 
diff -r fec90cbfbaad layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/layout/style/nsCSSParser.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -51,6 +51,8 @@
 #include "mozilla/dom/URL.h"
 #include "gfxFontFamilyList.h"
 
+#define BG_CONSOLE_SHOW_INVALID_VARIABLES "bluegriffon.console.showInvalidVariables"
+
 using namespace mozilla;
 
 typedef nsCSSProps::KTableValue KTableValue;
@@ -2618,7 +2620,7 @@
     nsCSSTokenSerializationType firstToken, lastToken;
     valid = ResolveValueWithVariableReferences(aVariables, expandedValue,
                                                firstToken, lastToken);
-    if (!valid) {
+    if (!valid && Preferences::GetBool(BG_CONSOLE_SHOW_INVALID_VARIABLES)) {
       NS_ConvertASCIItoUTF16 propName(nsCSSProps::GetStringValue(aPropertyID));
       REPORT_UNEXPECTED(PEInvalidVariableReference);
       REPORT_UNEXPECTED_P(PEValueParsingError, propName);
@@ -5392,6 +5394,9 @@
         REPORT_UNEXPECTED_EOF(PEAttSelValueEOF);
         return eSelectorParsingStatus_Error;
       }
+
+      bool isCaseSensitive = true;
+
       if ((eCSSToken_Ident == mToken.mType) || (eCSSToken_String == mToken.mType)) {
         nsAutoString  value(mToken.mIdent);
         bool gotClosingBracket;
@@ -5401,16 +5406,25 @@
           gotClosingBracket = true;
         } else {
           gotClosingBracket = mToken.IsSymbol(']');
+          if (!gotClosingBracket && eCSSToken_Ident == mToken.mType && mToken.mIdent.LowerCaseEqualsLiteral("i")) {
+            // Case-insensitive attribute selectors from Selectors Level 4 section 6.3
+            isCaseSensitive = false;
+            if (! GetToken(true)) { // premature EOF
+              REPORT_UNEXPECTED_EOF(PEAttSelValueEOF);
+              gotClosingBracket = true;
+            }
+            else
+              gotClosingBracket = mToken.IsSymbol(']');
+          }
         }
         if (gotClosingBracket) {
-          bool isCaseSensitive = true;
 
           // For cases when this style sheet is applied to an HTML
           // element in an HTML document, and the attribute selector is
           // for a non-namespaced attribute, then check to see if it's
           // one of the known attributes whose VALUE is
           // case-insensitive.
-          if (nameSpaceID == kNameSpaceID_None) {
+          if (isCaseSensitive && nameSpaceID == kNameSpaceID_None) {
             static const char* caseInsensitiveHTMLAttribute[] = {
               // list based on http://www.w3.org/TR/html4/
               "lang",
diff -r fec90cbfbaad layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/layout/style/nsCSSValue.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -23,6 +23,7 @@
 #include "nsPresContext.h"
 #include "nsStyleUtil.h"
 #include "nsDeviceContext.h"
+#include "nsIPrefService.h"
 
 using namespace mozilla;
 
@@ -1309,6 +1310,13 @@
     }
   }
   else if (IsNumericColorUnit(unit)) {
+    bool outputCssNames = false;
+    nsresult rv;
+    nsCOMPtr<nsIPrefBranch> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
+    if (NS_SUCCEEDED(rv) && prefBranch)
+      prefBranch->GetBoolPref("bluegriffon.css.colors.names.enabled", &outputCssNames);
+    bool serializeName = false;
+
     if (aSerialization == eNormalized ||
         unit == eCSSUnit_RGBColor ||
         unit == eCSSUnit_RGBAColor) {
@@ -1327,21 +1335,32 @@
         if (showAlpha) {
           aResult.AppendLiteral("rgba(");
         } else {
-          aResult.AppendLiteral("rgb(");
+          if (outputCssNames) {
+            nsAutoString nameToSerialize;
+            serializeName = NS_RGBToColorName(color, nameToSerialize);
+            if (serializeName)
+              aResult.Append(nameToSerialize);
+            else
+              aResult.AppendLiteral("rgb(");
+          }
+          else
+            aResult.AppendLiteral("rgb(");
         }
 
-        NS_NAMED_LITERAL_STRING(comma, ", ");
+        if (!serializeName) {
+          NS_NAMED_LITERAL_STRING(comma, ", ");
 
-        aResult.AppendInt(NS_GET_R(color), 10);
-        aResult.Append(comma);
-        aResult.AppendInt(NS_GET_G(color), 10);
-        aResult.Append(comma);
-        aResult.AppendInt(NS_GET_B(color), 10);
-        if (showAlpha) {
+          aResult.AppendInt(NS_GET_R(color), 10);
           aResult.Append(comma);
-          aResult.AppendFloat(nsStyleUtil::ColorComponentToFloat(a));
+          aResult.AppendInt(NS_GET_G(color), 10);
+          aResult.Append(comma);
+          aResult.AppendInt(NS_GET_B(color), 10);
+          if (showAlpha) {
+            aResult.Append(comma);
+            aResult.AppendFloat(nsStyleUtil::ColorComponentToFloat(a));
+          }
+          aResult.Append(char16_t(')'));
         }
-        aResult.Append(char16_t(')'));
       }
     } else if (eCSSUnit_HexColor == unit) {
       nscolor color = GetColorValue();
diff -r fec90cbfbaad parser/htmlparser/nsExpatDriver.cpp
--- a/parser/htmlparser/nsExpatDriver.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/parser/htmlparser/nsExpatDriver.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -972,7 +972,9 @@
   if (mSink && shouldReportError) {
     rv = mSink->ReportError(errorText.get(), 
                             sourceText.get(), 
-                            serr, 
+                            serr,
+                            lineNumber,
+                            colNumber,
                             &shouldReportError);
     if (NS_FAILED(rv)) {
       shouldReportError = true;
diff -r fec90cbfbaad parser/htmlparser/nsIExpatSink.idl
--- a/parser/htmlparser/nsIExpatSink.idl	Thu Apr 09 22:57:56 2015 -0400
+++ b/parser/htmlparser/nsIExpatSink.idl	Thu Feb 11 17:49:41 2016 +0100
@@ -105,5 +105,7 @@
    */
   boolean ReportError(in wstring aErrorText,
                       in wstring aSourceText,
-                      in nsIScriptError aError);
+                      in nsIScriptError aError,
+                      in unsigned long aLineNumber,
+                      in unsigned long aColNumber);
 }; 
diff -r fec90cbfbaad parser/xml/nsSAXXMLReader.cpp
--- a/parser/xml/nsSAXXMLReader.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/parser/xml/nsSAXXMLReader.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -306,6 +306,8 @@
 nsSAXXMLReader::ReportError(const char16_t* aErrorText,
                             const char16_t* aSourceText,
                             nsIScriptError *aError,
+                            PRUint32 aLineNumber,
+                            PRUint32 aColNumber,
                             bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
diff -r fec90cbfbaad rdf/base/nsRDFContentSink.cpp
--- a/rdf/base/nsRDFContentSink.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/rdf/base/nsRDFContentSink.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -538,6 +538,8 @@
 RDFContentSinkImpl::ReportError(const char16_t* aErrorText, 
                                 const char16_t* aSourceText,
                                 nsIScriptError *aError,
+                                PRUint32 aLineNumber,
+                                PRUint32 aColNumber,
                                 bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
diff -r fec90cbfbaad toolkit/components/console/content/consoleBindings.xml
--- a/toolkit/components/console/content/consoleBindings.xml	Thu Apr 09 22:57:56 2015 -0400
+++ b/toolkit/components/console/content/consoleBindings.xml	Thu Feb 11 17:49:41 2016 +0100
@@ -151,9 +151,14 @@
         <parameter name="aObject"/>
         <body><![CDATA[
           try {
+            const CM_RESOURCE_URL = "resource://gre/res/codemirror/";
             // Try to QI it to a script error to get more info
             var scriptError = aObject.QueryInterface(Components.interfaces.nsIScriptError);
 
+            // don't show codemirror errors
+            if (scriptError.sourceName.substr(0, CM_RESOURCE_URL.length) == CM_RESOURCE_URL)
+              return;
+
             // filter chrome urls
             if (!this.showChromeErrors && scriptError.sourceName.substr(0, 9) == "chrome://")
               return;
diff -r fec90cbfbaad toolkit/content/widgets/menu.xml
--- a/toolkit/content/widgets/menu.xml	Thu Apr 09 22:57:56 2015 -0400
+++ b/toolkit/content/widgets/menu.xml	Thu Feb 11 17:49:41 2016 +0100
@@ -217,6 +217,15 @@
     </content>
   </binding>
 
+  <binding id="menuitem-non-iconic-accel" extends="chrome://global/content/bindings/menu.xml#menuitem">
+    <content>
+      <xul:label class="menu-iconic-text" flex="1" xbl:inherits="value=label,accesskey,crop" crop="right"/>
+      <xul:hbox class="menu-accel-container" anonid="accel">
+        <xul:label class="menu-iconic-accel" xbl:inherits="value=acceltext"/>
+      </xul:hbox>
+    </content>
+  </binding>
+
   <binding id="menuitem-iconic-noaccel" extends="chrome://global/content/bindings/menu.xml#menuitem">
     <content>
       <xul:hbox class="menu-iconic-left" align="center" pack="center"
diff -r fec90cbfbaad toolkit/content/widgets/menulist.xml
--- a/toolkit/content/widgets/menulist.xml	Thu Apr 09 22:57:56 2015 -0400
+++ b/toolkit/content/widgets/menulist.xml	Thu Feb 11 17:49:41 2016 +0100
@@ -545,6 +545,13 @@
           this.inputField.select();
         </body>
       </method>
+
+      <method name="getChild">
+        <parameter name="aChildName"/>
+        <body><![CDATA[
+          return document.getAnonymousElementByAttribute(this, "anonid", aChildName);
+        ]]></body>
+      </method>
     </implementation>
 
     <handlers>
@@ -579,14 +586,30 @@
 
       <handler event="keypress">
         <![CDATA[
+          if (event.ctrlKey && event.shiftKey)
+            return;
+
+          if (this.getAttribute("bgtype") == "csslength") {
+            var _self = this;
+            if (event.keyCode == KeyEvent.DOM_VK_UP) {
+              IncreaseLength(this, this.getAttribute("units"));
+              if (this.oninput)
+                this.oninput.call(_self);
+              event.preventDefault();
+            }
+            else if (event.keyCode == KeyEvent.DOM_VK_DOWN) {
+              DecreaseLength(this, this.getAttribute("units"), !(this.getAttribute("unsigned") == "true"));
+              if (this.oninput)
+                this.oninput.call(_self);
+              event.preventDefault();
+            }
+          }
           // open popup if key is up arrow, down arrow, or F4
-          if (!event.ctrlKey && !event.shiftKey) {
-            if (event.keyCode == KeyEvent.DOM_VK_UP ||
-                event.keyCode == KeyEvent.DOM_VK_DOWN ||
-                (event.keyCode == KeyEvent.DOM_VK_F4 && !event.altKey)) {
-              event.preventDefault();
-              this.open = true;
-            }
+          else if (event.keyCode == KeyEvent.DOM_VK_UP ||
+                   event.keyCode == KeyEvent.DOM_VK_DOWN ||
+                   (event.keyCode == KeyEvent.DOM_VK_F4 && !event.altKey)) {
+            event.preventDefault();
+            this.open = true;
           }
         ]]>
       </handler>
diff -r fec90cbfbaad toolkit/content/widgets/tree.xml
--- a/toolkit/content/widgets/tree.xml	Thu Apr 09 22:57:56 2015 -0400
+++ b/toolkit/content/widgets/tree.xml	Thu Feb 11 17:49:41 2016 +0100
@@ -715,7 +715,8 @@
           // Only handle swipe gestures up and down
           switch (event.direction) {
             case event.DIRECTION_DOWN:
-              targetRow = this.view.rowCount - 1;
+              if (this.view)
+                targetRow = this.view.rowCount - 1;
               // Fall through for actual action
             case event.DIRECTION_UP:
               this.treeBoxObject.ensureRowIsVisible(targetRow);
@@ -1468,25 +1469,26 @@
             var refChild = aPopup.firstChild;
 
             var tree = this.parentNode.parentNode;
-            for (var currCol = tree.columns.getFirstColumn(); currCol;
-                 currCol = currCol.getNext()) {
-              // Construct an entry for each column in the row, unless
-              // it is not being shown.
-              var currElement = currCol.element;
-              if (!currElement.hasAttribute("ignoreincolumnpicker")) {
-                var popupChild = document.createElement("menuitem");
-                popupChild.setAttribute("type", "checkbox");
-                var columnName = currElement.getAttribute("display") ||
-                                 currElement.getAttribute("label");
-                popupChild.setAttribute("label", columnName);
-                popupChild.setAttribute("colindex", currCol.index);
-                if (currElement.getAttribute("hidden") != "true")
-                  popupChild.setAttribute("checked", "true");
-                if (currCol.primary)
-                  popupChild.setAttribute("disabled", "true");
-                aPopup.insertBefore(popupChild, refChild);
+            if (tree.columns) // sanity case
+              for (var currCol = tree.columns.getFirstColumn(); currCol;
+                   currCol = currCol.getNext()) {
+                // Construct an entry for each column in the row, unless
+                // it is not being shown.
+                var currElement = currCol.element;
+                if (!currElement.hasAttribute("ignoreincolumnpicker")) {
+                  var popupChild = document.createElement("menuitem");
+                  popupChild.setAttribute("type", "checkbox");
+                  var columnName = currElement.getAttribute("display") ||
+                                   currElement.getAttribute("label");
+                  popupChild.setAttribute("label", columnName);
+                  popupChild.setAttribute("colindex", currCol.index);
+                  if (currElement.getAttribute("hidden") != "true")
+                    popupChild.setAttribute("checked", "true");
+                  if (currCol.primary)
+                    popupChild.setAttribute("disabled", "true");
+                  aPopup.insertBefore(popupChild, refChild);
+                }
               }
-            }
 
             var hidden = !tree.enableColumnDrag;
             const anonids = ["menuseparator", "menuitem"];
diff -r fec90cbfbaad toolkit/content/xul.css
--- a/toolkit/content/xul.css	Thu Apr 09 22:57:56 2015 -0400
+++ b/toolkit/content/xul.css	Thu Feb 11 17:49:41 2016 +0100
@@ -368,6 +368,10 @@
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic");
 }
 
+menuitem.menuitem-non-iconic-accel {
+  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-non-iconic-accel");
+}
+
 menuitem[description] {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic-desc-noaccel");
 }
diff -r fec90cbfbaad toolkit/mozapps/extensions/content/extensions.js
--- a/toolkit/mozapps/extensions/content/extensions.js	Thu Apr 09 22:57:56 2015 -0400
+++ b/toolkit/mozapps/extensions/content/extensions.js	Thu Feb 11 17:49:41 2016 +0100
@@ -33,6 +33,7 @@
 const PREF_GETADDONS_CACHE_ID_ENABLED = "extensions.%ID%.getAddons.cache.enabled";
 const PREF_UI_TYPE_HIDDEN = "extensions.ui.%TYPE%.hidden";
 const PREF_UI_LASTCATEGORY = "extensions.ui.lastCategory";
+const PREF_CLOSE_ADDONS_MANAGER_ON_ESCAPE = "extensions.closeOnEscape";
 const PREF_ADDON_DEBUGGING_ENABLED = "devtools.chrome.enabled";
 const PREF_REMOTE_DEBUGGING_ENABLED = "devtools.debugger.remote-enabled";
 
@@ -89,6 +90,17 @@
   }
   document.removeEventListener("load", initialize, true);
 
+  // should we allow the window to close when the user hits the ESC key?
+  let closeOnEscape = false; // default for Firefox 4+
+  try {
+    closeOnEscape = Services.prefs.getBoolPref(PREF_CLOSE_ADDONS_MANAGER_ON_ESCAPE);
+  } catch(e) { }
+  if (!closeOnEscape) {
+    let escapeKeyElt = document.getElementById("escapeKey");
+    if (escapeKeyElt)
+      escapeKeyElt.setAttribute("disabled", "true");
+  }
+
   let globalCommandSet = document.getElementById("globalCommandSet");
   globalCommandSet.addEventListener("command", function(event) {
     gViewController.doCommand(event.target.id);
@@ -2701,7 +2713,7 @@
     let prop = aIsInstall ? "mInstall" : "mAddon";
 
     for (let item of this._listBox.childNodes) {
-      if (item[prop] == aObj) {
+      if (prop in utem && item[prop] == aObj) {
         this._listBox.removeChild(item);
         this.showEmptyNotice(this._listBox.itemCount == 0);
         return;
diff -r fec90cbfbaad toolkit/mozapps/extensions/content/extensions.xul
--- a/toolkit/mozapps/extensions/content/extensions.xul	Thu Apr 09 22:57:56 2015 -0400
+++ b/toolkit/mozapps/extensions/content/extensions.xul	Thu Feb 11 17:49:41 2016 +0100
@@ -28,6 +28,10 @@
   <script type="application/javascript"
           src="chrome://global/content/contentAreaUtils.js"/>
 
+  <keyset>
+    <key id="escapeKey" keycode="VK_ESCAPE" oncommand="window.close()"/>
+  </keyset>
+
   <popupset>
     <!-- menu for an addon item -->
     <menupopup id="addonitem-popup">
diff -r fec90cbfbaad toolkit/mozapps/handling/nsContentDispatchChooser.js
--- a/toolkit/mozapps/handling/nsContentDispatchChooser.js	Thu Apr 09 22:57:56 2015 -0400
+++ b/toolkit/mozapps/handling/nsContentDispatchChooser.js	Thu Feb 11 17:49:41 2016 +0100
@@ -67,12 +67,44 @@
     params.appendElement(aURI, false);
     params.appendElement(aWindowContext, false);
     
+    // if a modal window is already shown, we need to open the app chooser
+    // as a modal window otherwise it will be unresponsive; bug 687423
+    var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+               getService(Ci.nsIWindowMediator);
+    var enumerator = wm.getXULWindowEnumerator(null);
+    var inModalState = false;
+    while (!inModalState && enumerator.hasMoreElements()) {
+      var win = enumerator.getNext();
+      var windowDocShell = win.QueryInterface(Ci.nsIXULWindow).docShell;
+  
+      var containedDocShells = windowDocShell.getDocShellEnumerator(
+                                        Ci.nsIDocShellTreeItem.typeChrome,
+                                        Ci.nsIDocShell.ENUMERATE_FORWARDS);
+
+      while (!inModalState && containedDocShells.hasMoreElements()) {
+        // Get the corresponding document for this docshell
+        var childDocShell = containedDocShells.getNext();
+
+        // We don't want it if it's not done loading.
+        if (childDocShell.busyFlags != Ci.nsIDocShell.BUSY_FLAGS_NONE)
+          continue;
+
+        // Ensure that we are only returning true if it is indeed modal
+        var chrome = win.QueryInterface(Ci.nsIInterfaceRequestor).
+                         getInterface(Ci.nsIWebBrowserChrome);
+        if (chrome.isWindowModal()) {
+          inModalState = true;
+        }
+      }
+    }
+
     var ww = Cc["@mozilla.org/embedcomp/window-watcher;1"].
              getService(Ci.nsIWindowWatcher);
     ww.openWindow(window,
                   CONTENT_HANDLING_URL,
                   null,
-                  "chrome,dialog=yes,resizable,centerscreen",
+                  "chrome,dialog=yes,resizable,centerscreen"
+                    + (inModalState ? ",modal" : ""),
                   params);
   },
 
diff -r fec90cbfbaad toolkit/toolkit.mozbuild
--- a/toolkit/toolkit.mozbuild	Thu Apr 09 22:57:56 2015 -0400
+++ b/toolkit/toolkit.mozbuild	Thu Feb 11 17:49:41 2016 +0100
@@ -171,7 +171,6 @@
     DIRS += ['/testing/marionette']
 
 DIRS += [
-    '/tools/quitter',
     '/media/gmp-clearkey/0.1',
 ]
 
diff -r fec90cbfbaad widget/PuppetWidget.cpp
--- a/widget/PuppetWidget.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/PuppetWidget.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -1127,6 +1127,14 @@
 }
 
 NS_IMETHODIMP
+PuppetScreenManager::ScreenForIndex(uint32_t aId,
+                                 nsIScreen** outScreen)
+{
+  NS_IF_ADDREF(*outScreen = mOneScreen.get());
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 PuppetScreenManager::GetPrimaryScreen(nsIScreen** outScreen)
 {
   NS_IF_ADDREF(*outScreen = mOneScreen.get());
diff -r fec90cbfbaad widget/cocoa/nsChildView.mm
--- a/widget/cocoa/nsChildView.mm	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/cocoa/nsChildView.mm	Thu Feb 11 17:49:41 2016 +0100
@@ -6399,7 +6399,7 @@
   [self performSelector:@selector(shutdownAndReleaseCalledOnEventThread) onThread:mThread withObject:nil waitUntilDone:NO];
 }
 
-static const CGEventField kCGWindowNumberField = 51;
+static const CGEventField kCGWindowNumberField = (const CGEventField) 51;
 
 // Called on scroll thread
 - (void)handleEvent:(CGEventRef)cgEvent type:(CGEventType)type
diff -r fec90cbfbaad widget/cocoa/nsColorPicker.h
--- a/widget/cocoa/nsColorPicker.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/cocoa/nsColorPicker.h	Thu Feb 11 17:49:41 2016 +0100
@@ -22,7 +22,7 @@
   NS_DECL_ISUPPORTS
 
   NS_IMETHOD Init(nsIDOMWindow* aParent, const nsAString& aTitle,
-                  const nsAString& aInitialColor) override;
+                  const nsAString& aInitialColor, bool aShowAlpha) override;
   NS_IMETHOD Open(nsIColorPickerShownCallback* aCallback) override;
 
   // For NSColorPanelWrapper.
@@ -44,6 +44,7 @@
 
   nsString             mTitle;
   nsString             mColor;
+  PRBool               mShowsAlpha;
   nsCOMPtr<nsIColorPickerShownCallback> mCallback;
 };
 
diff -r fec90cbfbaad widget/cocoa/nsColorPicker.mm
--- a/widget/cocoa/nsColorPicker.mm	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/cocoa/nsColorPicker.mm	Thu Feb 11 17:49:41 2016 +0100
@@ -9,6 +9,8 @@
 #include "nsCocoaUtils.h"
 #include "nsThreadUtils.h"
 
+#include "nsCSSParser.h"
+
 using namespace mozilla;
 
 static unsigned int
@@ -37,7 +39,7 @@
   nsColorPicker* mColorPicker;
 }
 - (id)initWithPicker:(nsColorPicker*)aPicker;
-- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle;
+- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle showsAlpha:(BOOL)aShowsAlpha;
 - (void)retarget:(nsColorPicker*)aPicker;
 - (void)colorChanged:(NSColorPanel*)aPanel;
 @end
@@ -52,11 +54,12 @@
   return self;
 }
 
-- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle
+- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle showsAlpha:(BOOL)aShowsAlpha
 {
   [mColorPanel setTitle:aTitle];
   [mColorPanel setColor:aInitialColor];
   [mColorPanel setTarget:self];
+  [mColorPanel setShowsAlpha:aShowsAlpha];
   [mColorPanel setAction:@selector(colorChanged:)];
   [mColorPanel setDelegate:self];
   [mColorPanel makeKeyAndOrderFront:nil];
@@ -103,12 +106,13 @@
 
 NS_IMETHODIMP
 nsColorPicker::Init(nsIDOMWindow* aParent, const nsAString& aTitle,
-                    const nsAString& aInitialColor)
+                    const nsAString& aInitialColor, bool aShowAlpha)
 {
   MOZ_ASSERT(NS_IsMainThread(),
       "Color pickers can only be opened from main thread currently");
   mTitle = aTitle;
   mColor = aInitialColor;
+  mShowsAlpha = aShowAlpha;
 
   if (sColorPanelWrapper) {
     // Update current wrapper to target the new input instead
@@ -123,26 +127,43 @@
 /* static */ NSColor*
 nsColorPicker::GetNSColorFromHexString(const nsAString& aColor)
 {
-  NSString* str = nsCocoaUtils::ToNSString(aColor);
+  nsCSSValue value;
+  nsCSSParser parser;
+  if (!parser.ParseColorString(aColor, nullptr, 0, value)) {
+    return [NSColor colorWithDeviceRed: 0 green: 0 blue: 0 alpha: 1];
+  }
 
-  double red = HexStrToInt([str substringWithRange:NSMakeRange(1, 2)]) / 255.0;
-  double green = HexStrToInt([str substringWithRange:NSMakeRange(3, 2)]) / 255.0;
-  double blue = HexStrToInt([str substringWithRange:NSMakeRange(5, 2)]) / 255.0;
+  nscolor color;
+  if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
+    return [NSColor colorWithDeviceRed: 0 green: 0 blue: 0 alpha: 1];
+  }
 
-  return [NSColor colorWithDeviceRed: red green: green blue: blue alpha: 1.0];
+  return [NSColor colorWithRed: ((float)NS_GET_R(color))/255.0
+                         green: ((float)NS_GET_G(color))/255.0
+                          blue: ((float)NS_GET_B(color))/255.0
+                         alpha: ((float)NS_GET_A(color))/255.0];
 }
 
 /* static */ void
 nsColorPicker::GetHexStringFromNSColor(NSColor* aColor, nsAString& aResult)
 {
-  CGFloat redFloat, greenFloat, blueFloat;
-  [aColor getRed: &redFloat green: &greenFloat blue: &blueFloat alpha: nil];
-
-  nsCocoaUtils::GetStringForNSString([NSString stringWithFormat:@"#%02x%02x%02x",
-                                       (int)(redFloat * 255),
-                                       (int)(greenFloat * 255),
-                                       (int)(blueFloat * 255)],
-                                     aResult);
+  CGFloat redFloat, greenFloat, blueFloat, alphaFloat;
+  [aColor getRed: &redFloat green: &greenFloat blue: &blueFloat alpha: &alphaFloat];
+  if (alphaFloat < 1.0f) {
+    nsCocoaUtils::GetStringForNSString([NSString stringWithFormat:@"rgba(%d, %d, %d, %1.2f)",
+                                         (int)(redFloat * 255 + 0.5f),
+                                         (int)(greenFloat * 255 + 0.5f),
+                                         (int)(blueFloat * 255 + 0.5f),
+                                         (float) alphaFloat],
+                                       aResult);
+  }
+  else {
+    nsCocoaUtils::GetStringForNSString([NSString stringWithFormat:@"#%02x%02x%02x",
+                                         (int)(redFloat * 255 + 0.5f),
+                                         (int)(greenFloat * 255 + 0.5f),
+                                         (int)(blueFloat * 255 + 0.5f)],
+                                       aResult);
+  }
 }
 
 NS_IMETHODIMP
@@ -152,7 +173,8 @@
   mCallback = aCallback;
 
   [sColorPanelWrapper open:GetNSColorFromHexString(mColor)
-              title:nsCocoaUtils::ToNSString(mTitle)];
+              title:nsCocoaUtils::ToNSString(mTitle)
+              showsAlpha:mShowsAlpha];
 
   NS_ADDREF_THIS();
 
@@ -162,7 +184,12 @@
 void
 nsColorPicker::Update(NSColor* aColor)
 {
-  GetHexStringFromNSColor(aColor, mColor);
+  NSColor *color = aColor;
+  if ([[aColor colorSpaceName] isEqualToString:NSNamedColorSpace])        {
+    color = [aColor colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
+  }
+
+  GetHexStringFromNSColor(color, mColor);
   mCallback->Update(mColor);
 }
 
diff -r fec90cbfbaad widget/cocoa/nsMenuItemX.mm
--- a/widget/cocoa/nsMenuItemX.mm	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/cocoa/nsMenuItemX.mm	Thu Feb 11 17:49:41 2016 +0100
@@ -259,6 +259,29 @@
       uint8_t modifiers = nsMenuUtilsX::GeckoModifiersForNodeAttribute(modifiersStr);
 
       unsigned int macModifiers = nsMenuUtilsX::MacModifiersForGeckoModifiers(modifiers);
+      // If we're empty, try the keyCode instead.
+      if (keyChar.Equals(NS_LITERAL_STRING(" ")) || keyChar.IsEmpty()) {
+
+        keyContent->GetAttr(kNameSpaceID_None, nsGkAtoms::keycode, keyChar);
+
+        if (keyChar.Equals(NS_LITERAL_STRING("VK_F2"))) {
+          unichar ch[1];
+          ch[0] = NSF2FunctionKey;
+          macModifiers |= NSFunctionKeyMask;
+          [mNativeMenuItem setKeyEquivalentModifierMask:macModifiers];
+          [mNativeMenuItem setKeyEquivalent:[NSString stringWithCharacters:ch length:1]];
+          return;
+        }
+        else if (keyChar.Equals(NS_LITERAL_STRING("VK_F4"))) {
+          unichar ch[1];
+          ch[0] = NSF4FunctionKey;
+          macModifiers |= NSFunctionKeyMask;
+          [mNativeMenuItem setKeyEquivalentModifierMask:macModifiers];
+          [mNativeMenuItem setKeyEquivalent:[NSString stringWithCharacters:ch length:1]];
+          return;
+        }
+      }
+
       [mNativeMenuItem setKeyEquivalentModifierMask:macModifiers];
 
       NSString *keyEquivalent = [[NSString stringWithCharacters:(unichar*)keyChar.get()
diff -r fec90cbfbaad widget/cocoa/nsNativeThemeCocoa.mm
--- a/widget/cocoa/nsNativeThemeCocoa.mm	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/cocoa/nsNativeThemeCocoa.mm	Thu Feb 11 17:49:41 2016 +0100
@@ -2612,7 +2612,7 @@
       BOOL isMain = [win isMainWindow];
       float unifiedToolbarHeight = [win isKindOfClass:[ToolbarWindow class]] ?
         [(ToolbarWindow*)win unifiedToolbarHeight] : macRect.size.height;
-      DrawNativeTitlebar(cgContext, macRect, unifiedToolbarHeight, isMain, YES);
+      //DrawNativeTitlebar(cgContext, macRect, unifiedToolbarHeight, isMain, YES);
     }
       break;
 
diff -r fec90cbfbaad widget/cocoa/nsScreenManagerCocoa.mm
--- a/widget/cocoa/nsScreenManagerCocoa.mm	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/cocoa/nsScreenManagerCocoa.mm	Thu Feb 11 17:49:41 2016 +0100
@@ -145,3 +145,23 @@
 
     NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
+
+NS_IMETHODIMP
+nsScreenManagerCocoa::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+    NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
+
+    uint32_t numberOfScreens;
+    GetNumberOfScreens(&numberOfScreens);
+    if (aIndex >= numberOfScreens)
+        return NS_ERROR_FAILURE;
+  
+    NSScreen *sc = [[NSScreen screens] objectAtIndex: aIndex];
+  
+    *outScreen = ScreenForCocoaScreen(sc);
+    NS_ADDREF(*outScreen);
+  
+    return NS_OK;
+  
+    NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+}
diff -r fec90cbfbaad widget/gtk/nsColorPicker.cpp
--- a/widget/gtk/nsColorPicker.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/gtk/nsColorPicker.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -4,6 +4,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include <gtk/gtk.h>
+#include <gtk/gtkcolorsel.h>
 
 #include "nsColor.h"
 #include "nsColorPicker.h"
@@ -11,6 +12,8 @@
 #include "nsIWidget.h"
 #include "WidgetUtils.h"
 
+#include "nsCSSParser.h"
+
 NS_IMPL_ISUPPORTS(nsColorPicker, nsIColorPicker)
 
 int nsColorPicker::convertGdkColorComponent(guint16 color_component) {
@@ -40,11 +43,13 @@
 /* void init (in nsIDOMWindow parent, in AString title, in short mode); */
 NS_IMETHODIMP nsColorPicker::Init(nsIDOMWindow *parent,
                                   const nsAString& title,
-                                  const nsAString& initialColor)
+                                  const nsAString& initialColor,
+                                  bool aShowsAlpha)
 {
   mParentWidget = mozilla::widget::WidgetUtils::DOMWindowToWidget(parent);
   mTitle = title;
   mInitialColor = initialColor;
+  mShowsAlpha = aShowsAlpha;
 
   return NS_OK;
 }
@@ -53,15 +58,14 @@
 NS_IMETHODIMP nsColorPicker::Open(nsIColorPickerShownCallback *aColorPickerShownCallback)
 {
 
-  // Input color string should be 7 length (i.e. a string representing a valid
-  // simple color)
-  if (mInitialColor.Length() != 7) {
+  nsCSSValue value;
+  nsCSSParser parser;
+  if (!parser.ParseColorString(mInitialColor, nullptr, 0, value)) {
     return NS_ERROR_FAILURE;
   }
 
-  const nsAString& withoutHash  = StringTail(mInitialColor, 6);
   nscolor color;
-  if (!NS_HexToRGB(withoutHash, &color)) {
+  if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
     return NS_ERROR_FAILURE;
   }
 
@@ -85,6 +89,8 @@
     gtk_window_set_destroy_with_parent(window, TRUE);
   }
 
+  gtk_color_selection_set_has_opacity_control(WidgetGetColorSelection(color_chooser),
+                                              mShowsAlpha);
   gtk_color_selection_set_current_color(WidgetGetColorSelection(color_chooser),
                                         &color_gdk);
 
@@ -175,8 +181,26 @@
   GdkColor rgba;
   gtk_color_selection_get_current_color(colorselection, &rgba);
 
-  mColor.Assign('#');
-  mColor += ToHexString(convertGdkColorComponent(rgba.red));
-  mColor += ToHexString(convertGdkColorComponent(rgba.green));
-  mColor += ToHexString(convertGdkColorComponent(rgba.blue));
+  guint16 alphaValue = 65535;
+  if (mShowsAlpha) {
+    alphaValue = gtk_color_selection_get_current_alpha(colorselection);
+  }
+
+  if (alphaValue == 65535) {
+    mColor.Assign('#');
+    mColor += ToHexString(convertGdkColorComponent(rgba.red));
+    mColor += ToHexString(convertGdkColorComponent(rgba.green));
+    mColor += ToHexString(convertGdkColorComponent(rgba.blue));
+  }
+  else {
+    mColor.AssignWithConversion("rgba(");
+    mColor.AppendInt(convertGdkColorComponent(rgba.red), 10);
+    mColor.AppendLiteral(", ");
+    mColor.AppendInt(convertGdkColorComponent(rgba.green), 10);
+    mColor.AppendLiteral(", ");
+    mColor.AppendInt(convertGdkColorComponent(rgba.blue), 10);
+    mColor.AppendLiteral(", ");
+    mColor.AppendFloat(((float)alphaValue / 65535));
+    mColor.AppendLiteral(")");
+  }
 }
diff -r fec90cbfbaad widget/gtk/nsColorPicker.h
--- a/widget/gtk/nsColorPicker.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/gtk/nsColorPicker.h	Thu Feb 11 17:49:41 2016 +0100
@@ -48,6 +48,7 @@
   nsString mTitle;
   nsString mColor;
   nsString mInitialColor;
+  bool mShowsAlpha;
 };
 
 #endif // nsColorPicker_h__
diff -r fec90cbfbaad widget/gtk/nsScreenManagerGtk.cpp
--- a/widget/gtk/nsScreenManagerGtk.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/gtk/nsScreenManagerGtk.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -367,3 +367,15 @@
 
   return rv;
 }
+
+NS_IMETHODIMP
+nsScreenManagerGtk::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+    uint32_t numberOfScreens;
+    GetNumberOfScreens(&numberOfScreens);
+    if (aIndex >= numberOfScreens)
+        return NS_ERROR_FAILURE;
+
+    NS_IF_ADDREF(*outScreen = mCachedScreenArray[aIndex]);
+    return NS_OK;
+}
diff -r fec90cbfbaad widget/gtk/nsWindow.cpp
--- a/widget/gtk/nsWindow.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/gtk/nsWindow.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -3623,6 +3623,8 @@
                 gdk_window_add_filter(gtk_widget_get_window(mShell),
                                       popup_take_focus_filter, nullptr); 
 #endif
+                // XXX BlueGriffon ugly hack to work around bug 662770
+                gtk_window_set_modal(GTK_WINDOW(mShell), TRUE);
             }
 
             GdkWindowTypeHint gtkTypeHint;
diff -r fec90cbfbaad widget/nsColorPickerProxy.cpp
--- a/widget/nsColorPickerProxy.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/nsColorPickerProxy.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -15,7 +15,7 @@
 /* void init (in nsIDOMWindow parent, in AString title, in short mode); */
 NS_IMETHODIMP
 nsColorPickerProxy::Init(nsIDOMWindow* aParent, const nsAString& aTitle,
-                         const nsAString& aInitialColor)
+                         const nsAString& aInitialColor, bool aShowsAlpha)
 {
   TabChild* tabChild = TabChild::GetFrom(aParent);
   if (!tabChild) {
@@ -24,7 +24,8 @@
 
   tabChild->SendPColorPickerConstructor(this,
                                         nsString(aTitle),
-                                        nsString(aInitialColor));
+                                        nsString(aInitialColor),
+                                        aShowsAlpha);
   NS_ADDREF_THIS();
   return NS_OK;
 }
@@ -57,4 +58,4 @@
     mCallback = nullptr;
   }
   return true;
-}
\ No newline at end of file
+}
diff -r fec90cbfbaad widget/nsIColorPicker.idl
--- a/widget/nsIColorPicker.idl	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/nsIColorPicker.idl	Thu Feb 11 17:49:41 2016 +0100
@@ -42,7 +42,7 @@
   void done(in AString color);
 };
 
-[scriptable, uuid(3c3bdcce-54b1-4ae2-8647-1a8d4712ef2e)]
+[scriptable, uuid(645FAD1F-2B55-42E1-AC15-DB4A9DF27209)]
 interface nsIColorPicker : nsISupports
 {
  /**
@@ -62,7 +62,8 @@
   *                          parameter has to follow the format specified on top
   *                          of this file.
   */
-  void init(in nsIDOMWindow parent, in AString title, in AString initialColor);
+  void init(in nsIDOMWindow parent, in AString title, in AString initialColor,
+            in boolean aShowAlpha);
 
  /**
   * Opens the color dialog asynchrounously.
diff -r fec90cbfbaad widget/nsIScreenManager.idl
--- a/widget/nsIScreenManager.idl	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/nsIScreenManager.idl	Thu Feb 11 17:49:41 2016 +0100
@@ -7,7 +7,7 @@
 #include "nsISupports.idl"
 #include "nsIScreen.idl"
 
-[scriptable, uuid(e8a96e60-6b61-4a14-bacc-53891604b502)]
+[scriptable, uuid(0F311A41-3477-4E8D-AA33-AC6F9EF1D66D)]
 interface nsIScreenManager : nsISupports
 {
     //
@@ -17,7 +17,7 @@
     // The coordinates are in pixels (not twips) and in screen coordinates.
     //
   nsIScreen screenForRect ( in long left, in long top, in long width, in long height ) ;
-
+  nsIScreen screenForIndex ( in unsigned long index);
     //
     // Returns the screen corresponding to the id. If no such screen exists,
     // this will throw NS_ERROR_FAILURE. The id is a unique numeric value
diff -r fec90cbfbaad widget/nsScreenManagerProxy.cpp
--- a/widget/nsScreenManagerProxy.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/nsScreenManagerProxy.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -84,6 +84,14 @@
 }
 
 NS_IMETHODIMP
+nsScreenManagerProxy::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+  // At this time, there's no need for child processes to query for
+  // screens by ID.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 nsScreenManagerProxy::ScreenForRect(int32_t inLeft,
                                     int32_t inTop,
                                     int32_t inWidth,
diff -r fec90cbfbaad widget/windows/nsColorPicker.cpp
--- a/widget/windows/nsColorPicker.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/windows/nsColorPicker.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -192,12 +192,14 @@
 NS_IMETHODIMP
 nsColorPicker::Init(nsIDOMWindow* parent,
                     const nsAString& title,
-                    const nsAString& aInitialColor)
+                    const nsAString& aInitialColor,
+                    bool aShowsAlpha)
 {
   NS_PRECONDITION(parent,
       "Null parent passed to colorpicker, no color picker for you!");
   mParentWidget =  WidgetUtils::DOMWindowToWidget(parent);
   mInitialColor = ColorStringToRGB(aInitialColor);
+  mShowsAlpha = aShowsAlpha;
   return NS_OK;
 }
 
diff -r fec90cbfbaad widget/windows/nsColorPicker.h
--- a/widget/windows/nsColorPicker.h	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/windows/nsColorPicker.h	Thu Feb 11 17:49:41 2016 +0100
@@ -48,12 +48,13 @@
   NS_DECL_ISUPPORTS
 
   NS_IMETHOD Init(nsIDOMWindow* parent, const nsAString& title,
-                  const nsAString& aInitialColor);
+                  const nsAString& aInitialColor, bool aShowsAlpha);
   NS_IMETHOD Open(nsIColorPickerShownCallback* aCallback);
 
 private:
   COLORREF mInitialColor;
   nsCOMPtr<nsIWidget> mParentWidget;
+  bool mShowsAlpha;
 };
 
 #endif // nsColorPicker_h__
diff -r fec90cbfbaad widget/windows/nsScreenManagerWin.cpp
--- a/widget/windows/nsScreenManagerWin.cpp	Thu Apr 09 22:57:56 2015 -0400
+++ b/widget/windows/nsScreenManagerWin.cpp	Thu Feb 11 17:49:41 2016 +0100
@@ -185,3 +185,17 @@
   *outScreen = CreateNewScreenObject(mon);
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsScreenManagerWin::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+  *outScreen = nullptr;
+
+  if (aIndex < mScreenList.Length()) {
+    ScreenListItem& curr = mScreenList[aIndex];
+    NS_IF_ADDREF(*outScreen = curr.mScreen.get());
+    return NS_OK;
+  }
+
+  return NS_ERROR_FAILURE;
+}
