diff --git a/browser/base/content/baseMenuOverlay.xul b/browser/base/content/baseMenuOverlay.xul
--- a/browser/base/content/baseMenuOverlay.xul
+++ b/browser/base/content/baseMenuOverlay.xul
@@ -98,17 +98,17 @@
              oncommand="openHelpLink('firefox-osxkey');"
              key="&helpMac.commandkey;"
              modifiers="accel"/>
 <!-- These are used to build the Application menu under Cocoa widgets -->
         <key id="key_preferencesCmdMac"
              key="&preferencesCmdMac.commandkey;"
              modifiers="accel"/>
         <key id="key_hideThisAppCmdMac"
-             key="&hideThisAppCmdMac2.commandkey;"
+             key="&hideThisAppCmdMac.commandkey;"
              modifiers="accel"/>
         <key id="key_hideOtherAppsCmdMac"
              key="&hideOtherAppsCmdMac.commandkey;"
              modifiers="accel,alt"/>
 #endif
     </keyset>
 
     <stringbundleset id="stringbundleset">
diff --git a/browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd b/browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd
--- a/browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd
+++ b/browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd
@@ -41,14 +41,14 @@
 <!ENTITY helpShowTour2.accesskey        "o">
 
 <!ENTITY preferencesCmdMac.label        "Preferencesâ€¦">
 <!ENTITY preferencesCmdMac.commandkey   ",">
 
 <!ENTITY servicesMenuMac.label          "Services">
 
 <!ENTITY hideThisAppCmdMac2.label       "Hide &brandShorterName;">
-<!ENTITY hideThisAppCmdMac2.commandkey  "H">
+<!ENTITY hideThisAppCmdMac.commandkey  "H">
 
 <!ENTITY hideOtherAppsCmdMac.label      "Hide Others">
 <!ENTITY hideOtherAppsCmdMac.commandkey "H">
 
 <!ENTITY showAllAppsCmdMac.label        "Show All">
diff --git a/build/mach_bootstrap.py b/build/mach_bootstrap.py
--- a/build/mach_bootstrap.py
+++ b/build/mach_bootstrap.py
@@ -97,17 +97,17 @@ SEARCH_PATHS = [
     'testing/web-platform/tests/tools/wptserve',
     'testing/web-platform/tests/tools/six',
     'testing/xpcshell',
     'xpcom/idl-parser',
 ]
 
 # Individual files providing mach commands.
 MACH_MODULES = [
-    'addon-sdk/mach_commands.py',
+#    'addon-sdk/mach_commands.py',
     'build/valgrind/mach_commands.py',
     'devtools/shared/css/generated/mach_commands.py',
     'dom/bindings/mach_commands.py',
     'dom/media/test/external/mach_commands.py',
     'layout/tools/reftest/mach_commands.py',
     'python/mach_commands.py',
     'python/mach/mach/commands/commandinfo.py',
     'python/mach/mach/commands/settings.py',
diff --git a/caps/nsScriptSecurityManager.cpp b/caps/nsScriptSecurityManager.cpp
--- a/caps/nsScriptSecurityManager.cpp
+++ b/caps/nsScriptSecurityManager.cpp
@@ -890,16 +890,17 @@ nsScriptSecurityManager::CheckLoadURIFla
     }
 
     // Check for target URI pointing to a file
     rv = NS_URIChainHasFlags(aTargetURI,
                              nsIProtocolHandler::URI_IS_LOCAL_FILE,
                              &hasFlags);
     NS_ENSURE_SUCCESS(rv, rv);
     if (hasFlags) {
+        return NS_OK;
         // Allow domains that were whitelisted in the prefs. In 99.9% of cases,
         // this array is empty.
         for (nsIURI* uri : EnsureFileURIWhitelist()) {
             if (EqualOrSubdomain(aSourceURI, uri)) {
                 return NS_OK;
             }
         }
 
diff --git a/dom/base/nsCopySupport.cpp b/dom/base/nsCopySupport.cpp
--- a/dom/base/nsCopySupport.cpp
+++ b/dom/base/nsCopySupport.cpp
@@ -150,17 +150,18 @@ SelectionCopyHelper(nsISelection *aSel, 
     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(aDoc);
     if (!htmlDoc) {
       selForcedTextPlain = true;
     }
   }
 
   // The mime type is ultimately text/html if the encoder successfully encoded
   // the selection as text/html.
-  bool encodedTextHTML = mimeType.EqualsLiteral(kHTMLMime);
+  bool encodedTextHTML = mimeType.EqualsLiteral(kHTMLMime) ||
+                         mimeType.EqualsLiteral("application/xhtml+xml");
 
   // First, prepare the text/plain clipboard flavor.
   nsAutoString textPlainBuf;
   if (selForcedTextPlain) {
     // Nothing to do.  buf contains the final, preformatted, raw text/plain.
     textPlainBuf.Assign(buf);
   } else {
     // Redo the encoding, but this time use pretty printing.
@@ -553,18 +554,19 @@ static nsresult AppendDOMNode(nsITransfe
   DebugOnly<nsCOMPtr<nsIHTMLDocument>> htmlDoc =
     nsCOMPtr<nsIHTMLDocument>(do_QueryInterface(document, &rv));
   NS_ENSURE_SUCCESS(rv, NS_OK);
 
   NS_ENSURE_TRUE(document->IsHTMLDocument(), NS_OK);
 
   // init encoder with document and node
   rv = docEncoder->NativeInit(document, NS_LITERAL_STRING(kHTMLMime),
-                              nsIDocumentEncoder::OutputAbsoluteLinks |
-                              nsIDocumentEncoder::OutputEncodeW3CEntities);
+                              Preferences::GetBool("clipboard.absoluteLinks", true)
+                                ? nsIDocumentEncoder::OutputEncodeCharacterEntities | nsIDocumentEncoder::OutputAbsoluteLinks
+                                : nsIDocumentEncoder::OutputEncodeCharacterEntities);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = docEncoder->SetNativeNode(aDOMNode);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // serialize to string
   nsAutoString html, context, info;
   rv = docEncoder->EncodeToStringWithContext(context, info, html);
diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -7305,16 +7305,23 @@ nsDocument::GetInputEncoding(nsAString& 
 
 NS_IMETHODIMP
 nsDocument::GetMozSyntheticDocument(bool *aSyntheticDocument)
 {
   *aSyntheticDocument = mIsSyntheticDocument;
   return NS_OK;
 }
 
+ NS_IMETHODIMP
+nsDocument::GetHasXMLDeclaration(bool *aHasXMLDeclaration)
+{
+  *aHasXMLDeclaration = mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS;
+  return NS_OK;
+}
+
 NS_IMETHODIMP
 nsDocument::GetDocumentURI(nsAString& aDocumentURI)
 {
   nsString temp;
   nsresult rv = nsIDocument::GetDocumentURI(temp);
   aDocumentURI = temp;
   return rv;
 }
diff --git a/dom/base/nsDocumentEncoder.cpp b/dom/base/nsDocumentEncoder.cpp
--- a/dom/base/nsDocumentEncoder.cpp
+++ b/dom/base/nsDocumentEncoder.cpp
@@ -114,16 +114,21 @@ protected:
       ShadowRoot* shadowRoot = ShadowRoot::FromNode(aNode);
       if (shadowRoot) {
         content = shadowRoot->GetHost();
       } else {
         content = do_QueryInterface(aNode);
       }
 
       if (content) {
+        nsIAtom *tag = content->NodeInfo()->NameAtom();
+        if (tag == nsGkAtoms::script
+            || tag == nsGkAtoms::style) {
+          return true;
+        }
         nsIFrame* frame = content->GetPrimaryFrame();
         if (!frame) {
           if (aNode->IsNodeOfType(nsINode::eTEXT)) {
             // We have already checked that our parent is visible.
             return true;
           }
           if (aNode->IsHTMLElement(nsGkAtoms::rp)) {
             // Ruby parentheses are part of ruby structure, hence
@@ -1302,17 +1307,19 @@ nsHTMLCopyEncoder::Init(nsIDOMDocument* 
   if (aMimeType.EqualsLiteral("text/plain")) {
     mMimeType.AssignLiteral("text/plain");
   } else {
     mMimeType.AssignLiteral("text/html");
   }
 
   // Make all links absolute when copying
   // (see related bugs #57296, #41924, #58646, #32768)
-  mFlags = aFlags | OutputAbsoluteLinks;
+  mFlags = Preferences::GetBool("clipboard.absoluteLinks", true)
+             ? aFlags | nsIDocumentEncoder::OutputAbsoluteLinks
+             : aFlags;
 
   if (!mDocument->IsScriptEnabled())
     mFlags |= OutputNoScriptContent;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -1403,17 +1410,17 @@ nsHTMLCopyEncoder::SetSelection(nsISelec
     return NS_OK;
   }
 
   // XXX We should try to get rid of the Selection object here.
   // XXX bug 1245883
 
   // also consider ourselves in a text widget if we can't find an html document
   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
-  if (!(htmlDoc && mDocument->IsHTMLDocument())) {
+  if (!htmlDoc) {
     mIsTextWidget = true;
     mSelection = aSelection;
     // mMimeType is set to text/plain when encoding starts.
     return NS_OK;
   }
 
   // there's no Clone() for selection! fix...
   //nsresult rv = aSelection->Clone(getter_AddRefs(mSelection);
@@ -1424,19 +1431,20 @@ nsHTMLCopyEncoder::SetSelection(nsISelec
   // loop thru the ranges in the selection
   for (uint32_t rangeIdx = 0; rangeIdx < rangeCount; ++rangeIdx) {
     range = selection->GetRangeAt(rangeIdx);
     NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
     nsCOMPtr<nsIDOMRange> myRange;
     range->CloneRange(getter_AddRefs(myRange));
     NS_ENSURE_TRUE(myRange, NS_ERROR_FAILURE);
 
+    // BLUEGRIFFON, do not promote ranges for copy
     // adjust range to include any ancestors who's children are entirely selected
-    rv = PromoteRange(myRange);
-    NS_ENSURE_SUCCESS(rv, rv);
+    /*rv = PromoteRange(myRange);
+    NS_ENSURE_SUCCESS(rv, rv);*/
 
     ErrorResult result;
     nsRange* r = static_cast<nsRange*>(myRange.get());
     mSelection->AsSelection()->AddRangeInternal(*r, mDocument, result);
     rv = result.StealNSResult();
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
diff --git a/dom/base/nsFocusManager.cpp b/dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp
+++ b/dom/base/nsFocusManager.cpp
@@ -2711,41 +2711,16 @@ nsFocusManager::DetermineElementToMoveFo
         if (startContent ==
               nsLayoutUtils::GetEditableRootContentByContentEditable(doc)) {
           doNavigation = false;
         }
       }
     }
   }
   else {
-#ifdef MOZ_XUL
-    if (aType != MOVEFOCUS_CARET) {
-      // if there is no focus, yet a panel is open, focus the first item in
-      // the panel
-      nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
-      if (pm)
-        popupFrame = pm->GetTopPopup(ePopupTypePanel);
-    }
-#endif
-    if (popupFrame) {
-      // When there is a popup open, and no starting content, start the search
-      // at the topmost popup.
-      startContent = popupFrame->GetContent();
-      NS_ASSERTION(startContent, "Popup frame doesn't have a content node");
-      // Unless we are searching for documents, set the root content to the
-      // popup as well, so that we don't tab-navigate outside the popup.
-      // When navigating by documents, we start at the popup but can navigate
-      // outside of it to look for other panels and documents.
-      if (!forDocumentNavigation) {
-        rootContent = startContent;
-      }
-
-      doc = startContent ? startContent->GetComposedDoc() : nullptr;
-    }
-    else {
       // Otherwise, for content shells, start from the location of the caret.
       nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
       if (docShell && docShell->ItemType() != nsIDocShellTreeItem::typeChrome) {
         nsCOMPtr<nsIContent> endSelectionContent;
         GetSelectionLocation(doc, presShell,
                              getter_AddRefs(startContent),
                              getter_AddRefs(endSelectionContent));
         // If the selection is on the rootContent, then there is no selection
@@ -2767,23 +2742,37 @@ nsFocusManager::DetermineElementToMoveFo
         if (startContent) {
           // when starting from a selection, we always want to find the next or
           // previous element in the document. So the tabindex on elements
           // should be ignored.
           ignoreTabIndex = true;
         }
       }
 
+#ifdef MOZ_XUL
+    else {
+      // if there is no focus, yet a panel is open, focus the first item in
+      // the panel
+      nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
+      if (pm)
+        popupFrame = pm->GetTopPopup(ePopupTypePanel);
+      if (popupFrame) {
+        rootContent = popupFrame->GetContent();
+        NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
+        startContent = rootContent;
+      }
+    }
+#endif
+
       if (!startContent) {
         // otherwise, just use the root content as the starting point
         startContent = rootContent;
         NS_ENSURE_TRUE(startContent, NS_OK);
       }
     }
-  }
 
   // Check if the starting content is the same as the content assigned to the
   // retargetdocumentfocus attribute. Is so, we don't want to start searching
   // from there but instead from the beginning of the document. Otherwise, the
   // content that appears before the retargetdocumentfocus element will never
   // get checked as it will be skipped when the focus is retargetted to it.
   if (forDocumentNavigation && doc->IsXULDocument()) {
     nsAutoString retarget;
diff --git a/dom/base/nsGkAtomList.h b/dom/base/nsGkAtomList.h
--- a/dom/base/nsGkAtomList.h
+++ b/dom/base/nsGkAtomList.h
@@ -1142,16 +1142,17 @@ GK_ATOM(selectedindex, "selectedindex")
 GK_ATOM(self, "self")
 GK_ATOM(seltype, "seltype")
 GK_ATOM(setcookie, "set-cookie")
 GK_ATOM(setter, "setter")
 GK_ATOM(shape, "shape")
 GK_ATOM(show, "show")
 GK_ATOM(showcaret, "showcaret")
 GK_ATOM(showresizer, "showresizer")
+GK_ATOM(showtransparency, "showTransparency")
 GK_ATOM(simple, "simple")
 GK_ATOM(single, "single")
 GK_ATOM(size, "size")
 GK_ATOM(sizes, "sizes")
 GK_ATOM(sizemode, "sizemode")
 GK_ATOM(sizetopopup, "sizetopopup")
 GK_ATOM(slider, "slider")
 GK_ATOM(small, "small")
diff --git a/dom/base/nsHTMLContentSerializer.cpp b/dom/base/nsHTMLContentSerializer.cpp
--- a/dom/base/nsHTMLContentSerializer.cpp
+++ b/dom/base/nsHTMLContentSerializer.cpp
@@ -192,111 +192,120 @@ nsHTMLContentSerializer::AppendElementSt
     return rv;
   }
 
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsIAtom *name = content->NodeInfo()->NameAtom();
   int32_t ns = content->GetNameSpaceID();
 
-  bool lineBreakBeforeOpen = LineBreakBeforeOpen(ns, name);
+  bool hideTag = false;
+  if (ns != kNameSpaceID_XHTML) {
+    nsAutoString nsStr;
+    nsresult rv = nsContentUtils::NameSpaceManager()->GetNameSpaceURI(ns, nsStr);
+    hideTag = ( NS_SUCCEEDED(rv) && nsStr.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon"));
+  }
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    if (mColPos && lineBreakBeforeOpen) {
-      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    else {
-      NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    if (!mColPos) {
-      NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);
+  if (!hideTag) {
+    bool lineBreakBeforeOpen = LineBreakBeforeOpen(ns, name);
+
+    if (((mDoFormat || forceFormat) && !PreLevel()) || mDoRaw) {
+      if (mColPos && lineBreakBeforeOpen) {
+        NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+        mMayIgnoreLineBreakSequence = PR_FALSE;
+      }
+      else {
+        NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);;
+      }
+      if (!mColPos && !mDoRaw) {
+        NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);;;
+      }
+      else if (mAddSpace) {
+        NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);;;
+        mAddSpace = false;
+      }
     }
     else if (mAddSpace) {
       bool result = AppendToString(char16_t(' '), aStr);
       mAddSpace = false;
       NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
     }
-  }
-  else if (mAddSpace) {
-    bool result = AppendToString(char16_t(' '), aStr);
-    mAddSpace = false;
-    NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
-  }
-  else {
-    NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
-  // called
-  mAddNewlineForRootNode = false;
-
-  NS_ENSURE_TRUE(AppendToString(kLessThan, aStr), NS_ERROR_OUT_OF_MEMORY);
-
-  NS_ENSURE_TRUE(AppendToString(nsDependentAtomString(name), aStr), NS_ERROR_OUT_OF_MEMORY);
-
-  MaybeEnterInPreContent(content);
-
-  // for block elements, we increase the indentation
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel())
-    NS_ENSURE_TRUE(IncrIndentation(name), NS_ERROR_OUT_OF_MEMORY);
-
-  // Need to keep track of OL and LI elements in order to get ordinal number 
-  // for the LI.
-  if (mIsCopying && name == nsGkAtoms::ol && ns == kNameSpaceID_XHTML){
-    // We are copying and current node is an OL;
-    // Store its start attribute value in olState->startVal.
-    nsAutoString start;
-    int32_t startAttrVal = 0;
+    else {
+      NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
+    }
+    // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
+    // called
+    mAddNewlineForRootNode = false;
 
-    aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::start, start);
-    if (!start.IsEmpty()){
-      nsresult rv = NS_OK;
-      startAttrVal = start.ToInteger(&rv);
-      //If OL has "start" attribute, first LI element has to start with that value
-      //Therefore subtracting 1 as all the LI elements are incrementing it before using it;
-      //In failure of ToInteger(), default StartAttrValue to 0.
-      if (NS_SUCCEEDED(rv))
-        startAttrVal--; 
-      else
-        startAttrVal = 0;
-    }
-    mOLStateStack.AppendElement(olState(startAttrVal, true));
-  }
-
-  if (mIsCopying && name == nsGkAtoms::li && ns == kNameSpaceID_XHTML) {
-    mIsFirstChildOfOL = IsFirstChildOfOL(aOriginalElement);
-    if (mIsFirstChildOfOL){
-      // If OL is parent of this LI, serialize attributes in different manner.
-      NS_ENSURE_TRUE(SerializeLIValueAttribute(aElement, aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-  }
+    NS_ENSURE_TRUE(AppendToString(kLessThan, aStr), NS_ERROR_OUT_OF_MEMORY);
 
-  // Even LI passed above have to go through this 
-  // for serializing attributes other than "value".
-  nsAutoString dummyPrefix;
-  NS_ENSURE_TRUE(SerializeHTMLAttributes(content,
-                                         aOriginalElement,
-                                         dummyPrefix,
-                                         EmptyString(),
-                                         name,
-                                         ns,
-                                         aStr), NS_ERROR_OUT_OF_MEMORY);
+    NS_ENSURE_TRUE(AppendToString(nsDependentAtomString(name), aStr), NS_ERROR_OUT_OF_MEMORY);
 
-  NS_ENSURE_TRUE(AppendToString(kGreaterThan, aStr), NS_ERROR_OUT_OF_MEMORY);
+    MaybeEnterInPreContent(content);
 
-  if (ns == kNameSpaceID_XHTML &&
-      (name == nsGkAtoms::script ||
-       name == nsGkAtoms::style ||
-       name == nsGkAtoms::noscript ||
-       name == nsGkAtoms::noframes)) {
-    ++mDisableEntityEncoding;
-  }
+    // for block elements, we increase the indentation
+    if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel())
+      NS_ENSURE_TRUE(IncrIndentation(name), NS_ERROR_OUT_OF_MEMORY);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel() &&
-    LineBreakAfterOpen(ns, name)) {
-    NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+    // Need to keep track of OL and LI elements in order to get ordinal number
+    // for the LI.
+    if (mIsCopying && name == nsGkAtoms::ol && ns == kNameSpaceID_XHTML){
+      // We are copying and current node is an OL;
+      // Store its start attribute value in olState->startVal.
+      nsAutoString start;
+      int32_t startAttrVal = 0;
+
+      aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::start, start);
+      if (!start.IsEmpty()){
+        nsresult rv = NS_OK;
+        startAttrVal = start.ToInteger(&rv);
+        //If OL has "start" attribute, first LI element has to start with that value
+        //Therefore subtracting 1 as all the LI elements are incrementing it before using it;
+        //In failure of ToInteger(), default StartAttrValue to 0.
+        if (NS_SUCCEEDED(rv))
+          startAttrVal--;
+        else
+          startAttrVal = 0;
+      }
+      mOLStateStack.AppendElement(olState(startAttrVal, true));
+    }
+
+    if (mIsCopying && name == nsGkAtoms::li && ns == kNameSpaceID_XHTML) {
+      mIsFirstChildOfOL = IsFirstChildOfOL(aOriginalElement);
+      if (mIsFirstChildOfOL){
+        // If OL is parent of this LI, serialize attributes in different manner.
+        NS_ENSURE_TRUE(SerializeLIValueAttribute(aElement, aStr), NS_ERROR_OUT_OF_MEMORY);
+      }
+    }
+
+    // Even LI passed above have to go through this
+    // for serializing attributes other than "value".
+    nsAutoString dummyPrefix;
+    NS_ENSURE_TRUE(SerializeHTMLAttributes(content,
+                                           aOriginalElement,
+                                           dummyPrefix,
+                                           EmptyString(),
+                                           name,
+                                           ns,
+                                           aStr), NS_ERROR_OUT_OF_MEMORY);
+
+    NS_ENSURE_TRUE(AppendToString(kGreaterThan, aStr), NS_ERROR_OUT_OF_MEMORY);
+
+    if (ns == kNameSpaceID_XHTML &&
+        (name == nsGkAtoms::script ||
+         name == nsGkAtoms::style ||
+         name == nsGkAtoms::noscript ||
+         name == nsGkAtoms::noframes)) {
+      ++mDisableEntityEncoding;
+    }
+
+    if ((mDoFormat || forceFormat) && !PreLevel() &&
+      !mDoRaw && LineBreakAfterOpen(ns, name)) {
+      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+    }
   }
 
   NS_ENSURE_TRUE(AfterElementStart(content, aOriginalElement, aStr), NS_ERROR_OUT_OF_MEMORY);
 
   return NS_OK;
 }
   
 NS_IMETHODIMP 
@@ -305,16 +314,23 @@ nsHTMLContentSerializer::AppendElementEn
 {
   NS_ENSURE_ARG(aElement);
 
   nsIContent* content = aElement;
 
   nsIAtom *name = content->NodeInfo()->NameAtom();
   int32_t ns = content->GetNameSpaceID();
 
+  if (ns != kNameSpaceID_XHTML) {
+    nsAutoString nsStr;
+    nsresult rv = nsContentUtils::NameSpaceManager()->GetNameSpaceURI(ns, nsStr);
+    if (NS_SUCCEEDED(rv) && nsStr.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon"))
+      return NS_OK;
+  }
+
   if (ns == kNameSpaceID_XHTML &&
       (name == nsGkAtoms::script ||
        name == nsGkAtoms::style ||
        name == nsGkAtoms::noscript ||
        name == nsGkAtoms::noframes)) {
     --mDisableEntityEncoding;
   }
 
@@ -492,17 +508,18 @@ nsHTMLContentSerializer::AppendAndTransl
 
   if (mDisableEntityEncoding) {
     return aOutputStr.Append(aStr, mozilla::fallible);
   }
 
   bool nonBasicEntities =
     !!(mFlags & (nsIDocumentEncoder::OutputEncodeLatin1Entities |
                  nsIDocumentEncoder::OutputEncodeHTMLEntities   |
-                 nsIDocumentEncoder::OutputEncodeW3CEntities));
+                 nsIDocumentEncoder::OutputEncodeW3CEntities    |
+                 nsIDocumentEncoder::OutputEncodeCharacterEntities));
 
   if (!nonBasicEntities &&
       (mFlags & (nsIDocumentEncoder::OutputEncodeBasicEntities))) {
     const uint8_t* entityTable = mInAttribute ? kAttrEntities : kEntities;
     uint32_t start = 0;
     const uint32_t len = aStr.Length();
     for (uint32_t i = 0; i < len; ++i) {
       const char* entity = nullptr;
@@ -549,17 +566,23 @@ nsHTMLContentSerializer::AppendAndTransl
       const char* fullConstEntityText = nullptr;
       char* fullEntityText = nullptr;
 
       advanceLength = 0;
       // for each character in this chunk, check if it
       // needs to be replaced
       for (; c < fragmentEnd; c++, advanceLength++) {
         char16_t val = *c;
-        if (val <= kValNBSP && entityTable[val]) {
+        if ((val == kValNBSP || val > 127) &&
+            (mFlags & nsIDocumentEncoder::OutputEncodeCharacterEntities)) {
+          nsAutoString entityValue(char16_t('#'));
+          entityValue.AppendInt(val);
+          entityText = ToNewCString(entityValue);
+          break;
+        } else if (val <= kValNBSP && entityTable[val]) {
           fullConstEntityText = kEntityStrings[entityTable[val]];
           break;
         } else if (val > 127 &&
                   ((val < 256 &&
                     mFlags & nsIDocumentEncoder::OutputEncodeLatin1Entities) ||
                     mFlags & nsIDocumentEncoder::OutputEncodeHTMLEntities)) {
           entityReplacement.Truncate();
           parserService->HTMLConvertUnicodeToEntity(val, entityReplacement);
diff --git a/dom/base/nsIDocumentEncoder.idl b/dom/base/nsIDocumentEncoder.idl
--- a/dom/base/nsIDocumentEncoder.idl
+++ b/dom/base/nsIDocumentEncoder.idl
@@ -13,17 +13,17 @@ interface nsIOutputStream;
 
 %{ C++
 class nsINode;
 class nsIDocument;
 %}
 [ptr] native nsINodePtr(nsINode);
 [ptr] native nsIDocumentPtr(nsIDocument);
 
-[scriptable, uuid(3d9371d8-a2ad-403e-8b0e-8885ad3562e3)]
+[scriptable, uuid(30a3161c-09e0-425e-84e6-ff952c0fd859)]
 interface nsIDocumentEncoderNodeFixup : nsISupports
 {
   /**
    * Create a fixed up version of a node. This method is called before
    * each node in a document is about to be persisted. The implementor
    * may return a new node with fixed up attributes or null. If null is
    * returned the node should be used as-is.
    * @param aNode Node to fixup.
@@ -242,16 +242,21 @@ interface nsIDocumentEncoder : nsISuppor
 
   /**
    * Disallow breaking of long character strings. This is important
    * for serializing e-mail which contains CJK strings. These must
    * not be broken just as "normal" longs strings aren't broken.
    */
   const unsigned long OutputDisallowLineBreaking = (1 << 27);
 
+ /**
+   * Output all non-ascii characters as numeric entities
+   */                                                                                                                                         
+  const unsigned long OutputEncodeCharacterEntities = (1 << 28);
+
   /**
    * Initialize with a pointer to the document and the mime type.
    * @param aDocument Document to encode.
    * @param aMimeType MimeType to use. May also be set by SetMimeType.
    * @param aFlags Flags to use while encoding. May also be set by SetFlags.
    */
   void init(in nsIDOMDocument aDocument,
             in AString aMimeType,
diff --git a/dom/base/nsXHTMLContentSerializer.cpp b/dom/base/nsXHTMLContentSerializer.cpp
--- a/dom/base/nsXHTMLContentSerializer.cpp
+++ b/dom/base/nsXHTMLContentSerializer.cpp
@@ -58,23 +58,16 @@ nsXHTMLContentSerializer::~nsXHTMLConten
   NS_ASSERTION(mOLStateStack.IsEmpty(), "Expected OL State stack to be empty");
 }
 
 NS_IMETHODIMP
 nsXHTMLContentSerializer::Init(uint32_t aFlags, uint32_t aWrapColumn,
                               const char* aCharSet, bool aIsCopying,
                               bool aRewriteEncodingDeclaration)
 {
-  // The previous version of the HTML serializer did implicit wrapping
-  // when there is no flags, so we keep wrapping in order to keep
-  // compatibility with the existing calling code
-  // XXXLJ perhaps should we remove this default settings later ?
-  if (aFlags & nsIDocumentEncoder::OutputFormatted ) {
-      aFlags = aFlags | nsIDocumentEncoder::OutputWrap;
-  }
 
   nsresult rv;
   rv = nsXMLContentSerializer::Init(aFlags, aWrapColumn, aCharSet, aIsCopying, aRewriteEncodingDeclaration);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mRewriteEncodingDeclaration = aRewriteEncodingDeclaration;
   mIsCopying = aIsCopying;
   mIsFirstChildOfOL = false;
@@ -657,17 +650,26 @@ nsXHTMLContentSerializer::LineBreakBefor
 
   if (aName == nsGkAtoms::title ||
       aName == nsGkAtoms::meta  ||
       aName == nsGkAtoms::link  ||
       aName == nsGkAtoms::style ||
       aName == nsGkAtoms::select ||
       aName == nsGkAtoms::option ||
       aName == nsGkAtoms::script ||
-      aName == nsGkAtoms::html) {
+      aName == nsGkAtoms::html ||
+      aName == nsGkAtoms::head ||
+      //aName == nsGkAtoms::body ||
+      aName == nsGkAtoms::table ||
+      aName == nsGkAtoms::caption ||
+      aName == nsGkAtoms::tbody ||
+      aName == nsGkAtoms::thead ||
+      aName == nsGkAtoms::tfoot ||
+      aName == nsGkAtoms::tr ||
+      aName == nsGkAtoms::td) {
     return true;
   }
   else {
     nsIParserService* parserService = nsContentUtils::GetParserService();
 
     if (parserService) {
       bool res;
       parserService->
@@ -684,22 +686,24 @@ nsXHTMLContentSerializer::LineBreakAfter
 {
 
   if (aNamespaceID != kNameSpaceID_XHTML) {
     return false;
   }
 
   if ((aName == nsGkAtoms::html) ||
       (aName == nsGkAtoms::head) ||
-      (aName == nsGkAtoms::body) ||
+      // (aName == nsGkAtoms::body) ||
       (aName == nsGkAtoms::ul) ||
       (aName == nsGkAtoms::ol) ||
       (aName == nsGkAtoms::dl) ||
       (aName == nsGkAtoms::table) ||
       (aName == nsGkAtoms::tbody) ||
+      (aName == nsGkAtoms::thead) ||
+      (aName == nsGkAtoms::tfoot) ||
       (aName == nsGkAtoms::tr) ||
       (aName == nsGkAtoms::br) ||
       (aName == nsGkAtoms::meta) ||
       (aName == nsGkAtoms::link) ||
       (aName == nsGkAtoms::script) ||
       (aName == nsGkAtoms::select) ||
       (aName == nsGkAtoms::map) ||
       (aName == nsGkAtoms::area) ||
@@ -777,39 +781,45 @@ nsXHTMLContentSerializer::LineBreakAfter
 void
 nsXHTMLContentSerializer::MaybeEnterInPreContent(nsIContent* aNode)
 {
   if (!ShouldMaintainPreLevel() ||
       !aNode->IsHTMLElement()) {
     return;
   }
 
-  if (IsElementPreformatted(aNode) ||
+  PRBool disableEntityEncoding =
       aNode->IsAnyOfHTMLElements(nsGkAtoms::script,
                                  nsGkAtoms::style,
                                  nsGkAtoms::noscript,
-                                 nsGkAtoms::noframes)) {
+                                 nsGkAtoms::noframes);
+  if (IsElementPreformatted(aNode) || disableEntityEncoding) {
     PreLevel()++;
+    if (disableEntityEncoding)
+      ++mDisableEntityEncoding;
   }
 }
 
 void
 nsXHTMLContentSerializer::MaybeLeaveFromPreContent(nsIContent* aNode)
 {
   if (!ShouldMaintainPreLevel() ||
       !aNode->IsHTMLElement()) {
     return;
   }
 
-  if (IsElementPreformatted(aNode) ||
+  PRBool disableEntityEncoding =
       aNode->IsAnyOfHTMLElements(nsGkAtoms::script,
                                  nsGkAtoms::style,
                                  nsGkAtoms::noscript,
-                                 nsGkAtoms::noframes)) {
+                                 nsGkAtoms::noframes);
+  if (IsElementPreformatted(aNode) || disableEntityEncoding) {
     --PreLevel();
+    if (disableEntityEncoding)
+      --mDisableEntityEncoding;
   }
 }
 
 bool
 nsXHTMLContentSerializer::IsElementPreformatted(nsIContent* aNode)
 {
   MOZ_ASSERT(ShouldMaintainPreLevel(), "We should not be calling this needlessly");
 
diff --git a/dom/base/nsXMLContentSerializer.cpp b/dom/base/nsXMLContentSerializer.cpp
--- a/dom/base/nsXMLContentSerializer.cpp
+++ b/dom/base/nsXMLContentSerializer.cpp
@@ -620,17 +620,36 @@ nsXMLContentSerializer::SerializeAttr(co
                                       bool aDoEscapeEntities)
 {
   nsAutoString attrString_;
   // For innerHTML we can do faster appending without
   // temporary strings.
   bool rawAppend = mDoRaw && aDoEscapeEntities;
   nsAString& attrString = (rawAppend) ? aStr : attrString_;
 
-  NS_ENSURE_TRUE(attrString.Append(char16_t(' '), mozilla::fallible), false);
+  //NS_ENSURE_TRUE(attrString.Append(char16_t(' '), mozilla::fallible), false);
+  if (mColPos + 1 >= mMaxColumn && !mDoRaw) {
+    if (PreLevel() > 0) {
+      AppendToStringConvertLF(mLineBreak, aStr);
+    }
+    else if (mDoFormat) {
+      AppendToStringFormatedWrapped(mLineBreak, aStr);
+      AppendIndentation(aStr);
+    }
+    else if (mDoWrap) {
+      AppendToStringWrapped(mLineBreak, aStr);
+      AppendIndentation(aStr);
+    }
+    else {
+      AppendToStringConvertLF(mLineBreak, aStr);
+    }
+  }
+  else
+    attrString.Append(char16_t(' '));
+
   if (!aPrefix.IsEmpty()) {
     NS_ENSURE_TRUE(attrString.Append(aPrefix, mozilla::fallible), false);
     NS_ENSURE_TRUE(attrString.Append(char16_t(':'), mozilla::fallible), false);
   }
   NS_ENSURE_TRUE(attrString.Append(aName, mozilla::fallible), false);
 
   if (aDoEscapeEntities) {
     // if problem characters are turned into character entity references
@@ -689,29 +708,32 @@ nsXMLContentSerializer::SerializeAttr(co
                                            NS_LITERAL_STRING("&amp;"), mozilla::fallible), false);
     if (bIncludesDouble && bIncludesSingle) {
       NS_ENSURE_TRUE(sValue.ReplaceSubstring(NS_LITERAL_STRING("\""),
                                              NS_LITERAL_STRING("&quot;"), mozilla::fallible), false);
     }
     NS_ENSURE_TRUE(attrString.Append(sValue, mozilla::fallible), false);
     NS_ENSURE_TRUE(attrString.Append(cDelimiter, mozilla::fallible), false);
   }
+  AppendToStringConvertLF(attrString, aStr);
+  /* XXX
   if (mDoRaw || PreLevel() > 0) {
     NS_ENSURE_TRUE(AppendToStringConvertLF(attrString, aStr), false);
   }
   else if (mDoFormat) {
     NS_ENSURE_TRUE(AppendToStringFormatedWrapped(attrString, aStr), false);
   }
   else if (mDoWrap) {
     NS_ENSURE_TRUE(AppendToStringWrapped(attrString, aStr), false);
   }
   else {
     NS_ENSURE_TRUE(AppendToStringConvertLF(attrString, aStr), false);
   }
 
+  */
   return true;
 }
 
 uint32_t
 nsXMLContentSerializer::ScanNamespaceDeclarations(nsIContent* aContent,
                                                   nsIContent *aOriginalElement,
                                                   const nsAString& aTagNamespaceURI)
 {
@@ -901,77 +923,83 @@ nsXMLContentSerializer::AppendElementSta
 
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoString tagPrefix, tagLocalName, tagNamespaceURI;
   aElement->NodeInfo()->GetPrefix(tagPrefix);
   aElement->NodeInfo()->GetName(tagLocalName);
   aElement->NodeInfo()->GetNamespaceURI(tagNamespaceURI);
 
-  uint32_t skipAttr = ScanNamespaceDeclarations(content,
-                          aOriginalElement, tagNamespaceURI);
-
-  nsIAtom *name = content->NodeInfo()->NameAtom();
-  bool lineBreakBeforeOpen = LineBreakBeforeOpen(content->GetNameSpaceID(), name);
+  bool hideTag = tagNamespaceURI.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon");
+  if (!hideTag) {
+    uint32_t skipAttr = ScanNamespaceDeclarations(content,
+                            aOriginalElement, tagNamespaceURI);
+    nsIAtom *name = content->NodeInfo()->NameAtom();
+    bool lineBreakBeforeOpen = LineBreakBeforeOpen(content->GetNameSpaceID(), name);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    if (mColPos && lineBreakBeforeOpen) {
-      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    else {
-      NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    if (!mColPos) {
-      NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);
+    if (((mDoFormat || forceFormat) && !PreLevel()) || mDoRaw) {
+      if (mColPos && lineBreakBeforeOpen) {
+        AppendNewLineToString(aStr);
+      }
+      else {
+        MaybeAddNewlineForRootNode(aStr);
+      }
+      if (!mColPos) {
+        AppendIndentation(aStr);
+      }
+      else if (mAddSpace) {
+        AppendToString(char16_t(' '), aStr);
+        mAddSpace = false;
+      }
     }
     else if (mAddSpace) {
       NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
       mAddSpace = false;
     }
-  }
-  else if (mAddSpace) {
-    NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
-    mAddSpace = false;
-  }
-  else {
-    NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-
-  // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
-  // called
-  mAddNewlineForRootNode = false;
-
-  bool addNSAttr;
-  addNSAttr = ConfirmPrefix(tagPrefix, tagNamespaceURI, aOriginalElement,
-                            false);
+    else {
+      MaybeAddNewlineForRootNode(aStr);
+    }
 
-  // Serialize the qualified name of the element
-  NS_ENSURE_TRUE(AppendToString(kLessThan, aStr), NS_ERROR_OUT_OF_MEMORY);
-  if (!tagPrefix.IsEmpty()) {
-    NS_ENSURE_TRUE(AppendToString(tagPrefix, aStr), NS_ERROR_OUT_OF_MEMORY);
-    NS_ENSURE_TRUE(AppendToString(NS_LITERAL_STRING(":"), aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  NS_ENSURE_TRUE(AppendToString(tagLocalName, aStr), NS_ERROR_OUT_OF_MEMORY);
-
-  MaybeEnterInPreContent(content);
+    // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
+    // called
+    mAddNewlineForRootNode = false;
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    NS_ENSURE_TRUE(IncrIndentation(name), NS_ERROR_OUT_OF_MEMORY);
-  }
+    bool addNSAttr;
+    addNSAttr = ConfirmPrefix(tagPrefix, tagNamespaceURI, aOriginalElement,
+                              false);
 
-  NS_ENSURE_TRUE(SerializeAttributes(content, aOriginalElement, tagPrefix, tagNamespaceURI,
-                                     name, aStr, skipAttr, addNSAttr),
-                 NS_ERROR_OUT_OF_MEMORY);
+    if (!mNameSpaceStack.Length()
+        && tagNamespaceURI.EqualsLiteral("http://www.w3.org/1999/xhtml")
+        && !tagLocalName.EqualsLiteral("html"))
+      addNSAttr = false;
 
-  NS_ENSURE_TRUE(AppendEndOfElementStart(aElement, aOriginalElement, aStr),
-                 NS_ERROR_OUT_OF_MEMORY);
+    // Serialize the qualified name of the element
+    AppendToString(kLessThan, aStr);
+    if (!tagPrefix.IsEmpty()) {
+      AppendToString(tagPrefix, aStr);
+      AppendToString(NS_LITERAL_STRING(":"), aStr);
+    }
+    AppendToString(tagLocalName, aStr);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()
-    && LineBreakAfterOpen(content->GetNameSpaceID(), name)) {
-    NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+    MaybeEnterInPreContent(content);
+
+    if ((mDoFormat || forceFormat) && !PreLevel() && !mDoRaw) {
+      IncrIndentation(name);
+    }
+
+    SerializeAttributes(content, aOriginalElement, tagPrefix, tagNamespaceURI,
+                        name, aStr, skipAttr, addNSAttr);
+
+    AppendEndOfElementStart(aElement, aOriginalElement,
+                            aStr);
+
+    if ((mDoFormat || forceFormat) && !PreLevel()
+      && !mDoRaw && LineBreakAfterOpen(content->GetNameSpaceID(), name)) {
+      AppendNewLineToString(aStr);
+    }
   }
 
   NS_ENSURE_TRUE(AfterElementStart(content, aOriginalElement, aStr), NS_ERROR_OUT_OF_MEMORY);
 
   return NS_OK;
 }
 
 // aElement is the actual element we're outputting.  aOriginalElement is the one
@@ -1029,85 +1057,82 @@ nsXMLContentSerializer::AppendEndOfEleme
 NS_IMETHODIMP
 nsXMLContentSerializer::AppendElementEnd(Element* aElement,
                                          nsAString& aStr)
 {
   NS_ENSURE_ARG(aElement);
 
   nsIContent* content = aElement;
 
-  bool forceFormat = false, outputElementEnd;
-  outputElementEnd = CheckElementEnd(aElement, forceFormat, aStr);
-
-  nsIAtom *name = content->NodeInfo()->NameAtom();
-
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    DecrIndentation(name);
-  }
-
-  if (!outputElementEnd) {
-    // Keep this in sync with the cleanup at the end of this method.
-    PopNameSpaceDeclsFor(aElement);
-    MaybeLeaveFromPreContent(content);
-    MaybeFlagNewlineForRootNode(aElement);
-    AfterElementEnd(content, aStr);
-    return NS_OK;
-  }
-
   nsAutoString tagPrefix, tagLocalName, tagNamespaceURI;
-
   aElement->NodeInfo()->GetPrefix(tagPrefix);
   aElement->NodeInfo()->GetName(tagLocalName);
   aElement->NodeInfo()->GetNamespaceURI(tagNamespaceURI);
 
-#ifdef DEBUG
-  bool debugNeedToPushNamespace =
-#endif
-  ConfirmPrefix(tagPrefix, tagNamespaceURI, aElement, false);
-  NS_ASSERTION(!debugNeedToPushNamespace, "Can't push namespaces in closing tag!");
+  bool hideTag = tagNamespaceURI.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon");
+  if (!hideTag) {
+    bool forceFormat = false, outputElementEnd;
+    outputElementEnd = CheckElementEnd(aElement, forceFormat, aStr);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-
-    bool lineBreakBeforeClose = LineBreakBeforeClose(content->GetNameSpaceID(), name);
+    nsIAtom *name = content->NodeInfo()->NameAtom();
 
-    if (mColPos && lineBreakBeforeClose) {
-      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+    if ((mDoFormat || forceFormat) && !PreLevel() && !mDoRaw) {
+      DecrIndentation(name);
     }
-    if (!mColPos) {
-      NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);
+
+    if (!outputElementEnd) {
+      PopNameSpaceDeclsFor(aElement);
+      MaybeFlagNewlineForRootNode(aElement);
+      return NS_OK;
+    }
+
+#ifdef DEBUG
+    bool debugNeedToPushNamespace =
+#endif
+    ConfirmPrefix(tagPrefix, tagNamespaceURI, aElement, false);
+    NS_ASSERTION(!debugNeedToPushNamespace, "Can't push namespaces in closing tag!");
+
+    if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
+
+      bool lineBreakBeforeClose = LineBreakBeforeClose(content->GetNameSpaceID(), name);
+
+      if (mColPos && lineBreakBeforeClose) {
+        AppendNewLineToString(aStr);
+      }
+      if (!mColPos) {
+        AppendIndentation(aStr);
+      }
+      else if (mAddSpace) {
+        AppendToString(char16_t(' '), aStr);
+        mAddSpace = false;
+      }
     }
     else if (mAddSpace) {
       NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
       mAddSpace = false;
     }
-  }
-  else if (mAddSpace) {
-    NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
-    mAddSpace = false;
-  }
+    AppendToString(kEndTag, aStr);
+    if (!tagPrefix.IsEmpty()) {
+      AppendToString(tagPrefix, aStr);
+      AppendToString(NS_LITERAL_STRING(":"), aStr);
+    }
+    AppendToString(tagLocalName, aStr);
+    AppendToString(kGreaterThan, aStr);
 
-  NS_ENSURE_TRUE(AppendToString(kEndTag, aStr), NS_ERROR_OUT_OF_MEMORY);
-  if (!tagPrefix.IsEmpty()) {
-    NS_ENSURE_TRUE(AppendToString(tagPrefix, aStr), NS_ERROR_OUT_OF_MEMORY);
-    NS_ENSURE_TRUE(AppendToString(NS_LITERAL_STRING(":"), aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  NS_ENSURE_TRUE(AppendToString(tagLocalName, aStr), NS_ERROR_OUT_OF_MEMORY);
-  NS_ENSURE_TRUE(AppendToString(kGreaterThan, aStr), NS_ERROR_OUT_OF_MEMORY);
+    PopNameSpaceDeclsFor(aElement);
 
-  // Keep what follows in sync with the cleanup in the !outputElementEnd case.
-  PopNameSpaceDeclsFor(aElement);
-
-  MaybeLeaveFromPreContent(content);
+    MaybeLeaveFromPreContent(content);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()
-      && LineBreakAfterClose(content->GetNameSpaceID(), name)) {
-    NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  else {
-    MaybeFlagNewlineForRootNode(aElement);
+    if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()
+        && LineBreakAfterClose(content->GetNameSpaceID(), name)) {
+      AppendNewLineToString(aStr);
+    }
+    else {
+      MaybeFlagNewlineForRootNode(aElement);
+    }
   }
 
   AfterElementEnd(content, aStr);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -1187,16 +1212,33 @@ nsXMLContentSerializer::AppendToString(c
 bool
 nsXMLContentSerializer::AppendToString(const nsAString& aStr,
                                        nsAString& aOutputStr)
 {
   if (mBodyOnly && !mInBody) {
     return true;
   }
   mColPos += aStr.Length();
+  nsASingleFragmentString::const_char_iterator pos, end, sequenceStart;
+
+  aStr.BeginReading(pos);
+  aStr.EndReading(end);
+  bool foundCR = PR_FALSE;
+  bool foundOtherThanCROrBlank = PR_FALSE;
+  while (pos < end) {
+    if (*pos == '\n' || *pos == '\r')
+      foundCR = PR_TRUE;
+    else if (*pos != ' ' && *pos != '\t')
+      foundOtherThanCROrBlank = PR_TRUE;
+    pos++;
+  }
+
+  if (foundCR && !foundOtherThanCROrBlank) {
+    mMayIgnoreLineBreakSequence = PR_TRUE;
+  }
   return aOutputStr.Append(aStr, mozilla::fallible);
 }
 
 
 static const uint16_t kGTVal = 62;
 
 #define _ 0
 
@@ -1318,16 +1360,20 @@ nsXMLContentSerializer::MaybeLeaveFromPr
     if (space.EqualsLiteral("preserve"))
       --PreLevel();
   }
 }
 
 bool
 nsXMLContentSerializer::AppendNewLineToString(nsAString& aStr)
 {
+  if (!PreLevel() && mMayIgnoreLineBreakSequence) {
+    mMayIgnoreLineBreakSequence = PR_FALSE;
+    return true;
+  }
   bool result = AppendToString(mLineBreak, aStr);
   mMayIgnoreLineBreakSequence = true;
   mColPos = 0;
   mAddSpace = false;
   mIsIndentationAddedOnCurrentLine = false;
   return result;
 }
 
@@ -1626,19 +1672,39 @@ nsXMLContentSerializer::AppendWrapped_No
           if (!mColPos && mDoFormat) {
             NS_ENSURE_TRUE(AppendIndentation(aOutputStr), false);
           }
           else if (mAddSpace) {
             bool result = aOutputStr.Append(char16_t(' '), mozilla::fallible);
             mAddSpace = false;
             NS_ENSURE_TRUE(result, false);
           }
+          bool CRDone = PR_FALSE;
+          if (wrapPosition) {
+            CRDone = (*(aSequenceStart + wrapPosition - 1) == '\n');
+          }
           NS_ENSURE_TRUE(aOutputStr.Append(aSequenceStart, wrapPosition, mozilla::fallible), false);
 
-          NS_ENSURE_TRUE(AppendNewLineToString(aOutputStr), false);
+          if (CRDone) {
+            // we found a wrapping spot but there is a newline
+            // char right before that point... So we don't need another CR.
+            mMayIgnoreLineBreakSequence = PR_TRUE;
+            mColPos = 0;
+            mAddSpace = PR_FALSE;
+            mIsIndentationAddedOnCurrentLine = PR_FALSE;
+          }
+          else {
+            AppendNewLineToString(aOutputStr);
+          }
+
+          if (mDoFormat) {
+            AppendIndentation(aOutputStr);
+          }
+
+          mMayIgnoreLineBreakSequence = PR_TRUE;
           aPos = aSequenceStart + wrapPosition;
           aMayIgnoreStartOfLineWhitespaceSequence = true;
         }
         else {
           // try some simple fallback logic
           // go forward up to the next whitespace position,
           // in the worst case this will be all the rest of the data
 
diff --git a/dom/html/HTMLInputElement.cpp b/dom/html/HTMLInputElement.cpp
--- a/dom/html/HTMLInputElement.cpp
+++ b/dom/html/HTMLInputElement.cpp
@@ -121,16 +121,18 @@
 #include "nsIMIMEInfo.h"
 #include "nsFrameSelection.h"
 
 #include "nsIConsoleService.h"
 
 // input type=date
 #include "js/Date.h"
 
+#include "nsCSSParser.h"
+
 NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER(Input)
 
 // XXX align=left, hspace, vspace, border? other nav4 attrs
 
 static NS_DEFINE_CID(kXULControllersCID,  NS_XULCONTROLLERS_CID);
 
 // This must come outside of any namespace, or else it won't overload with the
 // double based version in nsMathUtils.h
@@ -901,19 +903,23 @@ HTMLInputElement::InitColorPicker()
   nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
                                      "ColorPicker", title);
 
   nsCOMPtr<nsIColorPicker> colorPicker = do_CreateInstance("@mozilla.org/colorpicker;1");
   if (!colorPicker) {
     return NS_ERROR_FAILURE;
   }
 
+  nsAutoString showtransparency;
+  GetAttr(kNameSpaceID_None, nsGkAtoms::showtransparency, showtransparency);
+  PRBool showAlpha = showtransparency.EqualsLiteral("true");
+
   nsAutoString initialValue;
   GetNonFileValueInternal(initialValue);
-  nsresult rv = colorPicker->Init(win, title, initialValue);
+  nsresult rv = colorPicker->Init(win, title, initialValue, showAlpha);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIColorPickerShownCallback> callback =
     new nsColorPickerShownCallback(this, colorPicker);
 
   rv = colorPicker->Open(callback);
   if (NS_SUCCEEDED(rv)) {
     mPickerRunning = true;
@@ -5362,27 +5368,27 @@ HTMLInputElement::SanitizeValue(nsAStrin
         }
       }
       break;
   }
 }
 
 bool HTMLInputElement::IsValidSimpleColor(const nsAString& aValue) const
 {
-  if (aValue.Length() != 7 || aValue.First() != '#') {
+  nsCSSValue value;
+  nsCSSParser parser;
+  if (!parser.ParseColorString(aValue, nullptr, 0, value)) {
     return false;
   }
 
-  for (int i = 1; i < 7; ++i) {
-    if (!nsCRT::IsAsciiDigit(aValue[i]) &&
-        !(aValue[i] >= 'a' && aValue[i] <= 'f') &&
-        !(aValue[i] >= 'A' && aValue[i] <= 'F')) {
-      return false;
-    }
-  }
+  nscolor color;
+  if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
+    return false;
+  }
+
   return true;
 }
 
 bool
 HTMLInputElement::IsLeapYear(uint32_t aYear) const
 {
   if ((aYear % 4 == 0 && aYear % 100 != 0) || ( aYear % 400 == 0)) {
     return true;
diff --git a/dom/html/HTMLInputElement.h b/dom/html/HTMLInputElement.h
--- a/dom/html/HTMLInputElement.h
+++ b/dom/html/HTMLInputElement.h
@@ -886,26 +886,28 @@ protected:
     VALUE_MODE_DEFAULT_ON,
     // On getting, returns "C:\fakepath\" followed by the file name of the
     // first file of the selected files if any.
     // On setting the empty string, empties the selected files list, otherwise
     // throw the INVALID_STATE_ERR exception.
     VALUE_MODE_FILENAME
   };
 
+public:
   /**
    * This helper method returns true if aValue is a valid email address.
    * This is following the HTML5 specification:
    * http://dev.w3.org/html5/spec/forms.html#valid-e-mail-address
    *
    * @param aValue  the email address to check.
    * @result        whether the given string is a valid email address.
    */
   static bool IsValidEmailAddress(const nsAString& aValue);
 
+protected:
   /**
    * This helper method returns true if aValue is a valid email address list.
    * Email address list is a list of email address separated by comas (,) which
    * can be surrounded by space charecters.
    * This is following the HTML5 specification:
    * http://dev.w3.org/html5/spec/forms.html#valid-e-mail-address-list
    *
    * @param aValue  the email address list to check.
diff --git a/dom/interfaces/core/nsIDOMDocument.idl b/dom/interfaces/core/nsIDOMDocument.idl
--- a/dom/interfaces/core/nsIDOMDocument.idl
+++ b/dom/interfaces/core/nsIDOMDocument.idl
@@ -28,17 +28,17 @@ interface nsIDOMLocation;
  * cannot exist outside the context of a Document, the nsIDOMDocument 
  * interface also contains the factory methods needed to create these 
  * objects.
  *
  * For more information on this interface please see 
  * http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html
  */
 
-[uuid(b15fa0f4-97c1-4388-af62-2ceff7a89bdf)]
+[uuid(D792B34B-8419-4729-9E09-43C61DC2FACE)]
 interface nsIDOMDocument : nsIDOMNode
 {
   readonly attribute nsIDOMDocumentType         doctype;
   readonly attribute nsIDOMDOMImplementation    implementation;
   readonly attribute nsIDOMElement              documentElement;
   nsIDOMElement                 createElement([Null(Stringify)] in DOMString tagName)
                                   raises(DOMException);
   nsIDOMDocumentFragment        createDocumentFragment();
@@ -75,16 +75,19 @@ interface nsIDOMDocument : nsIDOMNode
   // Introduced in DOM Level 3:
   readonly attribute DOMString       documentURI;
   // Alias introduced for all documents in recent DOM standards
   readonly attribute DOMString       URL;
   // Introduced in DOM Level 3:
   nsIDOMNode         adoptNode(in nsIDOMNode source)
                                         raises(DOMException);
 
+  // BLUEGRIFFON
+  readonly attribute boolean hasXMLDeclaration;
+
   /**
    * Create a range
    *
    * @see http://html5.org/specs/dom-range.html#dom-document-createrange
    */
   nsIDOMRange              createRange();
 
   [optional_argc] nsIDOMNodeIterator createNodeIterator(in nsIDOMNode root,
diff --git a/dom/ipc/ColorPickerParent.cpp b/dom/ipc/ColorPickerParent.cpp
--- a/dom/ipc/ColorPickerParent.cpp
+++ b/dom/ipc/ColorPickerParent.cpp
@@ -56,17 +56,17 @@ ColorPickerParent::CreateColorPicker()
     return false;
   }
 
   nsCOMPtr<nsPIDOMWindowOuter> window = ownerElement->OwnerDoc()->GetWindow();
   if (!window) {
     return false;
   }
 
-  return NS_SUCCEEDED(mPicker->Init(window, mTitle, mInitialColor));
+  return NS_SUCCEEDED(mPicker->Init(window, mTitle, mInitialColor, mShowsAlpha));
 }
 
 mozilla::ipc::IPCResult
 ColorPickerParent::RecvOpen()
 {
   if (!CreateColorPicker()) {
     Unused << Send__delete__(this, mInitialColor);
     return IPC_OK();
diff --git a/dom/ipc/ColorPickerParent.h b/dom/ipc/ColorPickerParent.h
--- a/dom/ipc/ColorPickerParent.h
+++ b/dom/ipc/ColorPickerParent.h
@@ -12,19 +12,21 @@
 
 namespace mozilla {
 namespace dom {
 
 class ColorPickerParent : public PColorPickerParent
 {
  public:
   ColorPickerParent(const nsString& aTitle,
-                    const nsString& aInitialColor)
+                    const nsString& aInitialColor,
+                    bool aShowsAlpha)
   : mTitle(aTitle)
   , mInitialColor(aInitialColor)
+  , mShowsAlpha(aShowsAlpha)
   {}
 
   virtual mozilla::ipc::IPCResult RecvOpen() override;
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
 
   class ColorPickerShownCallback final
     : public nsIColorPickerShownCallback
   {
@@ -48,14 +50,15 @@ class ColorPickerParent : public PColorP
 
   bool CreateColorPicker();
 
   RefPtr<ColorPickerShownCallback> mCallback;
   nsCOMPtr<nsIColorPicker> mPicker;
 
   nsString mTitle;
   nsString mInitialColor;
+  bool     mShowsAlpha;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ColorPickerParent_h
diff --git a/dom/ipc/PBrowser.ipdl b/dom/ipc/PBrowser.ipdl
--- a/dom/ipc/PBrowser.ipdl
+++ b/dom/ipc/PBrowser.ipdl
@@ -436,17 +436,17 @@ parent:
      */
     async ShowTooltip(uint32_t x, uint32_t y, nsString tooltip, nsString direction);
     async HideTooltip();
 
     /**
      * Create an asynchronous color picker on the parent side,
      * but don't open it yet.
      */
-    async PColorPicker(nsString title, nsString initialColor);
+    async PColorPicker(nsString title, nsString initialColor, bool showsAlpha);
 
     /**
      * Create an asynchronous date picker on the parent side,
      * but don't open it yet.
      */
     async PDatePicker(nsString title, nsString initialDate);
 
     async PFilePicker(nsString aTitle, int16_t aMode);
diff --git a/dom/ipc/TabChild.cpp b/dom/ipc/TabChild.cpp
--- a/dom/ipc/TabChild.cpp
+++ b/dom/ipc/TabChild.cpp
@@ -2117,17 +2117,17 @@ TabChild::RecvPDocumentRendererConstruct
 
     if (!PDocumentRendererChild::Send__delete__(actor, renderSize, data)) {
       return IPC_FAIL_NO_REASON(this);
     }
     return IPC_OK();
 }
 
 PColorPickerChild*
-TabChild::AllocPColorPickerChild(const nsString&, const nsString&)
+TabChild::AllocPColorPickerChild(const nsString&, const nsString&, const bool &)
 {
   MOZ_CRASH("unused");
   return nullptr;
 }
 
 bool
 TabChild::DeallocPColorPickerChild(PColorPickerChild* aColorPicker)
 {
diff --git a/dom/ipc/TabChild.h b/dom/ipc/TabChild.h
--- a/dom/ipc/TabChild.h
+++ b/dom/ipc/TabChild.h
@@ -463,17 +463,18 @@ public:
                                    const nsString& aBgcolor,
                                    const uint32_t& aRenderFlags,
                                    const bool& aFlushLayout,
                                    const nsIntSize& aRenderSize) override;
 
 
   virtual PColorPickerChild*
   AllocPColorPickerChild(const nsString& aTitle,
-                         const nsString& aInitialColor) override;
+                         const nsString& aInitialColor,
+                         const bool &showsAlpha) override;
 
   virtual bool DeallocPColorPickerChild(PColorPickerChild* aActor) override;
 
     virtual PDatePickerChild*
     AllocPDatePickerChild(const nsString& title, const nsString& initialDate) override;
     virtual bool DeallocPDatePickerChild(PDatePickerChild* actor) override;
 
   virtual PFilePickerChild*
diff --git a/dom/ipc/TabParent.cpp b/dom/ipc/TabParent.cpp
--- a/dom/ipc/TabParent.cpp
+++ b/dom/ipc/TabParent.cpp
@@ -2451,19 +2451,20 @@ TabParent::GetAuthPrompt(uint32_t aPromp
   }
 
   *aResult = prompt.forget().take();
   return NS_OK;
 }
 
 PColorPickerParent*
 TabParent::AllocPColorPickerParent(const nsString& aTitle,
-                                   const nsString& aInitialColor)
+                                   const nsString& aInitialColor,
+                                   const bool &aShowsAlpha)
 {
-  return new ColorPickerParent(aTitle, aInitialColor);
+  return new ColorPickerParent(aTitle, aInitialColor, aShowsAlpha);
 }
 
 bool
 TabParent::DeallocPColorPickerParent(PColorPickerParent* actor)
 {
   delete actor;
   return true;
 }
diff --git a/dom/ipc/TabParent.h b/dom/ipc/TabParent.h
--- a/dom/ipc/TabParent.h
+++ b/dom/ipc/TabParent.h
@@ -336,17 +336,18 @@ public:
   virtual mozilla::ipc::IPCResult
   RecvDispatchMouseEvent(const mozilla::WidgetMouseEvent& aEvent) override;
 
   virtual mozilla::ipc::IPCResult
   RecvDispatchKeyboardEvent(const mozilla::WidgetKeyboardEvent& aEvent) override;
 
   virtual PColorPickerParent*
   AllocPColorPickerParent(const nsString& aTitle,
-                          const nsString& aInitialColor) override;
+                          const nsString& aInitialColor,
+                          const bool &aShowsAlpha) override;
 
   virtual bool
   DeallocPColorPickerParent(PColorPickerParent* aColorPicker) override;
 
   virtual PDatePickerParent*
   AllocPDatePickerParent(const nsString& aTitle, const nsString& aInitialDate) override;
   virtual bool DeallocPDatePickerParent(PDatePickerParent* aDatePicker) override;
 
diff --git a/dom/xbl/nsXBLContentSink.cpp b/dom/xbl/nsXBLContentSink.cpp
--- a/dom/xbl/nsXBLContentSink.cpp
+++ b/dom/xbl/nsXBLContentSink.cpp
@@ -164,16 +164,18 @@ nsXBLContentSink::FlushText(bool aReleas
 
   return nsXMLContentSink::FlushText(aReleaseTextNode);
 }
 
 NS_IMETHODIMP
 nsXBLContentSink::ReportError(const char16_t* aErrorText, 
                               const char16_t* aSourceText,
                               nsIScriptError *aError,
+                              uint32_t aLineNumber,
+                              uint32_t aColNumber,
                               bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 
   // XXX FIXME This function overrides and calls on
   // nsXMLContentSink::ReportError, and probably should die.  See bug 347826.
 
   // XXX We should make sure the binding has no effect, but that it also
@@ -189,16 +191,18 @@ nsXBLContentSink::ReportError(const char
           NS_LossyConvertUTF16toASCII(aSourceText).get());
 #endif
 
   // Most of what this does won't be too useful, but whatever...
   // nsXMLContentSink::ReportError will handle the console logging.
   return nsXMLContentSink::ReportError(aErrorText, 
                                        aSourceText, 
                                        aError,
+                                       aLineNumber,
+                                       aColNumber,
                                        _retval);
 }
 
 nsresult
 nsXBLContentSink::ReportUnexpectedElement(nsIAtom* aElementName,
                                           uint32_t aLineNumber)
 {
   // XXX we should really somehow stop the parse and drop the binding
diff --git a/dom/xbl/nsXBLContentSink.h b/dom/xbl/nsXBLContentSink.h
--- a/dom/xbl/nsXBLContentSink.h
+++ b/dom/xbl/nsXBLContentSink.h
@@ -114,16 +114,18 @@ protected:
 
   // nsXMLContentSink overrides
   nsresult FlushText(bool aReleaseTextNode = true) override;
 
   // nsIExpatSink overrides
   NS_IMETHOD ReportError(const char16_t* aErrorText,
                          const char16_t* aSourceText,
                          nsIScriptError *aError,
+                         uint32_t aLineNumber,
+                         uint32_t aColNumber,
                          bool *_retval) override;
 
 protected:
   nsresult ReportUnexpectedElement(nsIAtom* aElementName, uint32_t aLineNumber);
 
   void AddMember(nsXBLProtoImplMember* aMember);
   void AddField(nsXBLProtoImplField* aField);
   
diff --git a/dom/xml/nsXMLContentSink.cpp b/dom/xml/nsXMLContentSink.cpp
--- a/dom/xml/nsXMLContentSink.cpp
+++ b/dom/xml/nsXMLContentSink.cpp
@@ -1300,16 +1300,18 @@ nsXMLContentSink::HandleXMLDeclaration(c
 
   return DidProcessATokenImpl();
 }
 
 NS_IMETHODIMP
 nsXMLContentSink::ReportError(const char16_t* aErrorText,
                               const char16_t* aSourceText,
                               nsIScriptError *aError,
+                              uint32_t aLineNumber,
+                              uint32_t aColNumber,
                               bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
   nsresult rv = NS_OK;
 
   // The expat driver should report the error.  We're just cleaning up the mess.
   *_retval = true;
 
@@ -1356,26 +1358,34 @@ nsXMLContentSink::ReportError(const char
     return NS_OK;
   }
 
   // prepare to set <parsererror> as the document root
   rv = HandleProcessingInstruction(u"xml-stylesheet",
                                    u"href=\"chrome://global/locale/intl.css\" type=\"text/css\"");
   NS_ENSURE_SUCCESS(rv, rv);
 
-  const char16_t* noAtts[] = { 0, 0 };
+  nsAutoString lineString, colString;
+  lineString.AppendInt(aLineNumber);
+  colString.AppendInt(aColNumber);
+  const char16_t* noAtts[] = { NS_LITERAL_STRING("line").get(),
+                                lineString.get(),
+                                NS_LITERAL_STRING("col").get(),
+                                colString.get(),
+                                0,
+                                0 };
 
   NS_NAMED_LITERAL_STRING(errorNs,
                           "http://www.mozilla.org/newlayout/xml/parsererror.xml");
 
   nsAutoString parsererror(errorNs);
   parsererror.Append((char16_t)0xFFFF);
   parsererror.AppendLiteral("parsererror");
 
-  rv = HandleStartElement(parsererror.get(), noAtts, 0, (uint32_t)-1,
+  rv = HandleStartElement(parsererror.get(), noAtts, 2, (uint32_t)-1,
                           false);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = HandleCharacterData(aErrorText, NS_strlen(aErrorText), false);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoString sourcetext(errorNs);
   sourcetext.Append((char16_t)0xFFFF);
diff --git a/dom/xml/nsXMLFragmentContentSink.cpp b/dom/xml/nsXMLFragmentContentSink.cpp
--- a/dom/xml/nsXMLFragmentContentSink.cpp
+++ b/dom/xml/nsXMLFragmentContentSink.cpp
@@ -51,16 +51,18 @@ public:
   NS_IMETHOD HandleProcessingInstruction(const char16_t* aTarget,
                                          const char16_t* aData) override;
   NS_IMETHOD HandleXMLDeclaration(const char16_t* aVersion,
                                   const char16_t* aEncoding,
                                   int32_t aStandalone) override;
   NS_IMETHOD ReportError(const char16_t* aErrorText,
                          const char16_t* aSourceText,
                          nsIScriptError* aError,
+                         uint32_t aLineNumber,
+                         uint32_t aColNumber,
                          bool* aRetval) override;
 
   // nsIContentSink
   NS_IMETHOD WillBuildModel(nsDTDMode aDTDMode) override;
   NS_IMETHOD DidBuildModel(bool aTerminated) override;
   NS_IMETHOD SetDocumentCharset(nsACString& aCharset) override;
   virtual nsISupports* GetTarget() override;
   NS_IMETHOD DidProcessATokenImpl();
@@ -280,16 +282,18 @@ nsXMLFragmentContentSink::HandleXMLDecla
   NS_NOTREACHED("fragments shouldn't have XML declarations");
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsXMLFragmentContentSink::ReportError(const char16_t* aErrorText, 
                                       const char16_t* aSourceText,
                                       nsIScriptError *aError,
+                                      uint32_t aLineNumber,
+                                      uint32_t aColNumber,
                                       bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 
   // The expat driver should report the error.
   *_retval = true;
 
   mParseError = true;
diff --git a/dom/xslt/xslt/txMozillaStylesheetCompiler.cpp b/dom/xslt/xslt/txMozillaStylesheetCompiler.cpp
--- a/dom/xslt/xslt/txMozillaStylesheetCompiler.cpp
+++ b/dom/xslt/xslt/txMozillaStylesheetCompiler.cpp
@@ -200,16 +200,18 @@ txStylesheetSink::HandleXMLDeclaration(c
 {
     return NS_OK;
 }
 
 NS_IMETHODIMP
 txStylesheetSink::ReportError(const char16_t *aErrorText,
                               const char16_t *aSourceText,
                               nsIScriptError *aError,
+                              uint32_t aLineNumber,
+                              uint32_t aColNumber,
                               bool *_retval)
 {
     NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 
     // The expat driver should report the error.
     *_retval = true;
 
     mCompiler->cancel(NS_ERROR_FAILURE, aErrorText, aSourceText);
diff --git a/dom/xul/nsXULContentSink.cpp b/dom/xul/nsXULContentSink.cpp
--- a/dom/xul/nsXULContentSink.cpp
+++ b/dom/xul/nsXULContentSink.cpp
@@ -647,16 +647,18 @@ XULContentSinkImpl::HandleXMLDeclaration
   return NS_OK;
 }
 
 
 NS_IMETHODIMP
 XULContentSinkImpl::ReportError(const char16_t* aErrorText,
                                 const char16_t* aSourceText,
                                 nsIScriptError *aError,
+                                uint32_t aLineNumber,
+                                uint32_t aColNumber,
                                 bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 
   // The expat driver should report the error.
   *_retval = true;
 
   nsresult rv = NS_OK;
diff --git a/editor/composer/nsComposerCommands.cpp b/editor/composer/nsComposerCommands.cpp
--- a/editor/composer/nsComposerCommands.cpp
+++ b/editor/composer/nsComposerCommands.cpp
@@ -206,16 +206,23 @@ nsStyleUpdatingCommand::ToggleState(nsIE
 
   //create some params now...
   nsresult rv;
   nsCOMPtr<nsICommandParams> params =
       do_CreateInstance(NS_COMMAND_PARAMS_CONTRACTID,&rv);
   if (NS_FAILED(rv) || !params)
     return rv;
 
+  bool isCSS;
+  htmlEditor->GetIsCSSEnabled(&isCSS);
+  if (isCSS
+      && (mTagName == nsGkAtoms::b
+          || mTagName == nsGkAtoms::i
+          || mTagName == nsGkAtoms::u))
+    htmlEditor->SetIsCSSEnabled(false);
   // tags "href" and "name" are special cases in the core editor
   // they are used to remove named anchor/link and shouldn't be used for insertion
   bool doTagRemoval;
   if (mTagName == nsGkAtoms::href || mTagName == nsGkAtoms::name) {
     doTagRemoval = true;
   } else {
     // check current selection; set doTagRemoval if formatting should be removed
     rv = GetCurrentState(aEditor, params);
@@ -247,16 +254,17 @@ nsStyleUpdatingCommand::ToggleState(nsIE
       rv = RemoveTextProperty(htmlEditor, tagName);
     }
     if (NS_SUCCEEDED(rv))
       rv = SetTextProperty(htmlEditor, tagName);
 
     aEditor->EndTransaction();
   }
 
+  htmlEditor->SetIsCSSEnabled(isCSS);
   return rv;
 }
 
 nsListCommand::nsListCommand(nsIAtom* aTagName)
 : nsBaseStateUpdatingCommand(aTagName)
 {
 }
 
@@ -458,17 +466,25 @@ nsIndentCommand::IsCommandEnabled(const 
 
 NS_IMETHODIMP
 nsIndentCommand::DoCommand(const char *aCommandName, nsISupports *refCon)
 {
   nsCOMPtr<nsIHTMLEditor> editor = do_QueryInterface(refCon);
 
   nsresult rv = NS_OK;
   if (editor) {
+    bool isCssEnabled;
+    nsresult rv = editor->GetIsCSSEnabled(&isCssEnabled);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = editor->SetIsCSSEnabled(true);
+    NS_ENSURE_SUCCESS(rv, rv);
+
     rv = editor->Indent(NS_LITERAL_STRING("indent"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = editor->SetIsCSSEnabled(isCssEnabled);
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 nsIndentCommand::DoCommandParams(const char *aCommandName,
                                  nsICommandParams *aParams,
@@ -507,17 +523,27 @@ nsOutdentCommand::IsCommandEnabled(const
 }
 
 
 NS_IMETHODIMP
 nsOutdentCommand::DoCommand(const char *aCommandName, nsISupports *refCon)
 {
   nsCOMPtr<nsIHTMLEditor> htmlEditor = do_QueryInterface(refCon);
   if (htmlEditor)
-    return htmlEditor->Indent(NS_LITERAL_STRING("outdent"));
+  {
+    bool isCssEnabled;
+    nsresult rv = htmlEditor->GetIsCSSEnabled(&isCssEnabled);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = htmlEditor->SetIsCSSEnabled(true);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = htmlEditor->Indent(NS_LITERAL_STRING("outdent"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = htmlEditor->SetIsCSSEnabled(isCssEnabled);
+  }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsOutdentCommand::DoCommandParams(const char *aCommandName,
                                   nsICommandParams *aParams,
                                   nsISupports *refCon)
@@ -914,22 +940,31 @@ nsAlignCommand::nsAlignCommand()
 nsresult
 nsAlignCommand::GetCurrentState(nsIEditor *aEditor, nsICommandParams *aParams)
 {
   NS_ASSERTION(aEditor, "Need an editor here");
 
   nsCOMPtr<nsIHTMLEditor> htmlEditor = do_QueryInterface(aEditor);
   NS_ENSURE_TRUE(htmlEditor, NS_ERROR_FAILURE);
 
+  bool isCssEnabled;
+  nsresult rv = htmlEditor->GetIsCSSEnabled(&isCssEnabled);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = htmlEditor->SetIsCSSEnabled(true);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   nsIHTMLEditor::EAlignment firstAlign;
   bool outMixed;
-  nsresult rv = htmlEditor->GetAlignment(&outMixed, &firstAlign);
+  rv = htmlEditor->GetAlignment(&outMixed, &firstAlign);
 
   NS_ENSURE_SUCCESS(rv, rv);
 
+  rv = htmlEditor->SetIsCSSEnabled(isCssEnabled);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   nsAutoString outStateString;
   switch (firstAlign) {
     default:
     case nsIHTMLEditor::eLeft:
       outStateString.AssignLiteral("left");
       break;
 
     case nsIHTMLEditor::eCenter:
@@ -954,17 +989,24 @@ nsAlignCommand::GetCurrentState(nsIEdito
 nsresult
 nsAlignCommand::SetState(nsIEditor *aEditor, nsString& newState)
 {
   NS_ASSERTION(aEditor, "Need an editor here");
 
   nsCOMPtr<nsIHTMLEditor> htmlEditor = do_QueryInterface(aEditor);
   NS_ENSURE_TRUE(htmlEditor, NS_ERROR_FAILURE);
 
-  return htmlEditor->Align(newState);
+  bool isCssEnabled;
+  nsresult rv = htmlEditor->GetIsCSSEnabled(&isCssEnabled);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = htmlEditor->SetIsCSSEnabled(true);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = htmlEditor->Align(newState);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return htmlEditor->SetIsCSSEnabled(isCssEnabled);
 }
 
 nsAbsolutePositioningCommand::nsAbsolutePositioningCommand()
 : nsBaseStateUpdatingCommand(nsGkAtoms::_empty)
 {
 }
 
 NS_IMETHODIMP
diff --git a/editor/libeditor/CSSEditUtils.cpp b/editor/libeditor/CSSEditUtils.cpp
--- a/editor/libeditor/CSSEditUtils.cpp
+++ b/editor/libeditor/CSSEditUtils.cpp
@@ -334,21 +334,22 @@ CSSEditUtils::IsCSSEditableProperty(nsIN
   nsINode* node = aNode;
   // we need an element node here
   if (node->NodeType() == nsIDOMNode::TEXT_NODE) {
     node = node->GetParentNode();
     NS_ENSURE_TRUE(node, false);
   }
 
   // html inline styles B I TT U STRIKE and COLOR/FACE on FONT
-  if (nsGkAtoms::b == aProperty ||
-      nsGkAtoms::i == aProperty ||
+  if (//nsGkAtoms::b == aProperty ||
+      //nsGkAtoms::i == aProperty ||
       nsGkAtoms::tt == aProperty ||
-      nsGkAtoms::u == aProperty ||
+      //nsGkAtoms::u == aProperty ||
       nsGkAtoms::strike == aProperty ||
+      nsGkAtoms::nobr == aProperty ||
       (nsGkAtoms::font == aProperty && aAttribute &&
        (aAttribute == nsGkAtoms::color || aAttribute == nsGkAtoms::face))) {
     return true;
   }
 
   // ALIGN attribute on elements supporting it
   if (aAttribute == nsGkAtoms::align &&
       node->IsAnyOfHTMLElements(nsGkAtoms::div,
@@ -831,16 +832,18 @@ CSSEditUtils::GenerateCSSDeclarationsFro
   if (nsGkAtoms::b == aHTMLProperty) {
     equivTable = boldEquivTable;
   } else if (nsGkAtoms::i == aHTMLProperty) {
     equivTable = italicEquivTable;
   } else if (nsGkAtoms::u == aHTMLProperty) {
     equivTable = underlineEquivTable;
   } else if (nsGkAtoms::strike == aHTMLProperty) {
     equivTable = strikeEquivTable;
+  } else if (nsGkAtoms::nobr == aHTMLProperty) {
+    equivTable = nowrapEquivTable;
   } else if (nsGkAtoms::tt == aHTMLProperty) {
     equivTable = ttEquivTable;
   } else if (aAttribute) {
     if (nsGkAtoms::font == aHTMLProperty && aAttribute == nsGkAtoms::color) {
       equivTable = fontColorEquivTable;
     } else if (nsGkAtoms::font == aHTMLProperty &&
                aAttribute == nsGkAtoms::face) {
       equivTable = fontFaceEquivTable;
diff --git a/editor/libeditor/EditorBase.cpp b/editor/libeditor/EditorBase.cpp
--- a/editor/libeditor/EditorBase.cpp
+++ b/editor/libeditor/EditorBase.cpp
@@ -99,16 +99,17 @@
 #include "nsStyleConsts.h"              // for NS_STYLE_DIRECTION_RTL, etc.
 #include "nsStyleContext.h"             // for nsStyleContext
 #include "nsStyleStruct.h"              // for nsStyleDisplay, nsStyleText, etc.
 #include "nsStyleStructFwd.h"           // for nsIFrame::StyleUIReset, etc.
 #include "nsTextNode.h"                 // for nsTextNode
 #include "nsThreadUtils.h"              // for nsRunnable
 #include "nsTransactionManager.h"       // for nsTransactionManager
 #include "prtime.h"                     // for PR_Now
+#include "nsIEditorMouseObserver.h"
 
 class nsIOutputStream;
 class nsIParserService;
 class nsITransferable;
 
 #ifdef DEBUG
 #include "nsIDOMHTMLDocument.h"         // for nsIDOMHTMLDocument
 #endif
@@ -167,16 +168,17 @@ NS_IMPL_CYCLE_COLLECTION_CLASS(EditorBas
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(EditorBase)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mRootElement)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mInlineSpellChecker)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mTxnMgr)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mIMETextNode)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mActionListeners)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mEditorObservers)
+ NS_IMPL_CYCLE_COLLECTION_UNLINK(mEditorMouseObservers)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mDocStateListeners)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mEventTarget)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mEventListener)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mSavedSel);
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mRangeUpdater);
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(EditorBase)
@@ -187,16 +189,17 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
    return NS_SUCCESS_INTERRUPTED_TRAVERSE;
  }
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mRootElement)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mInlineSpellChecker)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mTxnMgr)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mIMETextNode)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mActionListeners)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEditorObservers)
+ NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEditorMouseObservers)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDocStateListeners)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEventTarget)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEventListener)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSavedSel);
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mRangeUpdater);
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(EditorBase)
@@ -455,16 +458,17 @@ EditorBase::PreDestroy(bool aDestroyingF
   NotifyDocumentListeners(eDocumentToBeDestroyed);
 
   // Unregister event listeners
   RemoveEventListeners();
   // If this editor is still hiding the caret, we need to restore it.
   HideCaret(false);
   mActionListeners.Clear();
   mEditorObservers.Clear();
+  mEditorMouseObservers.Clear();
   mDocStateListeners.Clear();
   mInlineSpellChecker = nullptr;
   mSpellcheckCheckboxState = eTriUnset;
   mRootElement = nullptr;
 
   mDidPreDestroy = true;
   return NS_OK;
 }
@@ -1813,16 +1817,46 @@ EditorBase::RemoveEditorObserver(nsIEdit
 {
   NS_ENSURE_TRUE(aObserver, NS_ERROR_FAILURE);
 
   mEditorObservers.RemoveElement(aObserver);
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+EditorBase::AddEditorMouseObserver(nsIEditorMouseObserver *aObserver)
+{
+  // we don't keep ownership of the observers.  They must
+  // remove themselves as observers before they are destroyed.
+
+  NS_ENSURE_TRUE(aObserver, NS_ERROR_NULL_POINTER);
+
+  // Make sure the listener isn't already on the list
+  if (mEditorMouseObservers.IndexOf(aObserver) == -1)
+  {
+    if (!mEditorMouseObservers.AppendObject(aObserver))
+      return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+EditorBase::RemoveEditorMouseObserver(nsIEditorMouseObserver *aObserver)
+{
+  NS_ENSURE_TRUE(aObserver, NS_ERROR_FAILURE);
+
+  if (!mEditorMouseObservers.RemoveObject(aObserver))
+    return NS_ERROR_FAILURE;
+
+  return NS_OK;
+}
+
 class EditorInputEventDispatcher final : public Runnable
 {
 public:
   EditorInputEventDispatcher(EditorBase* aEditorBase,
                              nsIContent* aTarget,
                              bool aIsComposing)
     : mEditorBase(aEditorBase)
     , mTarget(aTarget)
@@ -1919,16 +1953,37 @@ EditorBase::FireInputEvent()
 
   // NOTE: Don't refer IsIMEComposing() because it returns false even before
   //       compositionend.  However, DOM Level 3 Events defines it should be
   //       true after compositionstart and before compositionend.
   nsContentUtils::AddScriptRunner(
     new EditorInputEventDispatcher(this, target, !!GetComposition()));
 }
 
+bool
+EditorBase::NotifyEditorMouseObservers(MouseEventType aMouseEventType,
+                                       int32_t aClientX,
+                                       int32_t aClientY,
+                                       nsIDOMNode* aTarget,
+                                       bool aIsShiftKey)
+{
+  bool rv = false;
+  for (int32_t i = 0; i < mEditorMouseObservers.Count(); i++) {
+    bool oneRv = false;
+    switch (aMouseEventType) {
+    case EditorBase::kMouseDown: mEditorMouseObservers[i]->MouseDown(aClientX, aClientY, aTarget, aIsShiftKey, &rv); break;
+    case EditorBase::kMouseUp:   mEditorMouseObservers[i]->MouseUp(aClientX, aClientY, aTarget, aIsShiftKey, &rv); break;
+    case EditorBase::kMouseMove: mEditorMouseObservers[i]->MouseMove(aClientX, aClientY, aTarget, aIsShiftKey, &rv); break;
+    }
+    rv |= oneRv;
+  }
+
+  return rv;
+}
+
 NS_IMETHODIMP
 EditorBase::AddEditActionListener(nsIEditActionListener* aListener)
 {
   NS_ENSURE_TRUE(aListener, NS_ERROR_NULL_POINTER);
 
   // Make sure the listener isn't already on the list
   if (!mActionListeners.Contains(aListener)) {
     mActionListeners.AppendElement(*aListener);
@@ -2288,17 +2343,21 @@ EditorBase::CloneAttributes(Element* aDe
 
   // Use transaction system for undo only if destination is already in the
   // document
   NS_ENSURE_TRUE(GetRoot(), );
   bool destInBody = GetRoot()->Contains(aDest);
 
   // Clear existing attributes
   RefPtr<nsDOMAttributeMap> destAttributes = aDest->Attributes();
-  while (RefPtr<Attr> attr = destAttributes->Item(0)) {
+  uint32_t destCount = destAttributes->Length();
+  for (int32_t i = destCount - 1; i >= 0; i--) {
+    RefPtr<Attr> attr = destAttributes->Item(i);
+    nsAutoString value;
+    attr->GetValue(value);
     if (destInBody) {
       RemoveAttribute(aDest, attr->NodeInfo()->NameAtom());
     } else {
       aDest->UnsetAttr(kNameSpaceID_None, attr->NodeInfo()->NameAtom(), true);
     }
   }
 
   // Set just the attributes that the source element has
@@ -2757,16 +2816,45 @@ struct SavedRange final
   RefPtr<Selection> mSelection;
   nsCOMPtr<nsINode> mStartNode;
   nsCOMPtr<nsINode> mEndNode;
   int32_t mStartOffset;
   int32_t mEndOffset;
 };
 
 nsresult
+EditorBase::RemoveNonCopyableAttributes(nsIDOMElement * aElement)
+{
+  NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
+  nsresult res = NS_OK;
+
+  nsCOMPtr<nsIDOMMozNamedAttrMap> attributes;
+  aElement->GetAttributes(getter_AddRefs(attributes));
+  NS_ENSURE_TRUE(attributes, NS_ERROR_FAILURE);
+  uint32_t attrCount;
+  attributes->GetLength(&attrCount);
+  nsCOMPtr<nsIDOMAttr> attr;
+  for (int32_t i = attrCount - 1; i >= 0; i--)   {
+    if (NS_SUCCEEDED(attributes->Item(i, getter_AddRefs(attr))) && attr) {
+      nsString attrName;
+      if (NS_SUCCEEDED(attr->GetName(attrName))) {
+        ToLowerCase(attrName);
+          if (StringBeginsWith(attrName, NS_LITERAL_STRING("its-")) ||
+              attrName.EqualsLiteral("translate") ||
+              attrName.EqualsLiteral("id")) {
+            res = RemoveAttribute(aElement, attrName);
+            NS_ENSURE_SUCCESS(res, res);
+        }
+      }
+    }
+  }
+  return res;
+}
+
+nsresult
 EditorBase::SplitNodeImpl(nsIContent& aExistingRightNode,
                           int32_t aOffset,
                           nsIContent& aNewLeftNode)
 {
   // Remember all selection points.
   AutoTArray<SavedRange, 10> savedRanges;
   for (size_t i = 0; i < kPresentSelectionTypeCount; ++i) {
     SelectionType selectionType(ToSelectionType(1 << i));
@@ -3912,16 +4000,21 @@ EditorBase::SplitNodeDeep(nsIContent& aN
     if ((aEmptyContainers == EmptyContainers::yes &&
          !nodeToSplit->GetAsText()) ||
         (offset && offset != (int32_t)nodeToSplit->Length())) {
       didSplit = true;
       ErrorResult rv;
       nsCOMPtr<nsIContent> newLeftNode = SplitNode(nodeToSplit, offset, rv);
       NS_ENSURE_TRUE(!NS_FAILED(rv.StealNSResult()), -1);
 
+      nsCOMPtr<nsIDOMElement> elt = do_QueryInterface(nodeToSplit);
+      if (elt) {
+        RemoveNonCopyableAttributes(elt);
+      }
+
       rightNode = nodeToSplit;
       leftNode = newLeftNode;
     }
 
     NS_ENSURE_TRUE(nodeToSplit->GetParent(), -1);
     OwningNonNull<nsIContent> parentNode = *nodeToSplit->GetParent();
 
     if (!didSplit && offset) {
diff --git a/editor/libeditor/EditorBase.h b/editor/libeditor/EditorBase.h
--- a/editor/libeditor/EditorBase.h
+++ b/editor/libeditor/EditorBase.h
@@ -155,16 +155,23 @@ public:
   typedef dom::Text Text;
 
   enum IterDirection
   {
     kIterForward,
     kIterBackward
   };
 
+  enum MouseEventType
+  {
+    kMouseDown,
+    kMouseUp,
+    kMouseMove
+  };
+
   /**
    * The default constructor. This should suffice. the setting of the
    * interfaces is done after the construction of the editor class.
    */
   EditorBase();
 
   virtual TextEditor* AsTextEditor() = 0;
   virtual const TextEditor* AsTextEditor() const = 0;
@@ -188,16 +195,21 @@ public:
   already_AddRefed<nsIWidget> GetWidget();
   enum NotificationForEditorObservers
   {
     eNotifyEditorObserversOfEnd,
     eNotifyEditorObserversOfBefore,
     eNotifyEditorObserversOfCancel
   };
   void NotifyEditorObservers(NotificationForEditorObservers aNotification);
+  bool NotifyEditorMouseObservers(MouseEventType aMouseEventType,
+                                  int32_t aClientX,
+                                  int32_t aClientY,
+                                  nsIDOMNode* aTarget,
+                                  bool aIsShiftKey);
 
   // nsIEditor methods
   NS_DECL_NSIEDITOR
 
   // nsIEditorIMESupport methods
   NS_DECL_NSIEDITORIMESUPPORT
 
   // nsIPhonetic
@@ -938,16 +950,18 @@ public:
 
   virtual nsresult InsertFromDrop(nsIDOMEvent* aDropEvent) = 0;
 
   virtual already_AddRefed<nsIDOMNode> FindUserSelectAllNode(nsIDOMNode* aNode)
   {
     return nullptr;
   }
 
+  nsresult RemoveNonCopyableAttributes(nsIDOMElement * aElement);
+
   /**
    * GetIMESelectionStartOffsetIn() returns the start offset of IME selection in
    * the aTextNode.  If there is no IME selection, returns -1.
    */
   int32_t GetIMESelectionStartOffsetIn(nsINode* aTextNode);
 
   /**
    * FindBetterInsertionPoint() tries to look for better insertion point which
@@ -1012,16 +1026,18 @@ protected:
   // Listens to all low level actions on the doc.
   typedef AutoTArray<OwningNonNull<nsIEditActionListener>, 5>
             AutoActionListenerArray;
   AutoActionListenerArray mActionListeners;
   // Just notify once per high level change.
   typedef AutoTArray<OwningNonNull<nsIEditorObserver>, 3>
             AutoEditorObserverArray;
   AutoEditorObserverArray mEditorObservers;
+  // Listen to mouse events
+  nsCOMArray<nsIEditorMouseObserver> mEditorMouseObservers;
   // Listen to overall doc state (dirty or not, just created, etc.).
   typedef AutoTArray<OwningNonNull<nsIDocumentStateListener>, 1>
             AutoDocumentStateListenerArray;
   AutoDocumentStateListenerArray mDocStateListeners;
 
   // Cached selection for AutoSelectionRestorer.
   SelectionState mSavedSel;
   // Utility class object for maintaining preserved ranges.
diff --git a/editor/libeditor/EditorEventListener.cpp b/editor/libeditor/EditorEventListener.cpp
--- a/editor/libeditor/EditorEventListener.cpp
+++ b/editor/libeditor/EditorEventListener.cpp
@@ -182,16 +182,19 @@ EditorEventListener::InstallToEditor()
   //     code need to check if it's editable.  It makes easier create new bugs.
   elmP->AddEventListenerByType(this,
                                NS_LITERAL_STRING("mousedown"),
                                TrustedEventsAtCapture());
   elmP->AddEventListenerByType(this,
                                NS_LITERAL_STRING("mouseup"),
                                TrustedEventsAtCapture());
   elmP->AddEventListenerByType(this,
+                               NS_LITERAL_STRING("mousemove"),
+                               TrustedEventsAtCapture());
+  elmP->AddEventListenerByType(this,
                                NS_LITERAL_STRING("click"),
                                TrustedEventsAtCapture());
   // Focus event doesn't bubble so adding the listener to capturing phase.
   // XXX Should we listen focus/blur events of system group too? Or should
   //     editor notified focus/blur of the element from nsFocusManager
   //     directly?  Because if the event propagation is stopped by JS,
   //     editor cannot initialize selection as expected.
   elmP->AddEventListenerByType(this,
@@ -276,16 +279,19 @@ EditorEventListener::UninstallFromEditor
                                   TrustedEventsAtSystemGroupBubble());
   elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("mousedown"),
                                   TrustedEventsAtCapture());
   elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("mouseup"),
                                   TrustedEventsAtCapture());
   elmP->RemoveEventListenerByType(this,
+                                  NS_LITERAL_STRING("mousemove"),
+                                  TrustedEventsAtCapture());
+  elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("click"),
                                   TrustedEventsAtCapture());
   elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("blur"),
                                   TrustedEventsAtCapture());
   elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("focus"),
                                   TrustedEventsAtCapture());
@@ -450,16 +456,22 @@ EditorEventListener::HandleEvent(nsIDOME
         mMouseDownOrUpConsumedByIME = true;
       }
       if (mMouseDownOrUpConsumedByIME) {
         return NS_OK;
       }
       nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
       return NS_WARN_IF(!mouseEvent) ? NS_OK : MouseUp(mouseEvent);
     }
+    // mousemove:
+    case eMouseMove: {
+      nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
+      NS_ENSURE_TRUE(mouseEvent, NS_OK);
+      return NS_OK;
+    }
     // click
     case eMouseClick: {
       nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
       NS_ENSURE_TRUE(mouseEvent, NS_OK);
       // If the preceding mousedown event or mouseup event was consumed,
       // editor shouldn't handle this click event.
       if (mMouseDownOrUpConsumedByIME) {
         mMouseDownOrUpConsumedByIME = false;
diff --git a/editor/libeditor/EditorEventListener.h b/editor/libeditor/EditorEventListener.h
--- a/editor/libeditor/EditorEventListener.h
+++ b/editor/libeditor/EditorEventListener.h
@@ -62,16 +62,17 @@ protected:
   nsresult KeyUp(const WidgetKeyboardEvent* aKeyboardEvent);
 #endif
   nsresult KeyPress(WidgetKeyboardEvent* aKeyboardEvent);
   nsresult HandleChangeComposition(WidgetCompositionEvent* aCompositionEvent);
   nsresult HandleStartComposition(WidgetCompositionEvent* aCompositionEvent);
   void HandleEndComposition(WidgetCompositionEvent* aCompositionEvent);
   virtual nsresult MouseDown(nsIDOMMouseEvent* aMouseEvent);
   virtual nsresult MouseUp(nsIDOMMouseEvent* aMouseEvent) { return NS_OK; }
+  virtual nsresult MouseMove(nsIDOMMouseEvent* aMouseEvent) { return NS_OK; }
   virtual nsresult MouseClick(nsIDOMMouseEvent* aMouseEvent);
   nsresult Focus(InternalFocusEvent* aFocusEvent);
   nsresult Blur(InternalFocusEvent* aBlurEvent);
   nsresult DragEnter(nsIDOMDragEvent* aDragEvent);
   nsresult DragOver(nsIDOMDragEvent* aDragEvent);
   nsresult DragExit(nsIDOMDragEvent* aDragEvent);
   nsresult Drop(nsIDOMDragEvent* aDragEvent);
 
diff --git a/editor/libeditor/HTMLEditRules.cpp b/editor/libeditor/HTMLEditRules.cpp
--- a/editor/libeditor/HTMLEditRules.cpp
+++ b/editor/libeditor/HTMLEditRules.cpp
@@ -448,16 +448,18 @@ HTMLEditRules::AfterEditInner(EditAction
     mDocChangeRange->GetStartContainer(getter_AddRefs(rangeStartParent));
     mDocChangeRange->GetEndContainer(getter_AddRefs(rangeEndParent));
     mDocChangeRange->GetStartOffset(&rangeStartOffset);
     mDocChangeRange->GetEndOffset(&rangeEndOffset);
     if (rangeStartParent && rangeEndParent)
       bDamagedRange = true;
   }
 
+  nsresult rv;
+
   if (bDamagedRange && !((action == EditAction::undo) ||
                          (action == EditAction::redo))) {
     // don't let any txns in here move the selection around behind our back.
     // Note that this won't prevent explicit selection setting from working.
     NS_ENSURE_STATE(mHTMLEditor);
     AutoTransactionsConserveSelection dontSpazMySelection(mHTMLEditor);
 
     // expand the "changed doc range" as needed
@@ -480,17 +482,20 @@ HTMLEditRules::AfterEditInner(EditAction
     if (action != EditAction::insertText &&
         action != EditAction::insertIMEText) {
       NS_ENSURE_STATE(mHTMLEditor);
       nsresult rv = mHTMLEditor->CollapseAdjacentTextNodes(mDocChangeRange);
       NS_ENSURE_SUCCESS(rv, rv);
     }
 
     // clean up any empty nodes in the selection
-    nsresult rv = RemoveEmptyNodes();
+    if ((action != EditAction::insertNode) &&
+        (action != EditAction::htmlPaste) &&
+        (action != EditAction::loadHTML))
+      rv = RemoveEmptyNodes();
     NS_ENSURE_SUCCESS(rv, rv);
 
     // attempt to transform any unneeded nbsp's into spaces after doing various operations
     if (action == EditAction::insertText ||
         action == EditAction::insertIMEText ||
         action == EditAction::deleteSelection ||
         action == EditAction::insertBreak ||
         action == EditAction::htmlPaste ||
@@ -540,22 +545,21 @@ HTMLEditRules::AfterEditInner(EditAction
       rv = ReapplyCachedStyles();
       NS_ENSURE_SUCCESS(rv, rv);
       ClearCachedStyles();
     }
   }
 
   NS_ENSURE_STATE(mHTMLEditor);
 
-  nsresult rv =
-    mHTMLEditor->HandleInlineSpellCheck(action, selection,
-                                        GetAsDOMNode(mRangeItem->startNode),
-                                        mRangeItem->startOffset,
-                                        rangeStartParent, rangeStartOffset,
-                                        rangeEndParent, rangeEndOffset);
+  rv = mHTMLEditor->HandleInlineSpellCheck(action, selection,
+                                           GetAsDOMNode(mRangeItem->startNode),
+                                           mRangeItem->startOffset,
+                                           rangeStartParent, rangeStartOffset,
+                                           rangeEndParent, rangeEndOffset);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // detect empty doc
   rv = CreateBogusNodeIfNeeded(selection);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // adjust selection HINT if needed
   if (!mDidExplicitlySetInterline) {
@@ -1342,50 +1346,18 @@ HTMLEditRules::WillInsertText(EditAction
     const char16_t *unicodeBuf = tString.get();
     int32_t pos = 0;
     NS_NAMED_LITERAL_STRING(newlineStr, LFSTR);
 
     // for efficiency, break out the pre case separately.  This is because
     // its a lot cheaper to search the input string for only newlines than
     // it is to search for both tabs and newlines.
     if (isPRE || IsPlaintextEditor()) {
-      while (unicodeBuf && pos != -1 &&
-             pos < static_cast<int32_t>(inString->Length())) {
-        int32_t oldPos = pos;
-        int32_t subStrLen;
-        pos = tString.FindChar(nsCRT::LF, oldPos);
-
-        if (pos != -1) {
-          subStrLen = pos - oldPos;
-          // if first char is newline, then use just it
-          if (!subStrLen) {
-            subStrLen = 1;
-          }
-        } else {
-          subStrLen = tString.Length() - oldPos;
-          pos = tString.Length();
-        }
-
-        nsDependentSubstring subStr(tString, oldPos, subStrLen);
-
-        // is it a return?
-        if (subStr.Equals(newlineStr)) {
-          NS_ENSURE_STATE(mHTMLEditor);
-          nsCOMPtr<Element> br =
-            mHTMLEditor->CreateBRImpl(address_of(curNode), &curOffset,
-                                      nsIEditor::eNone);
-          NS_ENSURE_STATE(br);
-          pos++;
-        } else {
-          NS_ENSURE_STATE(mHTMLEditor);
-          rv = mHTMLEditor->InsertTextImpl(subStr, address_of(curNode),
-                                           &curOffset, doc);
-          NS_ENSURE_SUCCESS(rv, rv);
-        }
-      }
+      rv = mHTMLEditor->InsertTextImpl(tString, address_of(curNode), &curOffset, doc);
+      NS_ENSURE_SUCCESS(rv, rv);
     } else {
       NS_NAMED_LITERAL_STRING(tabStr, "\t");
       NS_NAMED_LITERAL_STRING(spacesStr, "    ");
       char specialChars[] = {TAB, nsCRT::LF, 0};
       while (unicodeBuf && pos != -1 &&
              pos < static_cast<int32_t>(inString->Length())) {
         int32_t oldPos = pos;
         int32_t subStrLen;
@@ -4564,17 +4536,17 @@ HTMLEditRules::CreateStyleForInsertText(
         NS_ENSURE_SUCCESS(rv, rv);
       }
     }
 
     while (item) {
       NS_ENSURE_STATE(mHTMLEditor);
       rv = mHTMLEditor->SetInlinePropertyOnNode(*node->AsContent(),
                                                 *item->tag, &item->attr,
-                                                item->value);
+                                                item->value, false);
       NS_ENSURE_SUCCESS(rv, rv);
       item = mHTMLEditor->mTypeInState->TakeSetProperty();
     }
   }
   if (weDidSomething) {
     return aSelection.Collapse(node, offset);
   }
 
@@ -6524,16 +6496,17 @@ HTMLEditRules::SplitParagraph(nsIDOMNode
   if (EditorBase::IsTextNode(child) ||
       mHTMLEditor->IsContainer(child)) {
     aSelection->Collapse(child,0);
   } else {
     int32_t offset;
     nsCOMPtr<nsIDOMNode> parent = EditorBase::GetNodeLocation(child, &offset);
     aSelection->Collapse(parent,offset);
   }
+  ClearCachedStyles();
   return NS_OK;
 }
 
 /**
  * ReturnInListItem: do the right thing for returns pressed in list items
  */
 nsresult
 HTMLEditRules::ReturnInListItem(Selection& aSelection,
@@ -6578,16 +6551,19 @@ HTMLEditRules::ReturnInListItem(Selectio
       NS_ENSURE_SUCCESS(rv, rv);
       rv = aSelection.Collapse(&aListItem, 0);
       NS_ENSURE_SUCCESS(rv, rv);
     } else {
       // Otherwise kill this item
       rv = htmlEditor->DeleteNode(&aListItem);
       NS_ENSURE_SUCCESS(rv, rv);
 
+      ClearCachedStyles();
+      htmlEditor->mTypeInState->ClearAllProps();
+
       // Time to insert a paragraph
       nsCOMPtr<Element> pNode =
         htmlEditor->CreateNode(nsGkAtoms::p, listParent, offset + 1);
       NS_ENSURE_STATE(pNode);
 
       // Append a <br> to it
       nsCOMPtr<Element> brNode = htmlEditor->CreateBR(pNode, 0);
       NS_ENSURE_STATE(brNode);
@@ -6626,16 +6602,18 @@ HTMLEditRules::ReturnInListItem(Selectio
       if (isEmptyNode) {
         nsCOMPtr<nsIAtom> nodeAtom = aListItem.NodeInfo()->NameAtom();
         if (nodeAtom == nsGkAtoms::dd || nodeAtom == nsGkAtoms::dt) {
           nsCOMPtr<nsINode> list = aListItem.GetParentNode();
           int32_t itemOffset = list ? list->IndexOf(&aListItem) : -1;
 
           nsIAtom* listAtom = nodeAtom == nsGkAtoms::dt ? nsGkAtoms::dd
                                                         : nsGkAtoms::dt;
+          ClearCachedStyles();
+          htmlEditor->mTypeInState->ClearAllProps();
           nsCOMPtr<Element> newListItem =
             htmlEditor->CreateNode(listAtom, list, itemOffset + 1);
           NS_ENSURE_STATE(newListItem);
           rv = htmlEditor->DeleteNode(&aListItem);
           NS_ENSURE_SUCCESS(rv, rv);
           rv = aSelection.Collapse(newListItem, 0);
           NS_ENSURE_SUCCESS(rv, rv);
 
diff --git a/editor/libeditor/HTMLEditUtils.cpp b/editor/libeditor/HTMLEditUtils.cpp
--- a/editor/libeditor/HTMLEditUtils.cpp
+++ b/editor/libeditor/HTMLEditUtils.cpp
@@ -679,17 +679,17 @@ static const ElementInfo kElements[eHTML
   ELEM(mark, true, true, GROUP_PHRASE, GROUP_INLINE_ELEMENT),
   ELEM(marquee, false, false, GROUP_NONE, GROUP_NONE),
   ELEM(menu, true, true, GROUP_BLOCK, GROUP_LI | GROUP_FLOW_ELEMENT),
   ELEM(menuitem, false, false, GROUP_NONE, GROUP_NONE),
   ELEM(meta, false, false, GROUP_HEAD_CONTENT, GROUP_NONE),
   ELEM(meter, true, false, GROUP_SPECIAL, GROUP_FLOW_ELEMENT),
   ELEM(multicol, false, false, GROUP_NONE, GROUP_NONE),
   ELEM(nav, true, true, GROUP_BLOCK, GROUP_FLOW_ELEMENT),
-  ELEM(nobr, false, false, GROUP_NONE, GROUP_NONE),
+  ELEM(nobr, false, false, GROUP_PHRASE, GROUP_INLINE_ELEMENT),
   ELEM(noembed, false, false, GROUP_NONE, GROUP_NONE),
   ELEM(noframes, true, true, GROUP_BLOCK, GROUP_FLOW_ELEMENT),
   ELEM(noscript, true, true, GROUP_BLOCK, GROUP_FLOW_ELEMENT),
   ELEM(object, true, true, GROUP_SPECIAL | GROUP_BLOCK,
        GROUP_FLOW_ELEMENT | GROUP_OBJECT_CONTENT),
   // XXX Can contain self and ul because editor does sublists illegally.
   ELEM(ol, true, true, GROUP_BLOCK | GROUP_OL_UL,
        GROUP_LI | GROUP_OL_UL),
diff --git a/editor/libeditor/HTMLEditor.cpp b/editor/libeditor/HTMLEditor.cpp
--- a/editor/libeditor/HTMLEditor.cpp
+++ b/editor/libeditor/HTMLEditor.cpp
@@ -294,17 +294,18 @@ HTMLEditor::Init(nsIDOMDocument* aDoc,
     // init the type-in state
     mTypeInState = new TypeInState();
 
     // init the selection listener for image resizing
     mSelectionListenerP = new ResizerSelectionListener(this);
 
     if (!IsInteractionAllowed()) {
       // ignore any errors from this in case the file is missing
-      AddOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/EditorOverride.css"));
+      // BlueGriffon uses its own EditorOverride.css
+      //AddOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/EditorOverride.css"));
     }
 
     RefPtr<Selection> selection = GetSelection();
     if (selection) {
       nsCOMPtr<nsISelectionListener>listener;
       listener = do_QueryInterface(mTypeInState);
       if (listener) {
         selection->AddSelectionListener(listener);
@@ -2615,21 +2616,16 @@ HTMLEditor::CreateElementWithDefaults(co
       return nullptr;
     }
     newElement->SetAttribute(NS_LITERAL_STRING("border"),
                              NS_LITERAL_STRING("1"), rv);
     if (NS_WARN_IF(rv.Failed())) {
       rv.SuppressException();
       return nullptr;
     }
-  } else if (tagName.EqualsLiteral("td")) {
-    nsresult rv =
-      SetAttributeOrEquivalent(
-        newElement, nsGkAtoms::valign, NS_LITERAL_STRING("top"), true);
-    NS_ENSURE_SUCCESS(rv, nullptr);
   }
   // ADD OTHER TAGS HERE
 
   return newElement.forget();
 }
 
 NS_IMETHODIMP
 HTMLEditor::CreateElementWithDefaults(const nsAString& aTagName,
@@ -3656,17 +3652,17 @@ HTMLEditor::IsTextPropertySetByContent(n
   nsCOMPtr<nsIDOMNode>node = aNode;
 
   while (node) {
     nsCOMPtr<nsIDOMElement>element;
     element = do_QueryInterface(node);
     if (element) {
       nsAutoString tag, value;
       element->GetTagName(tag);
-      if (propName.Equals(tag, nsCaseInsensitiveStringComparator())) {
+      if (propName.IsEmpty() || propName.Equals(tag, nsCaseInsensitiveStringComparator())) {
         bool found = false;
         if (aAttribute && !aAttribute->IsEmpty()) {
           element->GetAttribute(*aAttribute, value);
           if (outValue) {
             *outValue = value;
           }
           if (!value.IsEmpty()) {
             if (!aValue) {
@@ -5272,9 +5268,40 @@ HTMLEditor::IsEditable(nsINode* aNode)
 }
 
 Element*
 HTMLEditor::GetEditorRoot()
 {
   return GetActiveEditingHost();
 }
 
+NS_IMETHODIMP
+HTMLEditor::GetMedium(nsAString & outValue)
+{
+  nsCOMPtr<nsIPresShell> ps = GetPresShell();
+
+  if (ps && ps->GetPresContext())
+  {
+    nsIAtom* medium = ps->GetPresContext()->Medium();
+    if (medium == nsGkAtoms::screen)
+      outValue.AssignLiteral("screen");
+    else
+      outValue.AssignLiteral("print");
+    return NS_OK;
+  }
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+HTMLEditor::SetMedium(const nsAString& aMedium)
+{
+  nsCOMPtr<nsIPresShell> ps = GetPresShell();
+
+  if (ps && ps->GetPresContext())
+  {
+    ps->GetPresContext()->SetMedium(aMedium);
+    return NS_OK;
+  }
+  return NS_ERROR_FAILURE;
+}
+
 } // namespace mozilla
+
diff --git a/editor/libeditor/HTMLEditor.h b/editor/libeditor/HTMLEditor.h
--- a/editor/libeditor/HTMLEditor.h
+++ b/editor/libeditor/HTMLEditor.h
@@ -701,17 +701,18 @@ protected:
                                        int32_t aStartOffset,
                                        int32_t aEndOffset,
                                        nsIAtom& aProperty,
                                        const nsAString* aAttribute,
                                        const nsAString& aValue);
   nsresult SetInlinePropertyOnNode(nsIContent& aNode,
                                    nsIAtom& aProperty,
                                    const nsAString* aAttribute,
-                                   const nsAString& aValue);
+                                   const nsAString& aValue,
+                                   bool aAvoidNestingForCSS);
 
   nsresult PromoteInlineRange(nsRange& aRange);
   nsresult PromoteRangeIfStartsOrEndsInNamedAnchor(nsRange& aRange);
   nsresult SplitStyleAboveRange(nsRange* aRange,
                                 nsIAtom* aProperty,
                                 const nsAString* aAttribute);
   nsresult SplitStyleAbovePoint(nsCOMPtr<nsINode>* aNode, int32_t* aOffset,
                                 nsIAtom* aProperty,
@@ -1015,17 +1016,18 @@ public:
 private:
   bool IsSimpleModifiableNode(nsIContent* aContent,
                               nsIAtom* aProperty,
                               const nsAString* aAttribute,
                               const nsAString* aValue);
   nsresult SetInlinePropertyOnNodeImpl(nsIContent& aNode,
                                        nsIAtom& aProperty,
                                        const nsAString* aAttribute,
-                                       const nsAString& aValue);
+                                       const nsAString& aValue,
+                                       bool aAvoidNestingForCSS);
   typedef enum { eInserted, eAppended } InsertedOrAppended;
   void DoContentInserted(nsIDocument* aDocument, nsIContent* aContainer,
                          nsIContent* aChild, int32_t aIndexInContainer,
                          InsertedOrAppended aInsertedOrAppended);
   already_AddRefed<Element> GetElementOrParentByTagName(
                               const nsAString& aTagName, nsINode* aNode);
   already_AddRefed<Element> CreateElementWithDefaults(
                               const nsAString& aTagName);
diff --git a/editor/libeditor/HTMLEditorDataTransfer.cpp b/editor/libeditor/HTMLEditorDataTransfer.cpp
--- a/editor/libeditor/HTMLEditorDataTransfer.cpp
+++ b/editor/libeditor/HTMLEditorDataTransfer.cpp
@@ -795,16 +795,18 @@ HTMLEditor::PrepareHTMLTransferable(nsIT
 
     // Create the desired DataFlavor for the type of data
     // we want to get out of the transferable
     // This should only happen in html editors, not plaintext
     if (!IsPlaintextEditor()) {
       (*aTransferable)->AddDataFlavor(kNativeHTMLMime);
       (*aTransferable)->AddDataFlavor(kHTMLMime);
       (*aTransferable)->AddDataFlavor(kFileMime);
+      if (Preferences::GetBool("bluegriffon.osx.clipboard.rtf.enabled"))
+        (*aTransferable)->AddDataFlavor(kRTFMime);
 
       switch (Preferences::GetInt("clipboard.paste_image_type", 1)) {
         case 0:  // prefer JPEG over PNG over GIF encoding
           (*aTransferable)->AddDataFlavor(kJPEGImageMime);
           (*aTransferable)->AddDataFlavor(kJPGImageMime);
           (*aTransferable)->AddDataFlavor(kPNGImageMime);
           (*aTransferable)->AddDataFlavor(kGIFImageMime);
           break;
@@ -1204,16 +1206,21 @@ HTMLEditor::InsertFromTransferable(nsITr
           // application/x-moz-nativehtml).  In this case, treat the data
           // to be pasted as mere HTML to get the best chance of pasting it
           // correctly.
           bestFlavor.AssignLiteral(kHTMLMime);
           // Fall through the next case
         }
       }
     }
+    else if (Preferences::GetBool("bluegriffon.osx.clipboard.rtf.enabled") &&
+             bestFlavor.EqualsLiteral(kRTFMime)) {
+      bestFlavor.AssignLiteral(kHTMLMime);
+      // Fall through the next case
+    }
     if (bestFlavor.EqualsLiteral(kHTMLMime) ||
         bestFlavor.EqualsLiteral(kUnicodeMime) ||
         bestFlavor.EqualsLiteral(kMozTextInternal)) {
       nsCOMPtr<nsISupportsString> textDataObj = do_QueryInterface(genericDataObj);
       if (textDataObj && len > 0) {
         nsAutoString text;
         textDataObj->GetData(text);
         NS_ASSERTION(text.Length() <= (len/2), "Invalid length!");
@@ -1224,24 +1231,50 @@ HTMLEditor::InsertFromTransferable(nsITr
           nsAutoCString text;
           textDataObj->GetData(text);
           NS_ASSERTION(text.Length() <= len, "Invalid length!");
           stuffToPaste.Assign(NS_ConvertUTF8toUTF16(Substring(text, 0, len)));
         }
       }
 
       if (!stuffToPaste.IsEmpty()) {
+
+        // Find where the <body> tag starts.
+        nsAString::const_iterator beginbody, endbody;
+        stuffToPaste.BeginReading(beginbody);
+        stuffToPaste.EndReading(endbody);
+        bool foundbody = CaseInsensitiveFindInReadable(NS_LITERAL_STRING("<body"),
+                                                         beginbody, endbody);
+        nsAutoString realStuffToPaste;
+        if (foundbody) {
+          nsAString::const_iterator endstartbody;
+          stuffToPaste.EndReading(endstartbody);
+         bool foundstartbody = CaseInsensitiveFindInReadable(NS_LITERAL_STRING(">"),
+                                                              endbody, endstartbody);
+          if (!foundstartbody)
+            return NS_ERROR_FAILURE;
+
+          nsAString::const_iterator beginclosebody, endclosebody;
+          stuffToPaste.BeginReading(beginclosebody);
+          stuffToPaste.EndReading(endclosebody);
+
+          // Find the index before "</body>"
+          CaseInsensitiveFindInReadable(NS_LITERAL_STRING("</body>"), beginclosebody, endclosebody);
+          realStuffToPaste.Assign(Substring(endstartbody, beginclosebody));
+        }
+        else
+          realStuffToPaste.Assign(stuffToPaste);
         AutoEditBatch beginBatching(this);
         if (bestFlavor.EqualsLiteral(kHTMLMime)) {
-          rv = DoInsertHTMLWithContext(stuffToPaste,
+          rv = DoInsertHTMLWithContext(realStuffToPaste,
                                        aContextStr, aInfoStr, flavor,
                                        aSourceDoc,
                                        aDestinationNode, aDestOffset,
                                        aDoDeleteSelection,
-                                       isSafe);
+                                       true);
         } else {
           rv = InsertTextAt(stuffToPaste, aDestinationNode, aDestOffset, aDoDeleteSelection);
         }
       }
     }
   }
 
   // Try to scroll the selection into view if the paste succeeded
diff --git a/editor/libeditor/HTMLEditorEventListener.cpp b/editor/libeditor/HTMLEditorEventListener.cpp
--- a/editor/libeditor/HTMLEditorEventListener.cpp
+++ b/editor/libeditor/HTMLEditorEventListener.cpp
@@ -62,20 +62,67 @@ HTMLEditorEventListener::MouseUp(nsIDOMM
   NS_ENSURE_TRUE(target, NS_ERROR_NULL_POINTER);
   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(target);
 
   int32_t clientX, clientY;
   aMouseEvent->GetClientX(&clientX);
   aMouseEvent->GetClientY(&clientY);
   htmlEditor->MouseUp(clientX, clientY, element);
 
+  bool isShiftKey;
+  rv = aMouseEvent->GetShiftKey(&isShiftKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (htmlEditor->NotifyEditorMouseObservers(EditorBase::kMouseUp,
+                                             clientX, clientY,
+                                             element, isShiftKey)) {
+    nsCOMPtr<nsIDOMEvent> event = do_QueryInterface(aMouseEvent);
+    event->PreventDefault();
+    return NS_OK;
+  }
+
   return EditorEventListener::MouseUp(aMouseEvent);
 }
 
 nsresult
+HTMLEditorEventListener::MouseMove(nsIDOMMouseEvent* aMouseEvent)
+{
+  NS_ENSURE_TRUE(mEditorBase, NS_ERROR_NOT_AVAILABLE);
+
+  if (!aMouseEvent) {
+    //non-ui event passed in.  bad things.
+    return NS_OK;
+  }
+
+  HTMLEditor* htmlEditor = mEditorBase->AsHTMLEditor();
+
+  nsCOMPtr<nsIDOMEventTarget> target;
+  nsCOMPtr<nsIDOMEvent> event = do_QueryInterface(aMouseEvent);
+  nsresult res = event->GetExplicitOriginalTarget(getter_AddRefs(target));
+  NS_ENSURE_SUCCESS(res, res);
+  NS_ENSURE_TRUE(target, NS_ERROR_NULL_POINTER);
+  nsCOMPtr<nsIDOMElement> element = do_QueryInterface(target);
+
+  int32_t clientX, clientY;
+  aMouseEvent->GetClientX(&clientX);
+  aMouseEvent->GetClientY(&clientY);
+
+  bool isShiftKey;
+  res = aMouseEvent->GetShiftKey(&isShiftKey);
+  NS_ENSURE_SUCCESS(res, res);
+  if (htmlEditor->NotifyEditorMouseObservers(EditorBase::kMouseMove,
+                                             clientX, clientY,
+                                             element, isShiftKey)) {
+    event->PreventDefault();
+    return NS_OK;
+  }
+
+  return EditorEventListener::MouseMove(aMouseEvent);
+}
+
+nsresult
 HTMLEditorEventListener::MouseDown(nsIDOMMouseEvent* aMouseEvent)
 {
   if (NS_WARN_IF(!aMouseEvent) || DetachedFromEditor()) {
     return NS_OK;
   }
 
   // Even if it's not acceptable mousedown event (i.e., when mousedown
   // event is fired outside of the active editing host), we need to commit
@@ -92,16 +139,20 @@ HTMLEditorEventListener::MouseDown(nsIDO
   MOZ_ASSERT(htmlEditor);
 
   // Contenteditable should disregard mousedowns outside it.
   // IsAcceptableInputEvent() checks it for a mouse event.
   if (!htmlEditor->IsAcceptableInputEvent(mousedownEvent)) {
     return EditorEventListener::MouseDown(aMouseEvent);
   }
 
+  int32_t clientX, clientY;
+  aMouseEvent->GetClientX(&clientX);
+  aMouseEvent->GetClientY(&clientY);
+
   // Detect only "context menu" click
   // XXX This should be easier to do!
   // But eDOMEvents_contextmenu and eContextMenu is not exposed in any event
   // interface :-(
   int16_t buttonNumber;
   nsresult rv = aMouseEvent->GetButton(&buttonNumber);
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -202,22 +253,31 @@ HTMLEditorEventListener::MouseDown(nsIDO
     // Prevent bubbling if we changed selection or
     //   for all context clicks
     if (element || isContextClick) {
       aMouseEvent->AsEvent()->PreventDefault();
       return NS_OK;
     }
   } else if (!isContextClick && buttonNumber == 0 && clickCount == 1) {
     // if the target element is an image, we have to display resizers
-    int32_t clientX, clientY;
-    aMouseEvent->GetClientX(&clientX);
-    aMouseEvent->GetClientY(&clientY);
     htmlEditor->MouseDown(clientX, clientY, element, aMouseEvent->AsEvent());
   }
 
+  nsCOMPtr<nsIDOMNode> targetNode = do_QueryInterface(target);
+  bool isShiftKey;
+  rv = aMouseEvent->GetShiftKey(&isShiftKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (htmlEditor->NotifyEditorMouseObservers(EditorBase::kMouseDown,
+                                             clientX, clientY,
+                                             element, isShiftKey)) {
+    nsCOMPtr<nsIDOMEvent> event = do_QueryInterface(aMouseEvent);
+    event->PreventDefault();
+    return NS_OK;
+  }
+
   return EditorEventListener::MouseDown(aMouseEvent);
 }
 
 nsresult
 HTMLEditorEventListener::MouseClick(nsIDOMMouseEvent* aMouseEvent)
 {
   if (NS_WARN_IF(DetachedFromEditor())) {
     return NS_OK;
diff --git a/editor/libeditor/HTMLEditorEventListener.h b/editor/libeditor/HTMLEditorEventListener.h
--- a/editor/libeditor/HTMLEditorEventListener.h
+++ b/editor/libeditor/HTMLEditorEventListener.h
@@ -29,13 +29,14 @@ public:
    * Connect() fails if aEditorBase isn't an HTMLEditor instance.
    */
   virtual nsresult Connect(EditorBase* aEditorBase) override;
 
 protected:
   virtual nsresult MouseDown(nsIDOMMouseEvent* aMouseEvent) override;
   virtual nsresult MouseUp(nsIDOMMouseEvent* aMouseEvent) override;
   virtual nsresult MouseClick(nsIDOMMouseEvent* aMouseEvent) override;
+  virtual nsresult MouseMove(nsIDOMMouseEvent* aMouseEvent) override;
 };
 
 } // namespace mozilla
 
 #endif // #ifndef HTMLEditorEventListener_h
diff --git a/editor/libeditor/HTMLStyleEditor.cpp b/editor/libeditor/HTMLStyleEditor.cpp
--- a/editor/libeditor/HTMLStyleEditor.cpp
+++ b/editor/libeditor/HTMLStyleEditor.cpp
@@ -193,18 +193,20 @@ HTMLEditor::SetInlineProperty(nsIAtom* a
         rv = SetInlinePropertyOnTextNode(*startNode->GetAsText(),
                                          range->StartOffset(),
                                          startNode->Length(), *aProperty,
                                          &aAttribute, aValue);
         NS_ENSURE_SUCCESS(rv, rv);
       }
 
       // Then loop through the list, set the property on each node
+      int32_t listCount = arrayOfNodes.Length();
       for (auto& node : arrayOfNodes) {
-        rv = SetInlinePropertyOnNode(*node, *aProperty, &aAttribute, aValue);
+        rv = SetInlinePropertyOnNode(*node, *aProperty, &aAttribute, aValue,
+                                     (1 == listCount));
         NS_ENSURE_SUCCESS(rv, rv);
       }
 
       // Last check the end parent of the range to see if it needs to be
       // separately handled (it does if it's a text node, due to how the
       // subtree iterator works - it will not have reported it).
       if (endNode && endNode->GetAsText() && IsEditable(endNode)) {
         rv = SetInlinePropertyOnTextNode(*endNode->GetAsText(), 0,
@@ -233,24 +235,27 @@ HTMLEditor::IsSimpleModifiableNode(nsICo
   MOZ_ASSERT(aProperty);
   MOZ_ASSERT_IF(aAttribute, aValue);
 
   nsCOMPtr<dom::Element> element = do_QueryInterface(aContent);
   if (!element) {
     return false;
   }
 
+  uint32_t attrCount = aContent->GetAttrCount();
+  bool noAttr = !attrCount
+                || (attrCount == 1 && aContent->GetAttrNameAt(0)->Equals(nsGkAtoms::mozdirty));
   // First check for <b>, <i>, etc.
-  if (element->IsHTMLElement(aProperty) && !element->GetAttrCount() &&
+  if (element->IsHTMLElement(aProperty) && noAttr &&
       (!aAttribute || aAttribute->IsEmpty())) {
     return true;
   }
 
   // Special cases for various equivalencies: <strong>, <em>, <s>
-  if (!element->GetAttrCount() &&
+  if (noAttr &&
       ((aProperty == nsGkAtoms::b &&
         element->IsHTMLElement(nsGkAtoms::strong)) ||
        (aProperty == nsGkAtoms::i &&
         element->IsHTMLElement(nsGkAtoms::em)) ||
        (aProperty == nsGkAtoms::strike &&
         element->IsHTMLElement(nsGkAtoms::s)))) {
     return true;
   }
@@ -272,17 +277,18 @@ HTMLEditor::IsSimpleModifiableNode(nsICo
     }
   }
 
   // No luck so far.  Now we check for a <span> with a single style=""
   // attribute that sets only the style we're looking for, if this type of
   // style supports it
   if (!mCSSEditUtils->IsCSSEditableProperty(element, aProperty, aAttribute) ||
       !element->IsHTMLElement(nsGkAtoms::span) ||
-      element->GetAttrCount() != 1 ||
+      !(attrCount == 1 || (attrCount == 2 && (element->GetAttrNameAt(0)->Equals(nsGkAtoms::mozdirty) ||
+                                              element->GetAttrNameAt(1)->Equals(nsGkAtoms::mozdirty)))) ||
       !element->HasAttr(kNameSpaceID_None, nsGkAtoms::style)) {
     return false;
   }
 
   // Some CSS styles are not so simple.  For instance, underline is
   // "text-decoration: underline", which decomposes into four different text-*
   // properties.  So for now, we just create a span, add the desired style, and
   // see if it matches.
@@ -352,24 +358,25 @@ HTMLEditor::SetInlinePropertyOnTextNode(
     sibling = GetNextHTMLSibling(text);
     if (IsSimpleModifiableNode(sibling, &aProperty, aAttribute, &aValue)) {
       // Following sib is already right kind of inline node; slide this over
       return MoveNode(text, sibling, 0);
     }
   }
 
   // Reparent the node inside inline node with appropriate {attribute,value}
-  return SetInlinePropertyOnNode(*text, aProperty, aAttribute, aValue);
+  return SetInlinePropertyOnNode(*text, aProperty, aAttribute, aValue, false);
 }
 
 nsresult
 HTMLEditor::SetInlinePropertyOnNodeImpl(nsIContent& aNode,
                                         nsIAtom& aProperty,
                                         const nsAString* aAttribute,
-                                        const nsAString& aValue)
+                                          const nsAString& aValue,
+                                          bool aAvoidNestingForCSS)
 {
   nsCOMPtr<nsIAtom> attrAtom = aAttribute ? NS_Atomize(*aAttribute) : nullptr;
 
   // If this is an element that can't be contained in a span, we have to
   // recurse to its children.
   if (!TagCanContain(*nsGkAtoms::span, aNode)) {
     if (aNode.HasChildren()) {
       nsTArray<OwningNonNull<nsIContent>> arrayOfNodes;
@@ -381,17 +388,17 @@ HTMLEditor::SetInlinePropertyOnNodeImpl(
         if (IsEditable(child) && !IsEmptyTextNode(this, child)) {
           arrayOfNodes.AppendElement(*child);
         }
       }
 
       // Then loop through the list, set the property on each node.
       for (auto& node : arrayOfNodes) {
         nsresult rv = SetInlinePropertyOnNode(node, aProperty, aAttribute,
-                                              aValue);
+                                              aValue, false);
         NS_ENSURE_SUCCESS(rv, rv);
       }
     }
     return NS_OK;
   }
 
   // First check if there's an adjacent sibling we can put our node into.
   nsCOMPtr<nsIContent> previousSibling = GetPriorHTMLSibling(&aNode);
@@ -427,18 +434,19 @@ HTMLEditor::SetInlinePropertyOnNodeImpl(
                                                       aAttribute)) ||
                 // bgcolor is always done using CSS
                 attrAtom == nsGkAtoms::bgcolor;
 
   if (useCSS) {
     nsCOMPtr<dom::Element> tmp;
     // We only add style="" to <span>s with no attributes (bug 746515).  If we
     // don't have one, we need to make one.
-    if (aNode.IsHTMLElement(nsGkAtoms::span) &&
-        !aNode.AsElement()->GetAttrCount()) {
+    if (aNode.IsElement() &&
+        (aAvoidNestingForCSS ||
+         (aNode.AsElement()->IsHTMLElement(nsGkAtoms::span) && !aNode.AsElement()->GetAttrCount()))) {
       tmp = aNode.AsElement();
     } else {
       tmp = InsertContainerAbove(&aNode, nsGkAtoms::span);
       NS_ENSURE_STATE(tmp);
     }
 
     // Add the CSS styles corresponding to the HTML style request
     mCSSEditUtils->SetCSSEquivalentToHTMLStyle(tmp,
@@ -461,30 +469,31 @@ HTMLEditor::SetInlinePropertyOnNodeImpl(
 
   return NS_OK;
 }
 
 nsresult
 HTMLEditor::SetInlinePropertyOnNode(nsIContent& aNode,
                                     nsIAtom& aProperty,
                                     const nsAString* aAttribute,
-                                    const nsAString& aValue)
+                                      const nsAString& aValue,
+                                      bool aAvoidNestingForCSS)
 {
   nsCOMPtr<nsIContent> previousSibling = aNode.GetPreviousSibling(),
                        nextSibling = aNode.GetNextSibling();
   NS_ENSURE_STATE(aNode.GetParentNode());
   OwningNonNull<nsINode> parent = *aNode.GetParentNode();
 
   nsresult rv = RemoveStyleInside(aNode, &aProperty, aAttribute);
   NS_ENSURE_SUCCESS(rv, rv);
 
   if (aNode.GetParentNode()) {
     // The node is still where it was
     return SetInlinePropertyOnNodeImpl(aNode, aProperty,
-                                       aAttribute, aValue);
+                                       aAttribute, aValue, aAvoidNestingForCSS);
   }
 
   // It's vanished.  Use the old siblings for reference to construct a
   // list.  But first, verify that the previous/next siblings are still
   // where we expect them; otherwise we have to give up.
   if ((previousSibling && previousSibling->GetParentNode() != parent) ||
       (nextSibling && nextSibling->GetParentNode() != parent)) {
     return NS_ERROR_UNEXPECTED;
@@ -494,17 +503,17 @@ HTMLEditor::SetInlinePropertyOnNode(nsIC
     ? previousSibling->GetNextSibling() : parent->GetFirstChild();
   for (; cur && cur != nextSibling; cur = cur->GetNextSibling()) {
     if (IsEditable(cur)) {
       nodesToSet.AppendElement(*cur);
     }
   }
 
   for (auto& node : nodesToSet) {
-    rv = SetInlinePropertyOnNodeImpl(node, aProperty, aAttribute, aValue);
+    rv = SetInlinePropertyOnNodeImpl(node, aProperty, aAttribute, aValue, false);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return NS_OK;
 }
 
 nsresult
 HTMLEditor::SplitStyleAboveRange(nsRange* inRange,
@@ -1312,17 +1321,17 @@ HTMLEditor::RemoveInlinePropertyImpl(nsI
                   CSSEditUtils::eComputed) &&
               // startNode's computed style indicates the CSS equivalence to
               // the HTML style to remove is applied; but we found no element
               // in the ancestors of startNode carrying specified styles;
               // assume it comes from a rule and let's try to insert a span
               // "inverting" the style
               mCSSEditUtils->IsCSSInvertible(*aProperty, aAttribute)) {
             NS_NAMED_LITERAL_STRING(value, "-moz-editor-invert-value");
-            SetInlinePropertyOnNode(node, *aProperty, aAttribute, value);
+            SetInlinePropertyOnNode(node, *aProperty, aAttribute, value, false);
           }
         }
       }
     }
   }
   if (!cancel) {
     // Post-process
     rv = rules->DidDoAction(selection, &ruleInfo, rv);
diff --git a/editor/libeditor/HTMLTableEditor.cpp b/editor/libeditor/HTMLTableEditor.cpp
--- a/editor/libeditor/HTMLTableEditor.cpp
+++ b/editor/libeditor/HTMLTableEditor.cpp
@@ -2311,42 +2311,90 @@ HTMLEditor::MergeCells(nsCOMPtr<nsIDOMEl
   nsCOMPtr<dom::Element> targetCell = do_QueryInterface(aTargetCell);
   nsCOMPtr<dom::Element> cellToMerge = do_QueryInterface(aCellToMerge);
   NS_ENSURE_TRUE(targetCell && cellToMerge, NS_ERROR_NULL_POINTER);
 
   // Prevent rules testing until we're done
   AutoRules beginRulesSniffing(this, EditAction::deleteNode, nsIEditor::eNext);
 
   // Don't need to merge if cell is empty
+  nsresult res;
   if (!IsEmptyCell(cellToMerge)) {
     // Get index of last child in target cell
     // If we fail or don't have children,
     //  we insert at index 0
     int32_t insertIndex = 0;
 
     // Start inserting just after last child
     uint32_t len = targetCell->GetChildCount();
-    if (len == 1 && IsEmptyCell(targetCell)) {
+    bool isTargetCellEmpty = IsEmptyCell(targetCell);
+    if (len == 1 && isTargetCellEmpty) {
       // Delete the empty node
       nsIContent* cellChild = targetCell->GetFirstChild();
       nsresult rv = DeleteNode(cellChild->AsDOMNode());
       NS_ENSURE_SUCCESS(rv, rv);
       insertIndex = 0;
     } else {
       insertIndex = (int32_t)len;
+      // Insert a break at the beginning of source cell if we need it.
+      // We need it if both cells are non-empty from a content point of view.
+      if (!isTargetCellEmpty) {
+        // Let's look for the last child of the target cell that is not
+        // an empty text node
+        nsIContent* targetCellChild = targetCell->GetLastChild();
+        nsCOMPtr<nsIDOMNode> targetCellChildNode = targetCellChild->AsDOMNode();
+        bool isEmptyTextNode = false;
+        while (targetCellChildNode
+               && EditorBase::IsTextNode(targetCellChildNode)
+               && (NS_SUCCEEDED(IsEmptyNode(targetCellChildNode, &isEmptyTextNode)) && isEmptyTextNode)) {
+          res = targetCellChildNode->GetPreviousSibling(getter_AddRefs(targetCellChildNode));
+          NS_ENSURE_SUCCESS(res, res);
+        }
+        // we know targetCellChildNode cannot be null at this point because
+        // we tested isTargetCellEmpty above...
+        bool isBlock = false;
+        NodeIsBlock(targetCellChildNode, &isBlock);
+        // Lets check if targetCellChildNode is a block or a break
+        if (!isBlock && !TextEditUtils::IsBreak(targetCellChildNode)) {
+          // It's not, we may have to insert a break...
+          // Let's look for the first child of the source cell that is not
+          // an empty text node
+          nsCOMPtr<nsIDOMNode> cellChildNode = cellToMerge->GetFirstChild()->AsDOMNode();
+          while (cellChildNode
+                 && EditorBase::IsTextNode(cellChildNode)
+                 && (NS_SUCCEEDED(IsEmptyNode(cellChildNode, &isEmptyTextNode)) && isEmptyTextNode)) {
+            res = cellChildNode->GetPreviousSibling(getter_AddRefs(cellChildNode));
+            NS_ENSURE_SUCCESS(res, res);
+          }
+          // we also know cellChildNode cannot be null at this point because
+          // we tested IsEmptyCell(cellToMerge) above...
+          isBlock = false;
+          NodeIsBlock(cellChildNode, &isBlock);
+          // Lets check if targetCellChildNode is a block or a break
+          if (!isBlock && !TextEditUtils::IsBreak(cellChildNode)) {
+            // so both last visible node of target cell and first visible node of
+            // source cell are not blocks or breaks. We need to insert
+            // a break as first child of source cell so the merged contents
+            // are separated by that break.
+            nsCOMPtr<nsIDOMNode> brNode;
+            res = CreateBR(aCellToMerge, 0, address_of(brNode));
+            NS_ENSURE_SUCCESS(res, res);
+          }
+        }
+      }
     }
 
     // Move the contents
     while (cellToMerge->HasChildren()) {
       nsCOMPtr<nsIDOMNode> cellChild = cellToMerge->GetLastChild()->AsDOMNode();
-      nsresult rv = DeleteNode(cellChild);
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      rv = InsertNode(cellChild, aTargetCell, insertIndex);
-      NS_ENSURE_SUCCESS(rv, rv);
+      res = DeleteNode(cellChild);
+      NS_ENSURE_SUCCESS(res, res);
+
+      res = InsertNode(cellChild, aTargetCell, insertIndex);
+      NS_ENSURE_SUCCESS(res, res);
     }
   }
 
   // Delete cells whose contents were moved
   if (aDeleteCellToMerge) {
     return DeleteNode(aCellToMerge);
   }
 
@@ -2717,17 +2765,17 @@ HTMLEditor::GetCellDataAt(nsIDOMElement*
   }
 
   nsTableWrapperFrame* tableFrame = GetTableFrame(aTable);
   NS_ENSURE_TRUE(tableFrame, NS_ERROR_FAILURE);
 
   nsTableCellFrame* cellFrame =
     tableFrame->GetCellFrameAt(aRowIndex, aColIndex);
   if (!cellFrame) {
-    return NS_ERROR_FAILURE;
+    return NS_SUCCESS_EDITOR_ELEMENT_NOT_FOUND;
   }
 
   *aIsSelected = cellFrame->IsSelected();
   cellFrame->GetRowIndex(*aStartRowIndex);
   cellFrame->GetColIndex(*aStartColIndex);
   *aRowSpan = cellFrame->GetRowSpan();
   *aColSpan = cellFrame->GetColSpan();
   *aActualRowSpan = tableFrame->GetEffectiveRowSpanAt(aRowIndex, aColIndex);
diff --git a/editor/libeditor/TextEditorDataTransfer.cpp b/editor/libeditor/TextEditorDataTransfer.cpp
--- a/editor/libeditor/TextEditorDataTransfer.cpp
+++ b/editor/libeditor/TextEditorDataTransfer.cpp
@@ -453,20 +453,17 @@ TextEditor::IsSafeToInsertData(nsIDOMDoc
   nsCOMPtr<nsIDocument> destdoc = GetDocument();
   NS_ASSERTION(destdoc, "Where is our destination doc?");
   nsCOMPtr<nsIDocShellTreeItem> dsti = destdoc->GetDocShell();
   nsCOMPtr<nsIDocShellTreeItem> root;
   if (dsti) {
     dsti->GetRootTreeItem(getter_AddRefs(root));
   }
   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(root);
-  uint32_t appType;
-  if (docShell && NS_SUCCEEDED(docShell->GetAppType(&appType))) {
-    isSafe = appType == nsIDocShell::APP_TYPE_EDITOR;
-  }
+
   if (!isSafe && aSourceDoc) {
     nsCOMPtr<nsIDocument> srcdoc = do_QueryInterface(aSourceDoc);
     NS_ASSERTION(srcdoc, "Where is our source doc?");
 
     nsIPrincipal* srcPrincipal = srcdoc->NodePrincipal();
     nsIPrincipal* destPrincipal = destdoc->NodePrincipal();
     NS_ASSERTION(srcPrincipal && destPrincipal, "How come we don't have a principal?");
     srcPrincipal->Subsumes(destPrincipal, &isSafe);
diff --git a/editor/libeditor/WSRunObject.cpp b/editor/libeditor/WSRunObject.cpp
--- a/editor/libeditor/WSRunObject.cpp
+++ b/editor/libeditor/WSRunObject.cpp
@@ -476,17 +476,17 @@ WSRunObject::PriorVisibleNode(nsINode* a
   // anything return start of ws.
   MOZ_ASSERT(aNode && outVisNode && outVisOffset && outType);
 
   WSFragment* run;
   FindRun(aNode, aOffset, &run, false);
 
   // Is there a visible run there or earlier?
   for (; run; run = run->mLeft) {
-    if (run->mType == WSType::normalWS) {
+    if (run->mType == WSType::normalWS || run->mType == WSType::trailingWS) {
       WSPoint point = GetCharBefore(aNode, aOffset);
       // When it's a non-empty text node, return it.
       if (point.mTextNode && point.mTextNode->Length()) {
         *outVisNode = point.mTextNode;
         *outVisOffset = point.mOffset + 1;
         if (nsCRT::IsAsciiSpace(point.mChar) || point.mChar == nbsp) {
           *outType = WSType::normalWS;
         } else {
diff --git a/editor/moz.build b/editor/moz.build
--- a/editor/moz.build
+++ b/editor/moz.build
@@ -13,16 +13,17 @@ DIRS += [
 
 XPIDL_SOURCES += [
     'nsIContentFilter.idl',
     'nsIDocumentStateListener.idl',
     'nsIEditActionListener.idl',
     'nsIEditor.idl',
     'nsIEditorIMESupport.idl',
     'nsIEditorMailSupport.idl',
+    'nsIEditorMouseObserver.idl',
     'nsIEditorObserver.idl',
     'nsIEditorSpellCheck.idl',
     'nsIEditorStyleSheets.idl',
     'nsIEditorUtils.idl',
     'nsIHTMLAbsPosEditor.idl',
     'nsIHTMLEditor.idl',
     'nsIHTMLInlineTableEditor.idl',
     'nsIHTMLObjectResizeListener.idl',
diff --git a/editor/nsIEditor.idl b/editor/nsIEditor.idl
--- a/editor/nsIEditor.idl
+++ b/editor/nsIEditor.idl
@@ -15,28 +15,29 @@ interface nsISelectionController;
 interface nsIDocumentStateListener;
 interface nsIOutputStream;
 interface nsITransactionManager;
 interface nsITransaction;
 interface nsIEditorObserver;
 interface nsIEditActionListener;
 interface nsIInlineSpellChecker;
 interface nsITransferable;
+interface nsIEditorMouseObserver;
 
 %{C++
 namespace mozilla {
 namespace widget {
 struct IMEState;
 } // namespace widget
 } // namespace mozilla
 %}
 
 native IMEState(mozilla::widget::IMEState);
 
-[scriptable, uuid(094be624-f0bf-400f-89e2-6a84baab9474)]
+[scriptable, uuid(EE1D66E6-1F4E-4A70-AEA9-23E1EFC17E92)]
 interface nsIEditor  : nsISupports
 {
 %{C++
   typedef short EDirection;
   typedef short EStripWrappers;
 %}
   const short eNone = 0;
   const short eNext = 1;
@@ -531,16 +532,19 @@ interface nsIEditor  : nsISupports
    */
 
   /** add an EditorObserver to the editors list of observers. */
   void addEditorObserver(in nsIEditorObserver observer);
 
   /** Remove an EditorObserver from the editor's list of observers. */
   void removeEditorObserver(in nsIEditorObserver observer);
 
+  void addEditorMouseObserver(in nsIEditorMouseObserver observer);
+  void removeEditorMouseObserver(in nsIEditorMouseObserver observer);
+
   /** add an EditActionListener to the editors list of listeners. */
   void addEditActionListener(in nsIEditActionListener listener);
 
   /** Remove an EditActionListener from the editor's list of listeners. */
   void removeEditActionListener(in nsIEditActionListener listener);
 
   /** Add a DocumentStateListener to the editors list of doc state listeners. */
   void addDocumentStateListener(in nsIDocumentStateListener listener);
diff --git a/editor/nsIEditorMouseObserver.idl b/editor/nsIEditorMouseObserver.idl
new file mode 100644
--- /dev/null
+++ b/editor/nsIEditorMouseObserver.idl
@@ -0,0 +1,17 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+#include "domstubs.idl"
+
+
+[scriptable, uuid(7A76F573-7512-4051-BB20-E6E279F26F55)]
+
+interface nsIEditorMouseObserver : nsISupports {
+
+  bool MouseDown(in int32_t aClientX, in int32_t aClientY, in nsIDOMNode aTarget, in boolean aShiftKey);
+  bool MouseUp(in int32_t aClientX, in int32_t aClientY, in nsIDOMNode aTarget, in boolean aShiftKey);
+  bool MouseMove(in int32_t aClientX, in int32_t aClientY, in nsIDOMNode aTarget, in boolean aShiftKey);
+};
diff --git a/editor/nsIHTMLEditor.idl b/editor/nsIHTMLEditor.idl
--- a/editor/nsIHTMLEditor.idl
+++ b/editor/nsIHTMLEditor.idl
@@ -17,17 +17,17 @@ namespace mozilla {
 namespace dom {
 class Element;
 }
 }
 %}
 
 [ptr] native Element (mozilla::dom::Element);
 
-[scriptable, uuid(87ee993e-985f-4a43-a974-0d9512da2fb0)]
+[scriptable, uuid(BFA533D9-358C-47CC-92FF-E89D5263D264)]
 interface nsIHTMLEditor : nsISupports
 {
 %{C++
   typedef short EAlignment;
 %}
 
   // used by GetAlignment()
   const short eLeft = 0;
@@ -487,16 +487,19 @@ interface nsIHTMLEditor : nsISupports
   /**
    * A boolean which is true is the HTMLEditor has been instantiated
    * with CSS knowledge and if the CSS pref is currently checked
    *
    * @return    true if CSS handled and enabled
    */
   attribute boolean isCSSEnabled;
 
+  AString getMedium();
+  void setMedium(in AString aMedium);
+
   /**
    * Add listener for insertion override
    * @param inFilter  function which callers want called during insertion
    */
   void addInsertionListener(in nsIContentFilter inFilter);
 
   /**
    * Remove listener for insertion override
diff --git a/extensions/moz.build b/extensions/moz.build
--- a/extensions/moz.build
+++ b/extensions/moz.build
@@ -1,10 +1,16 @@
 # -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
 # vim: set filetype=python:
 # This Source Code Form is subject to the terms of the Mozilla Public
 # License, v. 2.0. If a copy of the MPL was not distributed with this
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
-DIRS += CONFIG['MOZ_EXTENSIONS']
++DIRS += [
++    'svg-edit',
++    'gfd',
++    'fs',
++    'markdown',
++    'op1'
++]
 
 with Files('**'):
     BUG_COMPONENT = ('Core', 'General')
diff --git a/gfx/src/nsColor.cpp b/gfx/src/nsColor.cpp
--- a/gfx/src/nsColor.cpp
+++ b/gfx/src/nsColor.cpp
@@ -210,16 +210,37 @@ bool NS_ColorNameToRGB(const nsAString& 
     if (aResult) {
       *aResult = kColors[id];
     }
     return true;
   }
   return false;
 }
 
+bool NS_RGBToColorName(nscolor aColor, nsAString& aResult)
+{
+  uint8_t a = NS_GET_A(aColor);
+  if (a < 255)
+    return false;
+  uint8_t r = NS_GET_R(aColor);
+  uint8_t g = NS_GET_G(aColor);
+  uint8_t b = NS_GET_B(aColor);
+  uint32_t colorIndex;
+  for (colorIndex = 0; colorIndex < eColorName_COUNT; colorIndex++) {
+    nscolor matchingColor = kColors[colorIndex];
+    if (NS_GET_R(matchingColor) == r
+        && NS_GET_G(matchingColor) == g
+        && NS_GET_B(matchingColor) == b) {
+      aResult.AppendASCII(kColorNames[colorIndex]);
+      return true;
+    }
+  }
+  return false;
+}
+
 // Returns kColorNames, an array of all possible color names, and sets
 // *aSizeArray to the size of that array. Do NOT call free() on this array.
 const char * const * NS_AllColorNames(size_t *aSizeArray)
 {
   *aSizeArray = ArrayLength(kColorNames);
   return kColorNames;
 }
 
diff --git a/gfx/src/nsColor.h b/gfx/src/nsColor.h
--- a/gfx/src/nsColor.h
+++ b/gfx/src/nsColor.h
@@ -100,16 +100,20 @@ bool NS_LooseHexToRGB(const nsString& aB
 
 // There is no function to translate a color to a hex string, because
 // the hex-string syntax does not support transparency.
 
 // Translate a color name to a color. Return true if it parses ok,
 // otherwise return false.
 bool NS_ColorNameToRGB(const nsAString& aBuf, nscolor* aResult);
 
+// Translate a color to a color name. Return true if it parses ok,
+// otherwise return false.
+bool NS_RGBToColorName(nscolor aColor, nsAString& aResult);
+
 // Returns an array of all possible color names, and sets
 // *aSizeArray to the size of that array. Do NOT call |free()| on this array.
 const char * const * NS_AllColorNames(size_t *aSizeArray);
 
 // function to convert from HSL color space to RGB color space
 // the float parameters are all expected to be in the range 0-1
 nscolor NS_HSL2RGB(float h, float s, float l);
 
diff --git a/image/imgICache.idl b/image/imgICache.idl
--- a/image/imgICache.idl
+++ b/image/imgICache.idl
@@ -14,27 +14,29 @@ interface nsIURI;
 
 /**
  * imgICache interface
  *
  * @author Stuart Parmenter <pavlov@netscape.com>
  * @version 0.1
  * @see imagelib2
  */
-[scriptable, builtinclass, uuid(bfdf23ff-378e-402e-8a6c-840f0c82b6c3)]
+[scriptable, builtinclass, uuid(862388D5-EB14-4E0D-931C-F4FAD05FB5F2)]
 interface imgICache : nsISupports
 {
   /**
    * Evict images from the cache.
    *
    * @param chrome If TRUE,  evict only chrome images.
    *               If FALSE, evict everything except chrome images.
    */
   void clearCache(in boolean chrome);
 
+  void removeEntry(in nsIURI uri, in nsIDOMDocument doc);
+
   /**
    * Find Properties
    * Used to get properties such as 'type' and 'content-disposition'
    * 'type' is a nsISupportsCString containing the images' mime type such as
    * 'image/png'
    * 'content-disposition' will be a nsISupportsCString containing the header
    * If you call this before any data has been loaded from a URI, it will
    * succeed, but come back empty.
diff --git a/image/imgLoader.cpp b/image/imgLoader.cpp
--- a/image/imgLoader.cpp
+++ b/image/imgLoader.cpp
@@ -1361,16 +1361,37 @@ imgLoader::ClearCache(bool chrome)
   if (chrome) {
     return ClearChromeImageCache();
   }
   return ClearImageCache();
 
 }
 
 NS_IMETHODIMP
+imgLoader::RemoveEntry(nsIURI* aURI, nsIDOMDocument* aDOMDoc)
+{
+  OriginAttributes attrs;
+  nsCOMPtr<nsIDocument> doc = do_QueryInterface(aDOMDoc);
+  if (doc) {
+    nsCOMPtr<nsIPrincipal> principal = doc->NodePrincipal();
+    if (principal) {
+      attrs = principal->OriginAttributesRef();
+    }
+  }
+
+  nsresult rv;
+  ImageCacheKey key(aURI, attrs, doc, rv);
+  if (aURI && RemoveFromCache(key)) {
+    return NS_OK;
+  }
+
+  return NS_ERROR_NOT_AVAILABLE;
+}
+
+NS_IMETHODIMP
 imgLoader::FindEntryProperties(nsIURI* uri,
                                nsIDOMDocument* aDOMDoc,
                                nsIProperties** _retval)
 {
   *_retval = nullptr;
 
   nsCOMPtr<nsIDocument> doc = do_QueryInterface(aDOMDoc);
 
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -2147,16 +2147,30 @@ nsPresContext::SetPaginatedScrolling(boo
 
 void
 nsPresContext::SetPrintSettings(nsIPrintSettings *aPrintSettings)
 {
   if (mMedium == nsGkAtoms::print)
     mPrintSettings = aPrintSettings;
 }
 
+void
+nsPresContext::SetMedium(const nsAString& aMedium)
+{
+  if (aMedium.EqualsLiteral("screen")) {
+    mMedium = nsGkAtoms::screen;
+    mType =  eContext_Galley;
+  } else {
+    mMedium = nsGkAtoms::print;
+    mType =  eContext_PageLayout;
+    mPaginated = true;
+  }
+  MediaFeatureValuesChanged(eRestyle_ForceDescendants, NS_STYLE_HINT_REFLOW);
+}
+
 bool
 nsPresContext::EnsureVisible()
 {
   nsCOMPtr<nsIDocShell> docShell(mContainer);
   if (docShell) {
     nsCOMPtr<nsIContentViewer> cv;
     docShell->GetContentViewer(getter_AddRefs(cv));
     // Make sure this is the content viewer we belong with
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -326,16 +326,17 @@ public:
   /**
    * Get medium of presentation
    */
   nsIAtom* Medium() {
     if (!mIsEmulatingMedia)
       return mMedium;
     return mMediaEmulated;
   }
+  void SetMedium(const nsAString& aMedium);
 
   /*
    * Render the document as if being viewed on a device with the specified
    * media type.
    */
   void EmulateMedium(const nsAString& aMediaType);
 
   /*
diff --git a/layout/forms/nsColorControlFrame.cpp b/layout/forms/nsColorControlFrame.cpp
--- a/layout/forms/nsColorControlFrame.cpp
+++ b/layout/forms/nsColorControlFrame.cpp
@@ -96,16 +96,18 @@ nsColorControlFrame::AppendAnonymousCont
 nsresult
 nsColorControlFrame::UpdateColor()
 {
   // Get the color from the "value" property of our content; it will return the
   // default color (through the sanitization algorithm) if there is none.
   nsAutoString color;
   HTMLInputElement* elt = HTMLInputElement::FromContent(mContent);
   elt->GetValue(color, CallerType::System);
+  if (color.IsEmpty())
+    return NS_OK;
   MOZ_ASSERT(!color.IsEmpty(),
              "Content node's GetValue() should return a valid color string "
              "(the default color, in case no valid color is set)");
 
   // Set the background-color style property of the swatch element to this color
   return mColorContent->SetAttr(kNameSpaceID_None, nsGkAtoms::style,
       NS_LITERAL_STRING("background-color:") + color, true);
 }
diff --git a/layout/style/Loader.cpp b/layout/style/Loader.cpp
--- a/layout/style/Loader.cpp
+++ b/layout/style/Loader.cpp
@@ -1120,17 +1120,18 @@ Loader::CreateSheet(nsIURI* aURI,
       if (cache && cache->IsEnabled()) {
         sheet = cache->GetStyleSheet(aURI, GetStyleBackendType());
         LOG(("  From XUL cache: %p", sheet.get()));
       }
     }
 #endif
 
     bool fromCompleteSheets = false;
-    if (!sheet) {
+    //XXX BlueGriffon forces reload of stylesheets each time we need them
+    if (false /*!sheet*/) {
       // Then our per-document complete sheets.
       URIPrincipalReferrerPolicyAndCORSModeHashKey key(aURI, aLoaderPrincipal, aCORSMode, aReferrerPolicy);
 
       StyleSheet* completeSheet = nullptr;
       mSheets->mCompleteSheets.Get(&key, &completeSheet);
       sheet = completeSheet;
       LOG(("  From completed: %p", sheet.get()));
 
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -57,16 +57,18 @@
 #include "mozilla/LookAndFeel.h"
 #include "mozilla/Preferences.h"
 #include "nsRuleData.h"
 #include "mozilla/CSSVariableValues.h"
 #include "mozilla/dom/AnimationEffectReadOnlyBinding.h"
 #include "mozilla/dom/URL.h"
 #include "gfxFontFamilyList.h"
 
+#define BG_CONSOLE_SHOW_INVALID_VARIABLES "bluegriffon.console.showInvalidVariables"
+
 using namespace mozilla;
 using namespace mozilla::css;
 
 typedef nsCSSProps::KTableEntry KTableEntry;
 
 // pref-backed bool values (hooked up in nsCSSParser::Startup)
 static bool sOpentypeSVGEnabled;
 static bool sWebkitPrefixedAliasesEnabled;
@@ -2979,17 +2981,17 @@ CSSParserImpl::ParsePropertyWithVariable
   {
     nsCSSScanner scanner(aValue, 0);
     css::ErrorReporter reporter(scanner, aSheet, mChildLoader, aDocURL);
     InitScanner(scanner, reporter, aDocURL, aBaseURL, aDocPrincipal);
 
     nsCSSTokenSerializationType firstToken, lastToken;
     valid = ResolveValueWithVariableReferences(aVariables, expandedValue,
                                                firstToken, lastToken);
-    if (!valid) {
+    if (!valid && Preferences::GetBool(BG_CONSOLE_SHOW_INVALID_VARIABLES)) {
       NS_ConvertASCIItoUTF16 propName(nsCSSProps::GetStringValue(aPropertyID));
       REPORT_UNEXPECTED(PEInvalidVariableReference);
       REPORT_UNEXPECTED_P(PEValueParsingError, propName);
       if (nsCSSProps::IsInherited(aPropertyID)) {
         REPORT_UNEXPECTED(PEValueWithVariablesFallbackInherit);
       } else {
         REPORT_UNEXPECTED(PEValueWithVariablesFallbackInitial);
       }
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -1670,45 +1670,87 @@ nsCSSValue::AppendToString(nsCSSProperty
     nsAutoCString str;
     if (nsCSSProps::GetColorName(GetIntValue(), str)){
       AppendASCIItoUTF16(str, aResult);
     } else {
       MOZ_ASSERT(false, "bad color value");
     }
   }
   else if (IsNumericColorUnit(unit)) {
+    bool outputCssNames = false;
+    nsXPIDLCString colorOutputType;
+    nsresult rv;
+    nsCOMPtr<nsIPrefBranch> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
+    if (NS_SUCCEEDED(rv) && prefBranch) {
+      prefBranch->GetBoolPref("bluegriffon.css.colors.names.enabled", &outputCssNames);
+      prefBranch->GetCharPref("bluegriffon.css.colors.type", getter_Copies(colorOutputType));
+    }
+    bool serializeName = false;
+    bool forceHexSerialization = false;
+
     if (aSerialization == eNormalized ||
         unit == eCSSUnit_RGBColor ||
         unit == eCSSUnit_RGBAColor) {
       nscolor color = GetColorValue();
       // For brevity, we omit the alpha component if it's equal to 255 (full
       // opaque). Also, we try to preserve the author-specified function name,
       // unless it's rgba() and we're omitting the alpha component - then we
       // use rgb().
       uint8_t a = NS_GET_A(color);
       bool showAlpha = (a != 255);
 
       if (unit == eCSSUnit_RGBAColor && showAlpha) {
         aResult.AppendLiteral("rgba(");
       } else {
-        aResult.AppendLiteral("rgb(");
+          if (outputCssNames) {
+            nsAutoString nameToSerialize;
+            serializeName = NS_RGBToColorName(color, nameToSerialize);
+            if (serializeName) {
+              aResult.Append(nameToSerialize);
+            }
+            else {
+              if (!PL_strcmp(colorOutputType, "hex")) {
+                forceHexSerialization = true;
+              }
+              else
+                aResult.AppendLiteral("rgb(");
+            }
+          }
+          else {
+            if (!PL_strcmp(colorOutputType, "hex")) {
+              forceHexSerialization = true;
+            }
+            else
+              aResult.AppendLiteral("rgb(");
+          }
       }
 
-      NS_NAMED_LITERAL_STRING(comma, ", ");
-
-      aResult.AppendInt(NS_GET_R(color), 10);
-      aResult.Append(comma);
-      aResult.AppendInt(NS_GET_G(color), 10);
-      aResult.Append(comma);
-      aResult.AppendInt(NS_GET_B(color), 10);
-      if (showAlpha) {
-        aResult.Append(comma);
-        aResult.AppendFloat(nsStyleUtil::ColorComponentToFloat(a));
+        if (!serializeName) {
+          if (forceHexSerialization) {
+            nscolor color = GetColorValue();
+            aResult.Append('#');
+            aResult.AppendPrintf("%02x", NS_GET_R(color));
+            aResult.AppendPrintf("%02x", NS_GET_G(color));
+            aResult.AppendPrintf("%02x", NS_GET_B(color));
+          }
+          else {
+            NS_NAMED_LITERAL_STRING(comma, ", ");
+
+            aResult.AppendInt(NS_GET_R(color), 10);
+            aResult.Append(comma);
+            aResult.AppendInt(NS_GET_G(color), 10);
+            aResult.Append(comma);
+            aResult.AppendInt(NS_GET_B(color), 10);
+            if (showAlpha) {
+              aResult.Append(comma);
+              aResult.AppendFloat(nsStyleUtil::ColorComponentToFloat(a));
+            }
+            aResult.Append(char16_t(')'));
+          }
       }
-      aResult.Append(char16_t(')'));
     } else if (eCSSUnit_HexColor == unit ||
                eCSSUnit_HexColorAlpha == unit) {
       nscolor color = GetColorValue();
       aResult.Append('#');
       aResult.AppendPrintf("%02x", NS_GET_R(color));
       aResult.AppendPrintf("%02x", NS_GET_G(color));
       aResult.AppendPrintf("%02x", NS_GET_B(color));
       if (eCSSUnit_HexColorAlpha == unit) {
diff --git a/netwerk/protocol/res/nsResProtocolHandler.cpp b/netwerk/protocol/res/nsResProtocolHandler.cpp
--- a/netwerk/protocol/res/nsResProtocolHandler.cpp
+++ b/netwerk/protocol/res/nsResProtocolHandler.cpp
@@ -88,13 +88,13 @@ nsResProtocolHandler::ResolveSpecialCase
     }
     aResult.Append(aPath);
     return true;
 }
 
 nsresult
 nsResProtocolHandler::SetSubstitution(const nsACString& aRoot, nsIURI* aBaseURI)
 {
-    MOZ_ASSERT(!aRoot.Equals(""));
+    /*MOZ_ASSERT(!aRoot.Equals(""));
     MOZ_ASSERT(!aRoot.Equals(kAPP));
-    MOZ_ASSERT(!aRoot.Equals(kGRE));
+    MOZ_ASSERT(!aRoot.Equals(kGRE));*/
     return SubstitutingProtocolHandler::SetSubstitution(aRoot, aBaseURI);
 }
diff --git a/parser/htmlparser/nsExpatDriver.cpp b/parser/htmlparser/nsExpatDriver.cpp
--- a/parser/htmlparser/nsExpatDriver.cpp
+++ b/parser/htmlparser/nsExpatDriver.cpp
@@ -957,17 +957,19 @@ nsExpatDriver::HandleError()
   }
 
   // If it didn't initialize, we can't do any logging.
   bool shouldReportError = NS_SUCCEEDED(rv);
 
   if (mSink && shouldReportError) {
     rv = mSink->ReportError(errorText.get(), 
                             sourceText.get(), 
-                            serr, 
+                            serr,
+                            lineNumber,
+                            colNumber,
                             &shouldReportError);
     if (NS_FAILED(rv)) {
       shouldReportError = true;
     }
   }
 
   if (mOriginalSink) {
     nsCOMPtr<nsIDocument> doc = do_QueryInterface(mOriginalSink->GetTarget());
@@ -975,17 +977,17 @@ nsExpatDriver::HandleError()
       shouldReportError = false;
     }
   }
 
   if (shouldReportError) {
     nsCOMPtr<nsIConsoleService> cs
       (do_GetService(NS_CONSOLESERVICE_CONTRACTID));  
     if (cs) {
-      cs->LogMessage(serr);
+      //cs->LogMessage(serr);
     }
   }
 
   return NS_ERROR_HTMLPARSER_STOPPARSING;
 }
 
 void
 nsExpatDriver::ParseBuffer(const char16_t *aBuffer,
diff --git a/parser/htmlparser/nsIExpatSink.idl b/parser/htmlparser/nsIExpatSink.idl
--- a/parser/htmlparser/nsIExpatSink.idl
+++ b/parser/htmlparser/nsIExpatSink.idl
@@ -7,17 +7,17 @@
 interface nsIScriptError;
 
 /**
  * This interface should be implemented by any content sink that wants
  * to get output from expat and do something with it; in other words,
  * by any sink that handles some sort of XML dialect.
  */
 
-[scriptable, uuid(01f681af-0f22-4725-a914-0d396114daf0)]
+[scriptable, uuid(685473DA-41AA-4B20-BC9E-00828B592F76)]
 interface nsIExpatSink : nsISupports 
 {
   /**
    * Called to handle the opening tag of an element.
    * @param aName the fully qualified tagname of the element
    * @param aAtts the array of attribute names and values.  There are
    *        aAttsCount/2 names and aAttsCount/2 values, so the total number of
    *        elements in the array is aAttsCount.  The names and values
@@ -100,10 +100,12 @@ interface nsIExpatSink : nsISupports
    * @param aErrorText  Error message to pass to content sink.
    * @param aSourceText Source text of the document we're parsing.
    * @param aError      Script error object with line number & column number
    *
    * @retval True if the expat driver should report the error.
    */
   boolean ReportError(in wstring aErrorText,
                       in wstring aSourceText,
-                      in nsIScriptError aError);
+                      in nsIScriptError aError,
+                      in unsigned long aLineNumber,
+                      in unsigned long aColNumber);
 }; 
diff --git a/parser/xml/nsSAXXMLReader.cpp b/parser/xml/nsSAXXMLReader.cpp
--- a/parser/xml/nsSAXXMLReader.cpp
+++ b/parser/xml/nsSAXXMLReader.cpp
@@ -301,16 +301,18 @@ nsSAXXMLReader::HandleXMLDeclaration(con
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSAXXMLReader::ReportError(const char16_t* aErrorText,
                             const char16_t* aSourceText,
                             nsIScriptError *aError,
+                            PRUint32 aLineNumber,
+                            PRUint32 aColNumber,
                             bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
   // Normally, the expat driver should report the error.
   *_retval = true;
 
   if (mErrorHandler) {
     uint32_t lineNumber;
diff --git a/rdf/base/nsRDFContentSink.cpp b/rdf/base/nsRDFContentSink.cpp
--- a/rdf/base/nsRDFContentSink.cpp
+++ b/rdf/base/nsRDFContentSink.cpp
@@ -522,16 +522,18 @@ RDFContentSinkImpl::HandleXMLDeclaration
 {
     return NS_OK;
 }
 
 NS_IMETHODIMP
 RDFContentSinkImpl::ReportError(const char16_t* aErrorText, 
                                 const char16_t* aSourceText,
                                 nsIScriptError *aError,
+                                PRUint32 aLineNumber,
+                                PRUint32 aColNumber,
                                 bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 
   // The expat driver should report the error.
   *_retval = true;
   return NS_OK;
 }
diff --git a/toolkit/components/passwordmgr/nsLoginManagerPrompter.js b/toolkit/components/passwordmgr/nsLoginManagerPrompter.js
--- a/toolkit/components/passwordmgr/nsLoginManagerPrompter.js
+++ b/toolkit/components/passwordmgr/nsLoginManagerPrompter.js
@@ -1415,20 +1415,21 @@ LoginManagerPrompter.prototype = {
     propBag.setProperty("timesUsedIncrement", 1);
     this._pwmgr.modifyLogin(login, propBag);
   },
 
   /**
    * Given a content DOM window, returns the chrome window and browser it's in.
    */
   _getChromeWindow(aWindow) {
-    let windows = Services.wm.getEnumerator(null);
+    let windows = Services.wm.getEnumerator("bluegriffon");
     while (windows.hasMoreElements()) {
       let win = windows.getNext();
-      let browser = win.gBrowser.getBrowserForContentWindow(aWindow);
+      // let browser = win.gBrowser.getBrowserForContentWindow(aWindow);
+      let browser = win.EditorUtils.getCurrentTabEditor();
       if (browser) {
         return { win, browser };
       }
     }
     return null;
   },
 
   _getNotifyWindow() {
diff --git a/toolkit/components/telemetry/TelemetryStartup.js b/toolkit/components/telemetry/TelemetryStartup.js
--- a/toolkit/components/telemetry/TelemetryStartup.js
+++ b/toolkit/components/telemetry/TelemetryStartup.js
@@ -31,16 +31,18 @@ TelemetryStartup.prototype.observe = fun
     annotateEnvironment();
     TelemetryEnvironment.registerChangeListener("CrashAnnotator", annotateEnvironment);
     TelemetryEnvironment.onInitialized().then(() => annotateEnvironment());
   }
 }
 
 function annotateEnvironment() {
   try {
+    if (!("@mozilla.org/toolkit/crash-reporter;1" in Cc))
+      return;
     let cr = Cc["@mozilla.org/toolkit/crash-reporter;1"];
     if (cr) {
       let env = JSON.stringify(TelemetryEnvironment.currentEnvironment);
       cr.getService(Ci.nsICrashReporter).annotateCrashReport("TelemetryEnvironment", env);
     }
   } catch (e) {
     // crash reporting not built or disabled? Ignore errors
   }
diff --git a/toolkit/content/widgets/menu.xml b/toolkit/content/widgets/menu.xml
--- a/toolkit/content/widgets/menu.xml
+++ b/toolkit/content/widgets/menu.xml
@@ -219,16 +219,25 @@
       <xul:label class="menu-iconic-text" flex="1" xbl:inherits="value=label,accesskey,crop" crop="right"/>
       <children/>
       <xul:hbox class="menu-accel-container" anonid="accel">
         <xul:label class="menu-iconic-accel" xbl:inherits="value=acceltext"/>
       </xul:hbox>
     </content>
   </binding>
 
+  <binding id="menuitem-non-iconic-accel" extends="chrome://global/content/bindings/menu.xml#menuitem">
+    <content>
+      <xul:label class="menu-iconic-text" flex="1" xbl:inherits="value=label,accesskey,crop" crop="right"/>
+      <xul:hbox class="menu-accel-container" anonid="accel">
+        <xul:label class="menu-iconic-accel" xbl:inherits="value=acceltext"/>
+      </xul:hbox>
+    </content>
+  </binding>
+
   <binding id="menuitem-iconic-noaccel" extends="chrome://global/content/bindings/menu.xml#menuitem">
     <content>
       <xul:hbox class="menu-iconic-left" align="center" pack="center"
                 xbl:inherits="selected,disabled,checked">
         <xul:image class="menu-iconic-icon" xbl:inherits="src=image,validate,src"/>
       </xul:hbox>
       <xul:label class="menu-iconic-text" flex="1" xbl:inherits="value=label,accesskey,crop" crop="right"/>
     </content>
diff --git a/toolkit/content/widgets/menulist.xml b/toolkit/content/widgets/menulist.xml
--- a/toolkit/content/widgets/menulist.xml
+++ b/toolkit/content/widgets/menulist.xml
@@ -540,16 +540,23 @@
                                          else this.removeAttribute('readonly'); return val;"
                                   onget="return this.inputField.readOnly;"/>
 
       <method name="select">
         <body>
           this.inputField.select();
         </body>
       </method>
+
+      <method name="getChild">
+        <parameter name="aChildName"/>
+        <body><![CDATA[
+          return document.getAnonymousElementByAttribute(this, "anonid", aChildName);
+        ]]></body>
+      </method>
     </implementation>
 
     <handlers>
       <handler event="focus" phase="capturing">
         <![CDATA[
           this.setAttribute("focused", "true");
         ]]>
       </handler>
@@ -574,24 +581,40 @@
               // For now, only do this when the outermost menupopup opens.
               this.menuBoxObject.activeChild = this.mSelectedInternal;
           }
         ]]>
       </handler>
 
       <handler event="keypress">
         <![CDATA[
+          if (event.ctrlKey && event.shiftKey)
+            return;
+
+          if (this.getAttribute("bgtype") == "csslength") {
+            var _self = this;
+            if (event.keyCode == KeyEvent.DOM_VK_UP) {
+              IncreaseLength(this, this.getAttribute("units"));
+              if (this.oninput)
+                this.oninput.call(_self);
+              event.preventDefault();
+            }
+            else if (event.keyCode == KeyEvent.DOM_VK_DOWN) {
+              DecreaseLength(this, this.getAttribute("units"), !(this.getAttribute("unsigned") == "true"));
+              if (this.oninput)
+                this.oninput.call(_self);
+              event.preventDefault();
+            }
+          }
           // open popup if key is up arrow, down arrow, or F4
-          if (!event.ctrlKey && !event.shiftKey) {
-            if (event.keyCode == KeyEvent.DOM_VK_UP ||
-                event.keyCode == KeyEvent.DOM_VK_DOWN ||
-                (event.keyCode == KeyEvent.DOM_VK_F4 && !event.altKey)) {
-              event.preventDefault();
-              this.open = true;
-            }
+          else if (event.keyCode == KeyEvent.DOM_VK_UP ||
+                   event.keyCode == KeyEvent.DOM_VK_DOWN ||
+                   (event.keyCode == KeyEvent.DOM_VK_F4 && !event.altKey)) {
+            event.preventDefault();
+            this.open = true;
           }
         ]]>
       </handler>
     </handlers>
   </binding>
 
   <binding id="menulist-description" display="xul:menu"
            extends="chrome://global/content/bindings/menulist.xml#menulist">
diff --git a/toolkit/content/widgets/tree.xml b/toolkit/content/widgets/tree.xml
--- a/toolkit/content/widgets/tree.xml
+++ b/toolkit/content/widgets/tree.xml
@@ -737,17 +737,18 @@
       <handler event="MozSwipeGesture" preventdefault="true">
         <![CDATA[
           // Figure out which row to show
           let targetRow = 0;
 
           // Only handle swipe gestures up and down
           switch (event.direction) {
             case event.DIRECTION_DOWN:
-              targetRow = this.view.rowCount - 1;
+              if (this.view)
+                targetRow = this.view.rowCount - 1;
               // Fall through for actual action
             case event.DIRECTION_UP:
               this.treeBoxObject.ensureRowIsVisible(targetRow);
               break;
           }
         ]]>
       </handler>
       <handler event="select" phase="target"
@@ -1487,35 +1488,36 @@
           <![CDATA[
             // We no longer cache the picker content, remove the old content.
             while (aPopup.childNodes.length > 2)
               aPopup.firstChild.remove();
 
             var refChild = aPopup.firstChild;
 
             var tree = this.parentNode.parentNode;
-            for (var currCol = tree.columns.getFirstColumn(); currCol;
-                 currCol = currCol.getNext()) {
-              // Construct an entry for each column in the row, unless
-              // it is not being shown.
-              var currElement = currCol.element;
-              if (!currElement.hasAttribute("ignoreincolumnpicker")) {
-                var popupChild = document.createElement("menuitem");
-                popupChild.setAttribute("type", "checkbox");
-                var columnName = currElement.getAttribute("display") ||
-                                 currElement.getAttribute("label");
-                popupChild.setAttribute("label", columnName);
-                popupChild.setAttribute("colindex", currCol.index);
-                if (currElement.getAttribute("hidden") != "true")
-                  popupChild.setAttribute("checked", "true");
-                if (currCol.primary)
-                  popupChild.setAttribute("disabled", "true");
-                aPopup.insertBefore(popupChild, refChild);
+            if (tree.columns) // sanity case
+              for (var currCol = tree.columns.getFirstColumn(); currCol;
+                   currCol = currCol.getNext()) {
+                // Construct an entry for each column in the row, unless
+                // it is not being shown.
+                var currElement = currCol.element;
+                if (!currElement.hasAttribute("ignoreincolumnpicker")) {
+                  var popupChild = document.createElement("menuitem");
+                  popupChild.setAttribute("type", "checkbox");
+                  var columnName = currElement.getAttribute("display") ||
+                                   currElement.getAttribute("label");
+                  popupChild.setAttribute("label", columnName);
+                  popupChild.setAttribute("colindex", currCol.index);
+                  if (currElement.getAttribute("hidden") != "true")
+                    popupChild.setAttribute("checked", "true");
+                  if (currCol.primary)
+                    popupChild.setAttribute("disabled", "true");
+                  aPopup.insertBefore(popupChild, refChild);
+                }
               }
-            }
 
             var hidden = !tree.enableColumnDrag;
             const anonids = ["menuseparator", "menuitem"];
             for (var i = 0; i < anonids.length; i++) {
               var element = document.getAnonymousElementByAttribute(this, "anonid", anonids[i]);
               element.hidden = hidden;
             }
           ]]>
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -369,16 +369,20 @@ menubar > menu:empty {
 menuitem {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem");
 }
 
 menuitem.menuitem-iconic {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic");
 }
 
+menuitem.menuitem-non-iconic-accel {
+  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-non-iconic-accel");
+}
+
 menuitem[description] {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic-desc-noaccel");
 }
 
 menuitem[type="checkbox"],
 menuitem[type="radio"] {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic");
 }
diff --git a/toolkit/mozapps/extensions/content/extensions.js b/toolkit/mozapps/extensions/content/extensions.js
--- a/toolkit/mozapps/extensions/content/extensions.js
+++ b/toolkit/mozapps/extensions/content/extensions.js
@@ -47,16 +47,17 @@ XPCOMUtils.defineLazyPreferenceGetter(th
 const PREF_DISCOVERURL = "extensions.webservice.discoverURL";
 const PREF_DISCOVER_ENABLED = "extensions.getAddons.showPane";
 const PREF_XPI_ENABLED = "xpinstall.enabled";
 const PREF_MAXRESULTS = "extensions.getAddons.maxResults";
 const PREF_GETADDONS_CACHE_ENABLED = "extensions.getAddons.cache.enabled";
 const PREF_GETADDONS_CACHE_ID_ENABLED = "extensions.%ID%.getAddons.cache.enabled";
 const PREF_UI_TYPE_HIDDEN = "extensions.ui.%TYPE%.hidden";
 const PREF_UI_LASTCATEGORY = "extensions.ui.lastCategory";
+const PREF_CLOSE_ADDONS_MANAGER_ON_ESCAPE = "extensions.closeOnEscape";
 
 const LOADING_MSG_DELAY = 100;
 
 const SEARCH_SCORE_MULTIPLIER_NAME = 2;
 const SEARCH_SCORE_MULTIPLIER_DESCRIPTION = 2;
 
 // Use integers so search scores are sortable by nsIXULSortService
 const SEARCH_SCORE_MATCH_WHOLEWORD = 10;
@@ -192,16 +193,27 @@ Object.defineProperty(this, "gIsInitiali
 function initialize(event) {
   // XXXbz this listener gets _all_ load events for all nodes in the
   // document... but relies on not being called "too early".
   if (event.target instanceof XMLStylesheetProcessingInstruction) {
     return;
   }
   document.removeEventListener("load", initialize, true);
 
+  // should we allow the window to close when the user hits the ESC key?
+  let closeOnEscape = false; // default for Firefox 4+
+  try {
+    closeOnEscape = Services.prefs.getBoolPref(PREF_CLOSE_ADDONS_MANAGER_ON_ESCAPE);
+  } catch(e) { }
+  if (!closeOnEscape) {
+    let escapeKeyElt = document.getElementById("escapeKey");
+    if (escapeKeyElt)
+      escapeKeyElt.setAttribute("disabled", "true");
+  }
+
   let globalCommandSet = document.getElementById("globalCommandSet");
   globalCommandSet.addEventListener("command", function(event) {
     gViewController.doCommand(event.target.id);
   });
 
   let viewCommandSet = document.getElementById("viewCommandSet");
   viewCommandSet.addEventListener("commandupdate", function(event) {
     gViewController.updateCommands();
@@ -2986,17 +2998,17 @@ var gListView = {
     this._listBox.insertBefore(item, this._listBox.firstChild);
     this.showEmptyNotice(false);
   },
 
   removeItem(aObj, aIsInstall) {
     let prop = aIsInstall ? "mInstall" : "mAddon";
 
     for (let item of this._listBox.childNodes) {
-      if (item[prop] == aObj) {
+      if (prop in item && item[prop] == aObj) {
         this._listBox.removeChild(item);
         this.showEmptyNotice(this._listBox.itemCount == 0);
         return;
       }
     }
   },
 
   getSelectedAddon() {
diff --git a/toolkit/mozapps/extensions/content/extensions.xul b/toolkit/mozapps/extensions/content/extensions.xul
--- a/toolkit/mozapps/extensions/content/extensions.xul
+++ b/toolkit/mozapps/extensions/content/extensions.xul
@@ -23,16 +23,20 @@
   <xhtml:link rel="shortcut icon"
               href="chrome://mozapps/skin/extensions/extensionGeneric-16.png"/>
 
   <script type="application/javascript"
           src="chrome://mozapps/content/extensions/extensions.js"/>
   <script type="application/javascript"
           src="chrome://global/content/contentAreaUtils.js"/>
 
+  <keyset>
+    <key id="escapeKey" keycode="VK_ESCAPE" oncommand="window.close()"/>
+  </keyset>
+
   <popupset>
     <!-- menu for an addon item -->
     <menupopup id="addonitem-popup">
       <menuitem id="menuitem_showDetails" command="cmd_showItemDetails"
                 default="true" label="&cmd.showDetails.label;"
                 accesskey="&cmd.showDetails.accesskey;"/>
       <menuitem id="menuitem_enableItem" command="cmd_enableItem"
                 label="&cmd.enableAddon.label;"
diff --git a/toolkit/mozapps/extensions/internal/XPIProvider.jsm b/toolkit/mozapps/extensions/internal/XPIProvider.jsm
--- a/toolkit/mozapps/extensions/internal/XPIProvider.jsm
+++ b/toolkit/mozapps/extensions/internal/XPIProvider.jsm
@@ -1361,16 +1361,22 @@ let loadManifestFromRDF = Task.async(fun
   // icons will be filled by the calling function
   addon.icons = {};
   addon.userPermissions = null;
 
   return addon;
 });
 
 function defineSyncGUID(aAddon) {
+  try {
+    // BLUEGRIFFON BMO bug 1277295
+    let storage = Services.storage;
+  }
+  catch(e) {}
+
   // Define .syncGUID as a lazy property which is also settable
   Object.defineProperty(aAddon, "syncGUID", {
     get: () => {
       // Generate random GUID used for Sync.
       let guid = Cc["@mozilla.org/uuid-generator;1"]
           .getService(Ci.nsIUUIDGenerator)
           .generateUUID().toString();
 
diff --git a/toolkit/mozapps/handling/nsContentDispatchChooser.js b/toolkit/mozapps/handling/nsContentDispatchChooser.js
--- a/toolkit/mozapps/handling/nsContentDispatchChooser.js
+++ b/toolkit/mozapps/handling/nsContentDispatchChooser.js
@@ -57,22 +57,54 @@ nsContentDispatchChooser.prototype =
       let string = new SupportsString;
       string.data = text;
       params.appendElement(string, false);
     }
     params.appendElement(aHandler, false);
     params.appendElement(aURI, false);
     params.appendElement(aWindowContext, false);
 
+    // if a modal window is already shown, we need to open the app chooser
+    // as a modal window otherwise it will be unresponsive; bug 687423
+    var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+               getService(Ci.nsIWindowMediator);
+    var enumerator = wm.getXULWindowEnumerator(null);
+    var inModalState = false;
+    while (!inModalState && enumerator.hasMoreElements()) {
+      var win = enumerator.getNext();
+      var windowDocShell = win.QueryInterface(Ci.nsIXULWindow).docShell;
+  
+      var containedDocShells = windowDocShell.getDocShellEnumerator(
+                                        Ci.nsIDocShellTreeItem.typeChrome,
+                                        Ci.nsIDocShell.ENUMERATE_FORWARDS);
+
+      while (!inModalState && containedDocShells.hasMoreElements()) {
+        // Get the corresponding document for this docshell
+        var childDocShell = containedDocShells.getNext();
+
+        // We don't want it if it's not done loading.
+        if (childDocShell.busyFlags != Ci.nsIDocShell.BUSY_FLAGS_NONE)
+          continue;
+
+        // Ensure that we are only returning true if it is indeed modal
+        var chrome = win.QueryInterface(Ci.nsIInterfaceRequestor).
+                         getInterface(Ci.nsIWebBrowserChrome);
+        if (chrome.isWindowModal()) {
+          inModalState = true;
+        }
+      }
+    }
+
     var ww = Cc["@mozilla.org/embedcomp/window-watcher;1"].
              getService(Ci.nsIWindowWatcher);
     ww.openWindow(window,
                   CONTENT_HANDLING_URL,
                   null,
-                  "chrome,dialog=yes,resizable,centerscreen",
+                  "chrome,dialog=yes,resizable,centerscreen"
+                    + (inModalState ? ",modal" : ""),
                   params);
   },
 
   // nsISupports
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIContentDispatchChooser])
 };
 
diff --git a/toolkit/mozapps/installer/packager.mk b/toolkit/mozapps/installer/packager.mk
--- a/toolkit/mozapps/installer/packager.mk
+++ b/toolkit/mozapps/installer/packager.mk
@@ -48,17 +48,17 @@ stage-package: $(MOZ_PKG_MANIFEST) $(MOZ
 		$(if $(MOZ_PACKAGER_MINIFY_JS),--minify-js \
 		  $(addprefix --js-binary ,$(JS_BINARY)) \
 		) \
 		$(if $(JARLOG_DIR),$(addprefix --jarlog ,$(wildcard $(JARLOG_FILE_AB_CD)))) \
 		$(if $(OPTIMIZEJARS),--optimizejars) \
 		$(if $(DISABLE_JAR_COMPRESSION),--disable-compression) \
 		$(MOZ_PKG_MANIFEST) $(DIST) $(DIST)/$(MOZ_PKG_DIR)$(if $(MOZ_PKG_MANIFEST),,$(_BINPATH)) \
 		$(if $(filter omni,$(MOZ_PACKAGER_FORMAT)),$(if $(NON_OMNIJAR_FILES),--non-resource $(NON_OMNIJAR_FILES)))
-	$(PYTHON) $(MOZILLA_DIR)/toolkit/mozapps/installer/find-dupes.py $(DEFINES) $(ACDEFINES) $(MOZ_PKG_DUPEFLAGS) $(DIST)/$(MOZ_PKG_DIR)
+#	$(PYTHON) $(MOZILLA_DIR)/toolkit/mozapps/installer/find-dupes.py $(DEFINES) $(ACDEFINES) $(MOZ_PKG_DUPEFLAGS) $(DIST)/$(MOZ_PKG_DIR)
 ifndef MOZ_THUNDERBIRD
 	# Package mozharness
 	$(call py_action,test_archive, \
 		mozharness \
 		$(ABS_DIST)/$(PKG_PATH)$(MOZHARNESS_PACKAGE))
 endif # MOZ_THUNDERBIRD
 ifdef MOZ_PACKAGE_JSSHELL
 	# Package JavaScript Shell
diff --git a/toolkit/toolkit.mozbuild b/toolkit/toolkit.mozbuild
--- a/toolkit/toolkit.mozbuild
+++ b/toolkit/toolkit.mozbuild
@@ -151,26 +151,26 @@ if CONFIG['MOZ_RUST']:
 DIRS += [
     '/toolkit/library/StaticXULComponentsEnd',
     '/toolkit/library',
 ]
 
 if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']:
     DIRS += ['/toolkit/system/gnome']
 
-DIRS += ['/addon-sdk']
+#DIRS += ['/addon-sdk']
 
 if CONFIG['ENABLE_MARIONETTE']:
     DIRS += [
         '/testing/firefox-ui',
         '/testing/marionette',
     ]
 
 DIRS += [
-    '/tools/quitter',
+#    '/tools/quitter',
     '/media/gmp-clearkey/0.1',
 ]
 
 if CONFIG['ENABLE_TESTS']:
     DIRS += [
         '/testing/mochitest',
         '/testing/xpcshell',
         '/testing/tools/minidumpwriter',
diff --git a/widget/PuppetWidget.cpp b/widget/PuppetWidget.cpp
--- a/widget/PuppetWidget.cpp
+++ b/widget/PuppetWidget.cpp
@@ -1426,16 +1426,23 @@ NS_IMETHODIMP
 PuppetScreenManager::ScreenForId(uint32_t aId,
                                  nsIScreen** outScreen)
 {
   NS_IF_ADDREF(*outScreen = mOneScreen.get());
   return NS_OK;
 }
 
 NS_IMETHODIMP
+PuppetScreenManager::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+  NS_IF_ADDREF(*outScreen = mOneScreen.get());
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 PuppetScreenManager::GetPrimaryScreen(nsIScreen** outScreen)
 {
   NS_IF_ADDREF(*outScreen = mOneScreen.get());
   return NS_OK;
 }
 
 NS_IMETHODIMP
 PuppetScreenManager::ScreenForRect(int32_t inLeft,
@@ -1583,8 +1590,9 @@ PuppetWidget::OnWindowedPluginKeyEvent(c
     return NS_ERROR_FAILURE;
   }
   mKeyEventInPluginCallbacks.AppendElement(aCallback);
   return NS_SUCCESS_EVENT_HANDLED_ASYNCHRONOUSLY;
 }
 
 } // namespace widget
 } // namespace mozilla
+
diff --git a/widget/cocoa/nsClipboard.mm b/widget/cocoa/nsClipboard.mm
--- a/widget/cocoa/nsClipboard.mm
+++ b/widget/cocoa/nsClipboard.mm
@@ -19,16 +19,17 @@
 #include "nsIFile.h"
 #include "nsStringStream.h"
 #include "nsDragService.h"
 #include "nsEscape.h"
 #include "nsPrintfCString.h"
 #include "nsObjCExceptions.h"
 #include "imgIContainer.h"
 #include "nsCocoaUtils.h"
+#include "mozilla/Preferences.h"
 
 using mozilla::gfx::DataSourceSurface;
 using mozilla::gfx::SourceSurface;
 using mozilla::LogLevel;
 
 #define IMAGE_PASTEBOARD_TYPES NSPasteboardTypeTIFF, \
                                NSPasteboardTypePNG, \
                                nil
@@ -170,17 +171,45 @@ nsClipboard::TransferableFromPasteboard(
     NSString *pboardType = nil;
     if (nsClipboard::IsStringType(flavorStr, &pboardType)) {
       NSString* pString = [cocoaPasteboard stringForType:pboardType];
       if (!pString)
         continue;
 
       NSData* stringData;
       if ([pboardType isEqualToString:NSPasteboardTypeRTF]) {
+        // get a NSAttributedString for RTF data
+        NSDictionary *docAttributes;
         stringData = [pString dataUsingEncoding:NSASCIIStringEncoding];
+        if (mozilla::Preferences::GetBool("bluegriffon.osx.clipboard.rtf.enabled")) {
+          NSAttributedString *attrString = [[NSAttributedString alloc]
+                         initWithRTF: stringData
+                  documentAttributes: &docAttributes];
+
+          // then convert it to HTML excluding the document's outermost elements
+          // and the ones we can't deal with ; but don't exclude <body> because
+          // the editor relies on it to paste a html-based transferable
+          NSArray * exclude = [NSArray arrayWithObjects:@"doctype",
+                               @"html",
+                               @"head",
+                               @"xml",
+                               nil
+                               ];
+          NSDictionary * htmlAtt = [NSDictionary
+                                    dictionaryWithObjectsAndKeys:NSHTMLTextDocumentType,
+                                    NSDocumentTypeDocumentAttribute,
+                                    exclude,
+                                    NSExcludedElementsDocumentAttribute,
+                                    nil
+                                    ];
+          NSError * error;
+          stringData = [attrString dataFromRange:NSMakeRange(0, [attrString length])
+                                     documentAttributes:htmlAtt error:&error
+                               ];
+        }
       } else {
         stringData = [pString dataUsingEncoding:NSUnicodeStringEncoding];
       }
       unsigned int dataLength = [stringData length];
       void* clipboardDataPtr = malloc(dataLength);
       if (!clipboardDataPtr)
         return NS_ERROR_OUT_OF_MEMORY;
       [stringData getBytes:clipboardDataPtr];
diff --git a/widget/cocoa/nsCocoaUtils.mm b/widget/cocoa/nsCocoaUtils.mm
--- a/widget/cocoa/nsCocoaUtils.mm
+++ b/widget/cocoa/nsCocoaUtils.mm
@@ -301,18 +301,22 @@ void nsCocoaUtils::PrepareForNativeAppMo
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 
   // Don't do anything if this is embedding. We'll assume that if there is no hidden
   // window we shouldn't do anything, and that should cover the embedding case.
   nsMenuBarX* hiddenWindowMenuBar = nsMenuUtilsX::GetHiddenWindowMenuBar();
   if (!hiddenWindowMenuBar)
     return;
 
+  // XXX BLUEGRIFFON ; do NOT paint the hidden menubar because otherwise, that's
+  // what's show when you close a filepicker... And in that case, menus are mostly
+  // disabled and inable to operate even on a visible window...
+   // First put up the hidden window menu bar so that app menu event handling is correct.
   // First put up the hidden window menu bar so that app menu event handling is correct.
-  hiddenWindowMenuBar->Paint();
+  //hiddenWindowMenuBar->Paint();
 
   NSMenu* mainMenu = [NSApp mainMenu];
   NS_ASSERTION([mainMenu numberOfItems] > 0, "Main menu does not have any items, something is terribly wrong!");
   
   // Create new menu bar for use with modal dialog
   NSMenu* newMenuBar = [[NSMenu alloc] initWithTitle:@""];
   
   // Swap in our app menu. Note that the event target is whatever window is up when
diff --git a/widget/cocoa/nsColorPicker.h b/widget/cocoa/nsColorPicker.h
--- a/widget/cocoa/nsColorPicker.h
+++ b/widget/cocoa/nsColorPicker.h
@@ -17,17 +17,17 @@ class mozIDOMWindowProxy;
 @class NSColor;
 
 class nsColorPicker final : public nsIColorPicker
 {
 public:
   NS_DECL_ISUPPORTS
 
   NS_IMETHOD Init(mozIDOMWindowProxy* aParent, const nsAString& aTitle,
-                  const nsAString& aInitialColor) override;
+                  const nsAString& aInitialColor, bool aShowAlpha) override;
   NS_IMETHOD Open(nsIColorPickerShownCallback* aCallback) override;
 
   // For NSColorPanelWrapper.
   void Update(NSColor* aColor);
   // Call this method if you are done with this input, but the color picker needs to
   // stay open as it will be associated to another input
   void DoneWithRetarget();
   // Same as DoneWithRetarget + clean the static instance of sColorPanelWrapper,
@@ -39,12 +39,13 @@ private:
 
   static NSColor* GetNSColorFromHexString(const nsAString& aColor);
   static void GetHexStringFromNSColor(NSColor* aColor, nsAString& aResult);
 
   static NSColorPanelWrapper* sColorPanelWrapper;
 
   nsString             mTitle;
   nsString             mColor;
+  bool               mShowsAlpha;
   nsCOMPtr<nsIColorPickerShownCallback> mCallback;
 };
 
 #endif // nsColorPicker_h_
diff --git a/widget/cocoa/nsColorPicker.mm b/widget/cocoa/nsColorPicker.mm
--- a/widget/cocoa/nsColorPicker.mm
+++ b/widget/cocoa/nsColorPicker.mm
@@ -4,16 +4,18 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #import <Cocoa/Cocoa.h>
 
 #include "nsColorPicker.h"
 #include "nsCocoaUtils.h"
 #include "nsThreadUtils.h"
 
+#include "nsCSSParser.h"
+
 using namespace mozilla;
 
 static unsigned int
 HexStrToInt(NSString* str)
 {
   unsigned int result = 0;
 
   for (unsigned int i = 0; i < [str length]; ++i) {
@@ -32,39 +34,40 @@ HexStrToInt(NSString* str)
 }
 
 @interface NSColorPanelWrapper : NSObject <NSWindowDelegate>
 {
   NSColorPanel*  mColorPanel;
   nsColorPicker* mColorPicker;
 }
 - (id)initWithPicker:(nsColorPicker*)aPicker;
-- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle;
+- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle showsAlpha:(BOOL)aShowsAlpha;
 - (void)retarget:(nsColorPicker*)aPicker;
 - (void)colorChanged:(NSColorPanel*)aPanel;
 @end
 
 @implementation NSColorPanelWrapper
 - (id)initWithPicker:(nsColorPicker*)aPicker
 {
   mColorPicker = aPicker;
   mColorPanel = [NSColorPanel sharedColorPanel];
 
   self = [super init];
   return self;
 }
 
-- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle
+- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle showsAlpha:(BOOL)aShowsAlpha
 {
   [mColorPanel setTitle:aTitle];
   [mColorPanel setColor:aInitialColor];
   [mColorPanel setTarget:self];
+  [mColorPanel setShowsAlpha:aShowsAlpha];
   [mColorPanel setAction:@selector(colorChanged:)];
   [mColorPanel setDelegate:self];
-  [mColorPanel makeKeyAndOrderFront:nil];
+  [mColorPanel orderFront:nil];
 }
 
 - (void)colorChanged:(NSColorPanel*)aPanel
 {
   mColorPicker->Update([mColorPanel color]);
 }
 
 - (void)windowWillClose:(NSNotification*)aNotification
@@ -98,83 +101,100 @@ NS_IMPL_ISUPPORTS(nsColorPicker, nsIColo
 NSColorPanelWrapper* nsColorPicker::sColorPanelWrapper = nullptr;
 
 nsColorPicker::~nsColorPicker()
 {
 }
 
 NS_IMETHODIMP
 nsColorPicker::Init(mozIDOMWindowProxy* aParent, const nsAString& aTitle,
-                    const nsAString& aInitialColor)
+                    const nsAString& aInitialColor, bool aShowAlpha)
 {
   MOZ_ASSERT(NS_IsMainThread(),
       "Color pickers can only be opened from main thread currently");
   mTitle = aTitle;
   mColor = aInitialColor;
+  mShowsAlpha = aShowAlpha;
 
   if (sColorPanelWrapper) {
     // Update current wrapper to target the new input instead
     [sColorPanelWrapper retarget:this];
   } else {
     // Create a brand new color panel wrapper
     sColorPanelWrapper = [[NSColorPanelWrapper alloc] initWithPicker:this];
   }
   return NS_OK;
 }
 
 /* static */ NSColor*
 nsColorPicker::GetNSColorFromHexString(const nsAString& aColor)
 {
-  NSString* str = nsCocoaUtils::ToNSString(aColor);
+  nsCSSValue value;
+  nsCSSParser parser;
+  if (!parser.ParseColorString(aColor, nullptr, 0, value)) {
+    return [NSColor colorWithDeviceRed: 0 green: 0 blue: 0 alpha: 1];
+  }
 
-  double red = HexStrToInt([str substringWithRange:NSMakeRange(1, 2)]) / 255.0;
-  double green = HexStrToInt([str substringWithRange:NSMakeRange(3, 2)]) / 255.0;
-  double blue = HexStrToInt([str substringWithRange:NSMakeRange(5, 2)]) / 255.0;
+  nscolor color;
+  if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
+    return [NSColor colorWithDeviceRed: 0 green: 0 blue: 0 alpha: 1];
+  }
 
-  return [NSColor colorWithDeviceRed: red green: green blue: blue alpha: 1.0];
+  return [NSColor colorWithRed: ((float)NS_GET_R(color))/255.0
+                         green: ((float)NS_GET_G(color))/255.0
+                          blue: ((float)NS_GET_B(color))/255.0
+                         alpha: ((float)NS_GET_A(color))/255.0];
 }
 
 /* static */ void
 nsColorPicker::GetHexStringFromNSColor(NSColor* aColor, nsAString& aResult)
 {
-  CGFloat redFloat, greenFloat, blueFloat;
-
-  NSColor* color = aColor;
-  @try {
-    [color getRed:&redFloat green:&greenFloat blue:&blueFloat alpha: nil];
-  } @catch (NSException* e) {
-    color = [color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
-    [color getRed:&redFloat green:&greenFloat blue:&blueFloat alpha: nil];
+  CGFloat redFloat, greenFloat, blueFloat, alphaFloat;
+  [aColor getRed: &redFloat green: &greenFloat blue: &blueFloat alpha: &alphaFloat];
+  if (alphaFloat < 1.0f) {
+    nsCocoaUtils::GetStringForNSString([NSString stringWithFormat:@"rgba(%d, %d, %d, %1.2f)",
+                                         (int)(redFloat * 255 + 0.5f),
+                                         (int)(greenFloat * 255 + 0.5f),
+                                         (int)(blueFloat * 255 + 0.5f),
+                                         (float) alphaFloat],
+                                       aResult);
   }
-
-  nsCocoaUtils::GetStringForNSString([NSString stringWithFormat:@"#%02x%02x%02x",
-                                       (int)(redFloat * 255),
-                                       (int)(greenFloat * 255),
-                                       (int)(blueFloat * 255)],
-                                     aResult);
+  else {
+    nsCocoaUtils::GetStringForNSString([NSString stringWithFormat:@"#%02x%02x%02x",
+                                         (int)(redFloat * 255 + 0.5f),
+                                         (int)(greenFloat * 255 + 0.5f),
+                                         (int)(blueFloat * 255 + 0.5f)],
+                                       aResult);
+  }
 }
 
 NS_IMETHODIMP
 nsColorPicker::Open(nsIColorPickerShownCallback* aCallback)
 {
   MOZ_ASSERT(aCallback);
   mCallback = aCallback;
 
   [sColorPanelWrapper open:GetNSColorFromHexString(mColor)
-              title:nsCocoaUtils::ToNSString(mTitle)];
+              title:nsCocoaUtils::ToNSString(mTitle)
+              showsAlpha:mShowsAlpha];
 
   NS_ADDREF_THIS();
 
   return NS_OK;
 }
 
 void
 nsColorPicker::Update(NSColor* aColor)
 {
-  GetHexStringFromNSColor(aColor, mColor);
+  NSColor *color = aColor;
+  if ([[aColor colorSpaceName] isEqualToString:NSNamedColorSpace])        {
+    color = [aColor colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
+  }
+
+  GetHexStringFromNSColor(color, mColor);
   mCallback->Update(mColor);
 }
 
 void
 nsColorPicker::DoneWithRetarget()
 {
   mCallback->Done(EmptyString());
   mCallback = nullptr;
diff --git a/widget/cocoa/nsMenuItemX.mm b/widget/cocoa/nsMenuItemX.mm
--- a/widget/cocoa/nsMenuItemX.mm
+++ b/widget/cocoa/nsMenuItemX.mm
@@ -254,16 +254,39 @@ void nsMenuItemX::SetKeyEquiv()
         }
       }
 
       nsAutoString modifiersStr;
       keyContent->GetAttr(kNameSpaceID_None, nsGkAtoms::modifiers, modifiersStr);
       uint8_t modifiers = nsMenuUtilsX::GeckoModifiersForNodeAttribute(modifiersStr);
 
       unsigned int macModifiers = nsMenuUtilsX::MacModifiersForGeckoModifiers(modifiers);
+      // If we're empty, try the keyCode instead.
+      if (keyChar.Equals(NS_LITERAL_STRING(" ")) || keyChar.IsEmpty()) {
+
+        keyContent->GetAttr(kNameSpaceID_None, nsGkAtoms::keycode, keyChar);
+
+        if (keyChar.Equals(NS_LITERAL_STRING("VK_F2"))) {
+          unichar ch[1];
+          ch[0] = NSF2FunctionKey;
+          macModifiers |= NSFunctionKeyMask;
+          [mNativeMenuItem setKeyEquivalentModifierMask:macModifiers];
+          [mNativeMenuItem setKeyEquivalent:[NSString stringWithCharacters:ch length:1]];
+          return;
+        }
+        else if (keyChar.Equals(NS_LITERAL_STRING("VK_F4"))) {
+          unichar ch[1];
+          ch[0] = NSF4FunctionKey;
+          macModifiers |= NSFunctionKeyMask;
+          [mNativeMenuItem setKeyEquivalentModifierMask:macModifiers];
+          [mNativeMenuItem setKeyEquivalent:[NSString stringWithCharacters:ch length:1]];
+          return;
+        }
+      }
+
       [mNativeMenuItem setKeyEquivalentModifierMask:macModifiers];
 
       NSString *keyEquivalent = [[NSString stringWithCharacters:(unichar*)keyChar.get()
                                                          length:keyChar.Length()] lowercaseString];
       if ([keyEquivalent isEqualToString:@" "])
         [mNativeMenuItem setKeyEquivalent:@""];
       else
         [mNativeMenuItem setKeyEquivalent:keyEquivalent];
diff --git a/widget/cocoa/nsNativeThemeCocoa.mm b/widget/cocoa/nsNativeThemeCocoa.mm
--- a/widget/cocoa/nsNativeThemeCocoa.mm
+++ b/widget/cocoa/nsNativeThemeCocoa.mm
@@ -2594,17 +2594,17 @@ nsNativeThemeCocoa::DrawWidgetBackground
     }
       break;
 
     case NS_THEME_WINDOW_TITLEBAR: {
       NSWindow* win = NativeWindowForFrame(aFrame);
       BOOL isMain = [win isMainWindow];
       float unifiedToolbarHeight = [win isKindOfClass:[ToolbarWindow class]] ?
         [(ToolbarWindow*)win unifiedToolbarHeight] : macRect.size.height;
-      DrawNativeTitlebar(cgContext, macRect, unifiedToolbarHeight, isMain, YES);
+      // DrawNativeTitlebar(cgContext, macRect, unifiedToolbarHeight, isMain, YES);
     }
       break;
 
     case NS_THEME_STATUSBAR: 
       DrawStatusBar(cgContext, macRect, aFrame);
       break;
 
     case NS_THEME_MENULIST:
diff --git a/widget/cocoa/nsScreenManagerCocoa.mm b/widget/cocoa/nsScreenManagerCocoa.mm
--- a/widget/cocoa/nsScreenManagerCocoa.mm
+++ b/widget/cocoa/nsScreenManagerCocoa.mm
@@ -145,8 +145,28 @@ nsScreenManagerCocoa::ScreenForNativeWid
         return NS_OK;
     }
 
     *outScreen = nullptr;
     return NS_OK;
 
     NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
+
+NS_IMETHODIMP
+nsScreenManagerCocoa::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+    NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
+
+    uint32_t numberOfScreens;
+    GetNumberOfScreens(&numberOfScreens);
+    if (aIndex >= numberOfScreens)
+        return NS_ERROR_FAILURE;
+  
+    NSScreen *sc = [[NSScreen screens] objectAtIndex: aIndex];
+  
+    *outScreen = ScreenForCocoaScreen(sc);
+    NS_ADDREF(*outScreen);
+  
+    return NS_OK;
+  
+    NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+}
diff --git a/widget/gtk/mozgtk/mozgtk.c b/widget/gtk/mozgtk/mozgtk.c
--- a/widget/gtk/mozgtk/mozgtk.c
+++ b/widget/gtk/mozgtk/mozgtk.c
@@ -159,19 +159,21 @@ STUB(gtk_clipboard_get)
 STUB(gtk_clipboard_request_contents)
 STUB(gtk_clipboard_request_text)
 STUB(gtk_clipboard_set_can_store)
 STUB(gtk_clipboard_set_with_data)
 STUB(gtk_clipboard_store)
 STUB(gtk_color_selection_dialog_get_color_selection)
 STUB(gtk_color_selection_dialog_get_type)
 STUB(gtk_color_selection_dialog_new)
+STUB(gtk_color_selection_get_current_alpha)
 STUB(gtk_color_selection_get_current_color)
 STUB(gtk_color_selection_get_type)
 STUB(gtk_color_selection_set_current_color)
+STUB(gtk_color_selection_set_has_opacity_control)
 STUB(gtk_combo_box_get_active)
 STUB(gtk_combo_box_get_type)
 STUB(gtk_combo_box_new)
 STUB(gtk_combo_box_new_with_entry)
 STUB(gtk_combo_box_set_active)
 STUB(gtk_combo_box_text_get_type)
 STUB(gtk_combo_box_text_new)
 STUB(gtk_container_add)
diff --git a/widget/gtk/nsColorPicker.cpp b/widget/gtk/nsColorPicker.cpp
--- a/widget/gtk/nsColorPicker.cpp
+++ b/widget/gtk/nsColorPicker.cpp
@@ -7,16 +7,18 @@
 
 #include "nsColor.h"
 #include "nsColorPicker.h"
 #include "nsGtkUtils.h"
 #include "nsIWidget.h"
 #include "WidgetUtils.h"
 #include "nsPIDOMWindow.h"
 
+#include "nsCSSParser.h"
+
 NS_IMPL_ISUPPORTS(nsColorPicker, nsIColorPicker)
 
 #if defined(ACTIVATE_GTK3_COLOR_PICKER) && GTK_CHECK_VERSION(3,4,0)
 int nsColorPicker::convertGdkRgbaComponent(gdouble color_component) {
   // GdkRGBA value is in range [0.0..1.0]. We need something in range [0..255]
   return color_component * 255 + 0.5;
 }
 
@@ -55,38 +57,39 @@ GtkColorSelection* nsColorPicker::Widget
 {
   return GTK_COLOR_SELECTION(gtk_color_selection_dialog_get_color_selection(
                              GTK_COLOR_SELECTION_DIALOG(widget)));
 }
 #endif
 
 NS_IMETHODIMP nsColorPicker::Init(mozIDOMWindowProxy *aParent,
                                   const nsAString& title,
-                                  const nsAString& initialColor)
+                                  const nsAString& initialColor,
+                                  bool aShowsAlpha)
 {
   auto* parent = nsPIDOMWindowOuter::From(aParent);
   mParentWidget = mozilla::widget::WidgetUtils::DOMWindowToWidget(parent);
   mTitle = title;
   mInitialColor = initialColor;
+  mShowsAlpha = aShowsAlpha;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsColorPicker::Open(nsIColorPickerShownCallback *aColorPickerShownCallback)
 {
 
-  // Input color string should be 7 length (i.e. a string representing a valid
-  // simple color)
-  if (mInitialColor.Length() != 7) {
+  nsCSSValue value;
+  nsCSSParser parser;
+  if (!parser.ParseColorString(mInitialColor, nullptr, 0, value)) {
     return NS_ERROR_FAILURE;
   }
 
-  const nsAString& withoutHash  = StringTail(mInitialColor, 6);
   nscolor color;
-  if (!NS_HexToRGBA(withoutHash, nsHexColorType::NoAlpha, &color)) {
+  if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
     return NS_ERROR_FAILURE;
   }
 
   if (mCallback) {
     // It means Open has already been called: this is not allowed
     NS_WARNING("mCallback is already set. Open called twice?");
     return NS_ERROR_FAILURE;
   }
@@ -98,32 +101,34 @@ NS_IMETHODIMP nsColorPicker::Open(nsICol
   
 #if defined(ACTIVATE_GTK3_COLOR_PICKER) && GTK_CHECK_VERSION(3,4,0)
   GtkWidget* color_chooser = gtk_color_chooser_dialog_new(title, parent_window);
     
   if (parent_window) {
       gtk_window_set_destroy_with_parent(GTK_WINDOW(color_chooser), TRUE);
   }
   
-  gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(color_chooser), FALSE);
+  gtk_color_chooser_set_use_alpha(GTK_COLOR_CHOOSER(color_chooser), mShowsAlpha);
   GdkRGBA color_rgba = convertToRgbaColor(color);    
   gtk_color_chooser_set_rgba(GTK_COLOR_CHOOSER(color_chooser),
                              &color_rgba);
   
   g_signal_connect(GTK_COLOR_CHOOSER(color_chooser), "color-activated",
                    G_CALLBACK(OnColorChanged), this);
 #else
   GtkWidget *color_chooser = gtk_color_selection_dialog_new(title);
   
   if (parent_window) {
     GtkWindow *window = GTK_WINDOW(color_chooser);
     gtk_window_set_transient_for(window, parent_window);
     gtk_window_set_destroy_with_parent(window, TRUE);
   }
 
+  gtk_color_selection_set_has_opacity_control(WidgetGetColorSelection(color_chooser),
+                                              mShowsAlpha);
   GdkColor color_gdk = convertToGdkColor(color);
   gtk_color_selection_set_current_color(WidgetGetColorSelection(color_chooser),
                                         &color_gdk);
   
   g_signal_connect(WidgetGetColorSelection(color_chooser), "color-changed",
                    G_CALLBACK(OnColorChanged), this);
 #endif
 
@@ -177,20 +182,38 @@ nsColorPicker::Update(GtkColorSelection*
   }
 }
 
 void nsColorPicker::ReadValueFromColorSelection(GtkColorSelection* colorselection)
 {
   GdkColor rgba;
   gtk_color_selection_get_current_color(colorselection, &rgba);
 
-  mColor.Assign('#');
-  mColor += ToHexString(convertGdkColorComponent(rgba.red));
-  mColor += ToHexString(convertGdkColorComponent(rgba.green));
-  mColor += ToHexString(convertGdkColorComponent(rgba.blue));
+  guint16 alphaValue = 65535;
+  if (mShowsAlpha) {
+    alphaValue = gtk_color_selection_get_current_alpha(colorselection);
+  }
+
+  if (alphaValue == 65535) {
+    mColor.Assign('#');
+    mColor += ToHexString(convertGdkColorComponent(rgba.red));
+    mColor += ToHexString(convertGdkColorComponent(rgba.green));
+    mColor += ToHexString(convertGdkColorComponent(rgba.blue));
+  }
+  else {
+    mColor.AssignWithConversion("rgba(");
+    mColor.AppendInt(convertGdkColorComponent(rgba.red), 10);
+    mColor.AppendLiteral(", ");
+    mColor.AppendInt(convertGdkColorComponent(rgba.green), 10);
+    mColor.AppendLiteral(", ");
+    mColor.AppendInt(convertGdkColorComponent(rgba.blue), 10);
+    mColor.AppendLiteral(", ");
+    mColor.AppendFloat(((float)alphaValue / 65535));
+    mColor.AppendLiteral(")");
+  }
 }
 #endif
 
 /* static */ void
 nsColorPicker::OnResponse(GtkWidget* color_chooser, gint response_id,
                           gpointer user_data)
 {
   static_cast<nsColorPicker*>(user_data)->
diff --git a/widget/gtk/nsColorPicker.h b/widget/gtk/nsColorPicker.h
--- a/widget/gtk/nsColorPicker.h
+++ b/widget/gtk/nsColorPicker.h
@@ -63,11 +63,12 @@ private:
 
   void Done(GtkWidget* dialog, gint response_id);
 
   nsCOMPtr<nsIWidget> mParentWidget;
   nsCOMPtr<nsIColorPickerShownCallback> mCallback;
   nsString mTitle;
   nsString mColor;
   nsString mInitialColor;
+  bool mShowsAlpha;
 };
 
 #endif // nsColorPicker_h__
diff --git a/widget/gtk/nsScreenManagerGtk.cpp b/widget/gtk/nsScreenManagerGtk.cpp
--- a/widget/gtk/nsScreenManagerGtk.cpp
+++ b/widget/gtk/nsScreenManagerGtk.cpp
@@ -359,8 +359,20 @@ nsScreenManagerGtk :: ScreenForNativeWid
     gdk_window_get_origin(GDK_WINDOW(aWidget), &x, &y);
     rv = ScreenForRect(x, y, width, height, outScreen);
   } else {
     rv = GetPrimaryScreen(outScreen);
   }
 
   return rv;
 }
+
+NS_IMETHODIMP
+nsScreenManagerGtk::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+    uint32_t numberOfScreens;
+    GetNumberOfScreens(&numberOfScreens);
+    if (aIndex >= numberOfScreens)
+        return NS_ERROR_FAILURE;
+
+    NS_IF_ADDREF(*outScreen = mCachedScreenArray[aIndex]);
+    return NS_OK;
+}
diff --git a/widget/nsColorPickerProxy.cpp b/widget/nsColorPickerProxy.cpp
--- a/widget/nsColorPickerProxy.cpp
+++ b/widget/nsColorPickerProxy.cpp
@@ -9,26 +9,27 @@
 #include "mozilla/dom/TabChild.h"
 
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS(nsColorPickerProxy, nsIColorPicker)
 
 NS_IMETHODIMP
 nsColorPickerProxy::Init(mozIDOMWindowProxy* aParent, const nsAString& aTitle,
-                         const nsAString& aInitialColor)
+                         const nsAString& aInitialColor, bool aShowsAlpha)
 {
   TabChild* tabChild = TabChild::GetFrom(aParent);
   if (!tabChild) {
     return NS_ERROR_FAILURE;
   }
 
   tabChild->SendPColorPickerConstructor(this,
                                         nsString(aTitle),
-                                        nsString(aInitialColor));
+                                        nsString(aInitialColor),
+                                        aShowsAlpha);
   NS_ADDREF_THIS();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsColorPickerProxy::Open(nsIColorPickerShownCallback* aColorPickerShownCallback)
 {
   NS_ENSURE_STATE(!mCallback);
diff --git a/widget/nsIColorPicker.idl b/widget/nsIColorPicker.idl
--- a/widget/nsIColorPicker.idl
+++ b/widget/nsIColorPicker.idl
@@ -11,17 +11,17 @@ interface mozIDOMWindowProxy;
 /**
  * nsIColorPicker is representing colors as strings because the internal
  * representation will depend on the underlying backend.
  * The format of the colors taken in input and returned will always follow the
  * format of the <input type='color'> value as described in the HTML
  * specifications.
  */
 
-[scriptable, uuid(d2ce78d1-40b5-49d1-b66d-5801fcb9a385)]
+[scriptable, uuid(645FAD1F-2B55-42E1-AC15-DB4A9DF27209)]
 interface nsIColorPickerShownCallback : nsISupports
 {
  /**
   * Callback called when the color picker requests a color update.
   * This callback can not be called after done() was called.
   * When this callback is used, the consumer can assume that the color value has
   * changed.
   *
@@ -57,16 +57,17 @@ interface nsIColorPicker : nsISupports
   *
   * @param      parent       nsIDOMWindow parent. This dialog will be dependent
   *                          on this parent. parent must be non-null.
   * @param      title        The title for the color picker widget.
   * @param      initialColor The color to show when the widget is opened. The
   *                          parameter has to follow the format specified on top
   *                          of this file.
   */
-  void init(in mozIDOMWindowProxy parent, in AString title, in AString initialColor);
+  void init(in mozIDOMWindowProxy parent, in AString title, in AString initialColor,
+            in boolean aShowAlpha);
 
  /**
   * Opens the color dialog asynchrounously.
   * The results are provided via the callback object.
   */
   void open(in nsIColorPickerShownCallback aColorPickerShownCallback);
 };
diff --git a/widget/nsIScreenManager.idl b/widget/nsIScreenManager.idl
--- a/widget/nsIScreenManager.idl
+++ b/widget/nsIScreenManager.idl
@@ -13,16 +13,18 @@ interface nsIScreenManager : nsISupports
     //
     // Returns the screen that contains the rectangle. If the rect overlaps
     // multiple screens, it picks the screen with the greatest area of intersection.
     //
     // The coordinates are in pixels (not twips) and in screen coordinates.
     //
   nsIScreen screenForRect ( in long left, in long top, in long width, in long height ) ;
 
+  nsIScreen screenForIndex ( in unsigned long index);
+
     //
     // Returns the screen corresponding to the id. If no such screen exists,
     // this will throw NS_ERROR_FAILURE. The id is a unique numeric value
     // assigned to each screen, and is an attribute available on the nsIScreen
     // interface.
   nsIScreen screenForId ( in unsigned long id ) ;
 
     // The screen with the menubar/taskbar. This shouldn't be needed very
diff --git a/widget/nsScreenManagerProxy.cpp b/widget/nsScreenManagerProxy.cpp
--- a/widget/nsScreenManagerProxy.cpp
+++ b/widget/nsScreenManagerProxy.cpp
@@ -80,16 +80,24 @@ NS_IMETHODIMP
 nsScreenManagerProxy::ScreenForId(uint32_t aId, nsIScreen** outScreen)
 {
   // At this time, there's no need for child processes to query for
   // screens by ID.
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
+nsScreenManagerProxy::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+  // At this time, there's no need for child processes to query for
+  // screens by ID.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 nsScreenManagerProxy::ScreenForRect(int32_t inLeft,
                                     int32_t inTop,
                                     int32_t inWidth,
                                     int32_t inHeight,
                                     nsIScreen** outScreen)
 {
   bool success = false;
   ScreenDetails details;
diff --git a/widget/windows/nsColorPicker.cpp b/widget/windows/nsColorPicker.cpp
--- a/widget/windows/nsColorPicker.cpp
+++ b/widget/windows/nsColorPicker.cpp
@@ -187,22 +187,24 @@ nsColorPicker::~nsColorPicker()
 {
 }
 
 NS_IMPL_ISUPPORTS(nsColorPicker, nsIColorPicker)
 
 NS_IMETHODIMP
 nsColorPicker::Init(mozIDOMWindowProxy* parent,
                     const nsAString& title,
-                    const nsAString& aInitialColor)
+                    const nsAString& aInitialColor,
+                    bool aShowsAlpha)
 {
   NS_PRECONDITION(parent,
       "Null parent passed to colorpicker, no color picker for you!");
   mParentWidget =  WidgetUtils::DOMWindowToWidget(nsPIDOMWindowOuter::From(parent));
   mInitialColor = ColorStringToRGB(aInitialColor);
+  mShowsAlpha = aShowsAlpha;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsColorPicker::Open(nsIColorPickerShownCallback* aCallback)
 {
   NS_ENSURE_ARG(aCallback);
   nsCOMPtr<nsIRunnable> event = new AsyncColorChooser(mInitialColor,
diff --git a/widget/windows/nsColorPicker.h b/widget/windows/nsColorPicker.h
--- a/widget/windows/nsColorPicker.h
+++ b/widget/windows/nsColorPicker.h
@@ -43,17 +43,19 @@ class nsColorPicker :
   virtual ~nsColorPicker();
 
 public:
   nsColorPicker();
 
   NS_DECL_ISUPPORTS
 
   NS_IMETHOD Init(mozIDOMWindowProxy* parent, const nsAString& title,
-                  const nsAString& aInitialColor);
+                  const nsAString& aInitialColor,
+                  bool aShowsAlpha);
   NS_IMETHOD Open(nsIColorPickerShownCallback* aCallback);
 
 private:
   COLORREF mInitialColor;
   nsCOMPtr<nsIWidget> mParentWidget;
+  bool mShowsAlpha;
 };
 
 #endif // nsColorPicker_h__
diff --git a/widget/windows/nsScreenManagerWin.cpp b/widget/windows/nsScreenManagerWin.cpp
--- a/widget/windows/nsScreenManagerWin.cpp
+++ b/widget/windows/nsScreenManagerWin.cpp
@@ -174,8 +174,22 @@ nsScreenManagerWin::GetSystemDefaultScal
 
 NS_IMETHODIMP
 nsScreenManagerWin::ScreenForNativeWidget(void *aWidget, nsIScreen **outScreen)
 {
   HMONITOR mon = MonitorFromWindow((HWND) aWidget, MONITOR_DEFAULTTOPRIMARY);
   *outScreen = CreateNewScreenObject(mon);
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsScreenManagerWin::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+  *outScreen = nullptr;
+
+  if (aIndex < mScreenList.Length()) {
+    ScreenListItem& curr = mScreenList[aIndex];
+    NS_IF_ADDREF(*outScreen = curr.mScreen.get());
+    return NS_OK;
+  }
+
+  return NS_ERROR_FAILURE;
+}
