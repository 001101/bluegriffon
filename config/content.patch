diff --git a/README.txt b/README.txt
--- a/README.txt
+++ b/README.txt
@@ -1,27 +1,2 @@
-An explanation of the Mozilla Source Code Directory Structure and links to
-project pages with documentation can be found at:
-
-    https://developer.mozilla.org/en/Mozilla_Source_Code_Directory_Structure
-
-For information on how to build Mozilla from the source code, see:
-
-    http://developer.mozilla.org/en/docs/Build_Documentation
-
-To have your bug fix / feature added to Mozilla, you should create a patch and
-submit it to Bugzilla (https://bugzilla.mozilla.org). Instructions are at:
-
-    http://developer.mozilla.org/en/docs/Creating_a_patch
-    http://developer.mozilla.org/en/docs/Getting_your_patch_in_the_tree
-
-If you have a question about developing Mozilla, and can't find the solution
-on http://developer.mozilla.org, you can try asking your question in a
-mozilla.* Usenet group, or on IRC at irc.mozilla.org. [The Mozilla news groups
-are accessible on Google Groups, or news.mozilla.org with a NNTP reader.]
-
-You can download nightly development builds from the Mozilla FTP server.
-Keep in mind that nightly builds, which are used by Mozilla developers for
-testing, may be buggy. Firefox nightlies, for example, can be found at:
-
-    https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central/
-            - or -
-    http://nightly.mozilla.org/
+video.png icon derived from movie.png by "Phuzion" used under Creative Commons Ñ Attribution licence
+  http://findicons.com/icon/64871/video?width=32#
diff --git a/browser/base/content/baseMenuOverlay.xul b/browser/base/content/baseMenuOverlay.xul
--- a/browser/base/content/baseMenuOverlay.xul
+++ b/browser/base/content/baseMenuOverlay.xul
@@ -98,17 +98,17 @@
              oncommand="openHelpLink('firefox-osxkey');"
              key="&helpMac.commandkey;"
              modifiers="accel"/>
 <!-- These are used to build the Application menu under Cocoa widgets -->
         <key id="key_preferencesCmdMac"
              key="&preferencesCmdMac.commandkey;"
              modifiers="accel"/>
         <key id="key_hideThisAppCmdMac"
-             key="&hideThisAppCmdMac2.commandkey;"
+             key="&hideThisAppCmdMac.commandkey;"
              modifiers="accel"/>
         <key id="key_hideOtherAppsCmdMac"
              key="&hideOtherAppsCmdMac.commandkey;"
              modifiers="accel,alt"/>
 #endif
     </keyset>
 
     <stringbundleset id="stringbundleset">
diff --git a/browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd b/browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd
--- a/browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd
+++ b/browser/locales/en-US/chrome/browser/baseMenuOverlay.dtd
@@ -41,14 +41,14 @@
 <!ENTITY helpShowTour2.accesskey        "o">
 
 <!ENTITY preferencesCmdMac.label        "Preferencesâ€¦">
 <!ENTITY preferencesCmdMac.commandkey   ",">
 
 <!ENTITY servicesMenuMac.label          "Services">
 
 <!ENTITY hideThisAppCmdMac2.label       "Hide &brandShorterName;">
-<!ENTITY hideThisAppCmdMac2.commandkey  "H">
+<!ENTITY hideThisAppCmdMac.commandkey   "H">
 
 <!ENTITY hideOtherAppsCmdMac.label      "Hide Others">
 <!ENTITY hideOtherAppsCmdMac.commandkey "H">
 
 <!ENTITY showAllAppsCmdMac.label        "Show All">
diff --git a/caps/nsScriptSecurityManager.cpp b/caps/nsScriptSecurityManager.cpp
--- a/caps/nsScriptSecurityManager.cpp
+++ b/caps/nsScriptSecurityManager.cpp
@@ -920,16 +920,17 @@ nsScriptSecurityManager::CheckLoadURIWit
     }
 
     // Check for target URI pointing to a file
     rv = NS_URIChainHasFlags(aTargetURI,
                              nsIProtocolHandler::URI_IS_LOCAL_FILE,
                              &hasFlags);
     NS_ENSURE_SUCCESS(rv, rv);
     if (hasFlags) {
+        return NS_OK;
         // Allow domains that were whitelisted in the prefs. In 99.9% of cases,
         // this array is empty.
         for (size_t i = 0; i < mFileURIWhitelist.Length(); ++i) {
             if (EqualOrSubdomain(sourceURI, mFileURIWhitelist[i])) {
                 return NS_OK;
             }
         }
 
diff --git a/dom/base/nsCopySupport.cpp b/dom/base/nsCopySupport.cpp
--- a/dom/base/nsCopySupport.cpp
+++ b/dom/base/nsCopySupport.cpp
@@ -132,17 +132,18 @@ SelectionCopyHelper(nsISelection *aSel, 
     nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(aDoc);
     if (!htmlDoc) {
       selForcedTextPlain = true;
     }
   }
 
   // The mime type is ultimately text/html if the encoder successfully encoded
   // the selection as text/html.
-  bool encodedTextHTML = mimeType.EqualsLiteral(kHTMLMime);
+  bool encodedTextHTML = mimeType.EqualsLiteral(kHTMLMime) ||
+                         mimeType.EqualsLiteral("application/xhtml+xml");
 
   // First, prepare the text/plain clipboard flavor.
   nsAutoString textPlainBuf;
   if (selForcedTextPlain) {
     // Nothing to do.  buf contains the final, preformatted, raw text/plain.
     textPlainBuf.Assign(buf);
   } else {
     // Redo the encoding, but this time use pretty printing.
@@ -510,18 +511,19 @@ static nsresult AppendDOMNode(nsITransfe
   // serializers and parsers is OK, and those mess up XHTML).
   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(document, &rv);
   NS_ENSURE_SUCCESS(rv, NS_OK);
 
   NS_ENSURE_TRUE(document->IsHTMLDocument(), NS_OK);
 
   // init encoder with document and node
   rv = docEncoder->NativeInit(document, NS_LITERAL_STRING(kHTMLMime),
-                              nsIDocumentEncoder::OutputAbsoluteLinks |
-                              nsIDocumentEncoder::OutputEncodeW3CEntities);
+                              Preferences::GetBool("clipboard.absoluteLinks", true)
+                                ? nsIDocumentEncoder::OutputEncodeCharacterEntities | nsIDocumentEncoder::OutputAbsoluteLinks
+                                : nsIDocumentEncoder::OutputEncodeCharacterEntities);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = docEncoder->SetNativeNode(aDOMNode);
   NS_ENSURE_SUCCESS(rv, rv);
 
   // serialize to string
   nsAutoString html, context, info;
   rv = docEncoder->EncodeToStringWithContext(context, info, html);
diff --git a/dom/base/nsDocument.cpp b/dom/base/nsDocument.cpp
--- a/dom/base/nsDocument.cpp
+++ b/dom/base/nsDocument.cpp
@@ -7577,16 +7577,23 @@ nsDocument::GetInputEncoding(nsAString& 
 NS_IMETHODIMP
 nsDocument::GetMozSyntheticDocument(bool *aSyntheticDocument)
 {
   *aSyntheticDocument = mIsSyntheticDocument;
   return NS_OK;
 }
 
 NS_IMETHODIMP
+nsDocument::GetHasXMLDeclaration(bool *aHasXMLDeclaration)
+{
+  *aHasXMLDeclaration = mXMLDeclarationBits & XML_DECLARATION_BITS_DECLARATION_EXISTS;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 nsDocument::GetDocumentURI(nsAString& aDocumentURI)
 {
   nsString temp;
   nsIDocument::GetDocumentURI(temp);
   aDocumentURI = temp;
   return NS_OK;
 }
 
diff --git a/dom/base/nsDocumentEncoder.cpp b/dom/base/nsDocumentEncoder.cpp
--- a/dom/base/nsDocumentEncoder.cpp
+++ b/dom/base/nsDocumentEncoder.cpp
@@ -116,16 +116,21 @@ protected:
       ShadowRoot* shadowRoot = ShadowRoot::FromNode(aNode);
       if (shadowRoot) {
         content = shadowRoot->GetHost();
       } else {
         content = do_QueryInterface(aNode);
       }
 
       if (content) {
+        nsIAtom *tag = content->NodeInfo()->NameAtom();
+        if (tag == nsGkAtoms::script
+            || tag == nsGkAtoms::style) {
+          return true;
+        }
         nsIFrame* frame = content->GetPrimaryFrame();
         if (!frame) {
           if (aNode->IsNodeOfType(nsINode::eTEXT)) {
             // We have already checked that our parent is visible.
             return true;
           }
           if (aNode->IsHTMLElement(nsGkAtoms::rp)) {
             // Ruby parentheses are part of ruby structure, hence
@@ -1387,17 +1392,19 @@ nsHTMLCopyEncoder::Init(nsIDOMDocument* 
   if (aMimeType.EqualsLiteral("text/plain")) {
     mMimeType.AssignLiteral("text/plain");
   } else {
     mMimeType.AssignLiteral("text/html");
   }
 
   // Make all links absolute when copying
   // (see related bugs #57296, #41924, #58646, #32768)
-  mFlags = aFlags | OutputAbsoluteLinks;
+  mFlags = Preferences::GetBool("clipboard.absoluteLinks", true)
+             ? aFlags | nsIDocumentEncoder::OutputAbsoluteLinks
+             : aFlags;
 
   if (!mDocument->IsScriptEnabled())
     mFlags |= OutputNoScriptContent;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -1485,17 +1492,17 @@ nsHTMLCopyEncoder::SetSelection(nsISelec
   {
     mSelection = aSelection;
     mMimeType.AssignLiteral("text/plain");
     return NS_OK;
   }
 
   // also consider ourselves in a text widget if we can't find an html document
   nsCOMPtr<nsIHTMLDocument> htmlDoc = do_QueryInterface(mDocument);
-  if (!(htmlDoc && mDocument->IsHTMLDocument())) {
+  if (!htmlDoc) {
     mIsTextWidget = true;
     mSelection = aSelection;
     // mMimeType is set to text/plain when encoding starts.
     return NS_OK;
   }
   
   // there's no Clone() for selection! fix...
   //nsresult rv = aSelection->Clone(getter_AddRefs(mSelection);
@@ -1506,19 +1513,20 @@ nsHTMLCopyEncoder::SetSelection(nsISelec
   // loop thru the ranges in the selection
   for (uint32_t rangeIdx = 0; rangeIdx < rangeCount; ++rangeIdx) {
     range = selection->GetRangeAt(rangeIdx);
     NS_ENSURE_TRUE(range, NS_ERROR_FAILURE);
     nsCOMPtr<nsIDOMRange> myRange;
     range->CloneRange(getter_AddRefs(myRange));
     NS_ENSURE_TRUE(myRange, NS_ERROR_FAILURE);
 
+    // BLUEGRIFFON, do not promote ranges for copy
     // adjust range to include any ancestors who's children are entirely selected
-    rv = PromoteRange(myRange);
-    NS_ENSURE_SUCCESS(rv, rv);
+    /*rv = PromoteRange(myRange);
+    NS_ENSURE_SUCCESS(rv, rv);*/
     
     rv = mSelection->AddRange(myRange);
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return NS_OK;
 }
 
diff --git a/dom/base/nsFocusManager.cpp b/dom/base/nsFocusManager.cpp
--- a/dom/base/nsFocusManager.cpp
+++ b/dom/base/nsFocusManager.cpp
@@ -2565,41 +2565,16 @@ nsFocusManager::DetermineElementToMoveFo
         if (startContent ==
               nsLayoutUtils::GetEditableRootContentByContentEditable(doc)) {
           doNavigation = false;
         }
       }
     }
   }
   else {
-#ifdef MOZ_XUL
-    if (aType != MOVEFOCUS_CARET) {
-      // if there is no focus, yet a panel is open, focus the first item in
-      // the panel
-      nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
-      if (pm)
-        popupFrame = pm->GetTopPopup(ePopupTypePanel);
-    }
-#endif
-    if (popupFrame) {
-      // When there is a popup open, and no starting content, start the search
-      // at the topmost popup.
-      startContent = popupFrame->GetContent();
-      NS_ASSERTION(startContent, "Popup frame doesn't have a content node");
-      // Unless we are searching for documents, set the root content to the
-      // popup as well, so that we don't tab-navigate outside the popup.
-      // When navigating by documents, we start at the popup but can navigate
-      // outside of it to look for other panels and documents.
-      if (!forDocumentNavigation) {
-        rootContent = startContent;
-      }
-
-      doc = startContent ? startContent->GetComposedDoc() : nullptr;
-    }
-    else {
       // Otherwise, for content shells, start from the location of the caret.
       nsCOMPtr<nsIDocShell> docShell = aWindow->GetDocShell();
       if (docShell && docShell->ItemType() != nsIDocShellTreeItem::typeChrome) {
         nsCOMPtr<nsIContent> endSelectionContent;
         GetSelectionLocation(doc, presShell,
                              getter_AddRefs(startContent),
                              getter_AddRefs(endSelectionContent));
         // If the selection is on the rootContent, then there is no selection
@@ -2621,23 +2596,37 @@ nsFocusManager::DetermineElementToMoveFo
         if (startContent) {
           // when starting from a selection, we always want to find the next or
           // previous element in the document. So the tabindex on elements
           // should be ignored.
           ignoreTabIndex = true;
         }
       }
 
+#ifdef MOZ_XUL
+    else {
+      // if there is no focus, yet a panel is open, focus the first item in
+      // the panel
+      nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
+      if (pm)
+        popupFrame = pm->GetTopPopup(ePopupTypePanel);
+      if (popupFrame) {
+        rootContent = popupFrame->GetContent();
+        NS_ASSERTION(rootContent, "Popup frame doesn't have a content node");
+        startContent = rootContent;
+      }
+    }
+#endif
+
       if (!startContent) {
         // otherwise, just use the root content as the starting point
         startContent = rootContent;
         NS_ENSURE_TRUE(startContent, NS_OK);
       }
     }
-  }
 
   // Check if the starting content is the same as the content assigned to the
   // retargetdocumentfocus attribute. Is so, we don't want to start searching
   // from there but instead from the beginning of the document. Otherwise, the
   // content that appears before the retargetdocumentfocus element will never
   // get checked as it will be skipped when the focus is retargetted to it.
   if (forDocumentNavigation && doc->IsXULDocument()) {
     nsAutoString retarget;
diff --git a/dom/base/nsGkAtomList.h b/dom/base/nsGkAtomList.h
--- a/dom/base/nsGkAtomList.h
+++ b/dom/base/nsGkAtomList.h
@@ -1114,16 +1114,17 @@ GK_ATOM(selectedindex, "selectedindex")
 GK_ATOM(self, "self")
 GK_ATOM(seltype, "seltype")
 GK_ATOM(setcookie, "set-cookie")
 GK_ATOM(setter, "setter")
 GK_ATOM(shape, "shape")
 GK_ATOM(show, "show")
 GK_ATOM(showcaret, "showcaret")
 GK_ATOM(showresizer, "showresizer")
+GK_ATOM(showtransparency, "showTransparency")
 GK_ATOM(simple, "simple")
 GK_ATOM(single, "single")
 GK_ATOM(size, "size")
 GK_ATOM(sizes, "sizes")
 GK_ATOM(sizemode, "sizemode")
 GK_ATOM(sizetopopup, "sizetopopup")
 GK_ATOM(slider, "slider")
 GK_ATOM(small, "small")
diff --git a/dom/base/nsHTMLContentSerializer.cpp b/dom/base/nsHTMLContentSerializer.cpp
--- a/dom/base/nsHTMLContentSerializer.cpp
+++ b/dom/base/nsHTMLContentSerializer.cpp
@@ -189,111 +189,120 @@ nsHTMLContentSerializer::AppendElementSt
     return rv;
   }
 
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsIAtom *name = content->NodeInfo()->NameAtom();
   int32_t ns = content->GetNameSpaceID();
 
-  bool lineBreakBeforeOpen = LineBreakBeforeOpen(ns, name);
+  bool hideTag = false;
+  if (ns != kNameSpaceID_XHTML) {
+    nsAutoString nsStr;
+    nsresult rv = nsContentUtils::NameSpaceManager()->GetNameSpaceURI(ns, nsStr);
+    hideTag = ( NS_SUCCEEDED(rv) && nsStr.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon"));
+  }
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    if (mColPos && lineBreakBeforeOpen) {
-      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    else {
-      NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    if (!mColPos) {
-      NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);
+  if (!hideTag) {
+    bool lineBreakBeforeOpen = LineBreakBeforeOpen(ns, name);
+
+    if (((mDoFormat || forceFormat) && !PreLevel()) || mDoRaw) {
+      if (mColPos && lineBreakBeforeOpen) {
+        NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+        mMayIgnoreLineBreakSequence = PR_FALSE;
+      }
+      else {
+        NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);;
+      }
+      if (!mColPos && !mDoRaw) {
+        NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);;;
+      }
+      else if (mAddSpace) {
+        NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);;;
+        mAddSpace = false;
+      }
     }
     else if (mAddSpace) {
       bool result = AppendToString(char16_t(' '), aStr);
       mAddSpace = false;
       NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
     }
-  }
-  else if (mAddSpace) {
-    bool result = AppendToString(char16_t(' '), aStr);
-    mAddSpace = false;
-    NS_ENSURE_TRUE(result, NS_ERROR_OUT_OF_MEMORY);
-  }
-  else {
-    NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
-  // called
-  mAddNewlineForRootNode = false;
+    else {
+      NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
+    }
+    // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
+    // called
+    mAddNewlineForRootNode = false;
 
-  NS_ENSURE_TRUE(AppendToString(kLessThan, aStr), NS_ERROR_OUT_OF_MEMORY);
+    NS_ENSURE_TRUE(AppendToString(kLessThan, aStr), NS_ERROR_OUT_OF_MEMORY);
 
-  NS_ENSURE_TRUE(AppendToString(nsDependentAtomString(name), aStr), NS_ERROR_OUT_OF_MEMORY);
+    NS_ENSURE_TRUE(AppendToString(nsDependentAtomString(name), aStr), NS_ERROR_OUT_OF_MEMORY);
 
-  MaybeEnterInPreContent(content);
+    MaybeEnterInPreContent(content);
 
-  // for block elements, we increase the indentation
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel())
-    NS_ENSURE_TRUE(IncrIndentation(name), NS_ERROR_OUT_OF_MEMORY);
+    // for block elements, we increase the indentation
+    if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel())
+      NS_ENSURE_TRUE(IncrIndentation(name), NS_ERROR_OUT_OF_MEMORY);
 
-  // Need to keep track of OL and LI elements in order to get ordinal number 
-  // for the LI.
-  if (mIsCopying && name == nsGkAtoms::ol && ns == kNameSpaceID_XHTML){
-    // We are copying and current node is an OL;
-    // Store its start attribute value in olState->startVal.
-    nsAutoString start;
-    int32_t startAttrVal = 0;
+    // Need to keep track of OL and LI elements in order to get ordinal number
+    // for the LI.
+    if (mIsCopying && name == nsGkAtoms::ol && ns == kNameSpaceID_XHTML){
+      // We are copying and current node is an OL;
+      // Store its start attribute value in olState->startVal.
+      nsAutoString start;
+      int32_t startAttrVal = 0;
 
-    aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::start, start);
-    if (!start.IsEmpty()){
-      nsresult rv = NS_OK;
-      startAttrVal = start.ToInteger(&rv);
-      //If OL has "start" attribute, first LI element has to start with that value
-      //Therefore subtracting 1 as all the LI elements are incrementing it before using it;
-      //In failure of ToInteger(), default StartAttrValue to 0.
-      if (NS_SUCCEEDED(rv))
-        startAttrVal--; 
-      else
-        startAttrVal = 0;
+      aElement->GetAttr(kNameSpaceID_None, nsGkAtoms::start, start);
+      if (!start.IsEmpty()){
+        nsresult rv = NS_OK;
+        startAttrVal = start.ToInteger(&rv);
+        //If OL has "start" attribute, first LI element has to start with that value
+        //Therefore subtracting 1 as all the LI elements are incrementing it before using it;
+        //In failure of ToInteger(), default StartAttrValue to 0.
+        if (NS_SUCCEEDED(rv))
+          startAttrVal--;
+        else
+          startAttrVal = 0;
+      }
+      mOLStateStack.AppendElement(olState(startAttrVal, true));
     }
-    mOLStateStack.AppendElement(olState(startAttrVal, true));
-  }
 
-  if (mIsCopying && name == nsGkAtoms::li && ns == kNameSpaceID_XHTML) {
-    mIsFirstChildOfOL = IsFirstChildOfOL(aOriginalElement);
-    if (mIsFirstChildOfOL){
-      // If OL is parent of this LI, serialize attributes in different manner.
-      NS_ENSURE_TRUE(SerializeLIValueAttribute(aElement, aStr), NS_ERROR_OUT_OF_MEMORY);
+    if (mIsCopying && name == nsGkAtoms::li && ns == kNameSpaceID_XHTML) {
+      mIsFirstChildOfOL = IsFirstChildOfOL(aOriginalElement);
+      if (mIsFirstChildOfOL){
+        // If OL is parent of this LI, serialize attributes in different manner.
+        NS_ENSURE_TRUE(SerializeLIValueAttribute(aElement, aStr), NS_ERROR_OUT_OF_MEMORY);
+      }
     }
-  }
 
-  // Even LI passed above have to go through this 
-  // for serializing attributes other than "value".
-  nsAutoString dummyPrefix;
-  NS_ENSURE_TRUE(SerializeHTMLAttributes(content,
-                                         aOriginalElement,
-                                         dummyPrefix,
-                                         EmptyString(),
-                                         name,
-                                         ns,
-                                         aStr), NS_ERROR_OUT_OF_MEMORY);
+    // Even LI passed above have to go through this
+    // for serializing attributes other than "value".
+    nsAutoString dummyPrefix;
+    NS_ENSURE_TRUE(SerializeHTMLAttributes(content,
+                                           aOriginalElement,
+                                           dummyPrefix,
+                                           EmptyString(),
+                                           name,
+                                           ns,
+                                           aStr), NS_ERROR_OUT_OF_MEMORY);
 
-  NS_ENSURE_TRUE(AppendToString(kGreaterThan, aStr), NS_ERROR_OUT_OF_MEMORY);
+    NS_ENSURE_TRUE(AppendToString(kGreaterThan, aStr), NS_ERROR_OUT_OF_MEMORY);
 
-  if (ns == kNameSpaceID_XHTML &&
-      (name == nsGkAtoms::script ||
-       name == nsGkAtoms::style ||
-       name == nsGkAtoms::noscript ||
-       name == nsGkAtoms::noframes)) {
-    ++mDisableEntityEncoding;
-  }
+    if (ns == kNameSpaceID_XHTML &&
+        (name == nsGkAtoms::script ||
+         name == nsGkAtoms::style ||
+         name == nsGkAtoms::noscript ||
+         name == nsGkAtoms::noframes)) {
+      ++mDisableEntityEncoding;
+    }
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel() &&
-    LineBreakAfterOpen(ns, name)) {
-    NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+    if ((mDoFormat || forceFormat) && !PreLevel() &&
+      !mDoRaw && LineBreakAfterOpen(ns, name)) {
+      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+    }
   }
 
   NS_ENSURE_TRUE(AfterElementStart(content, aOriginalElement, aStr), NS_ERROR_OUT_OF_MEMORY);
 
   return NS_OK;
 }
   
 NS_IMETHODIMP 
@@ -302,16 +311,23 @@ nsHTMLContentSerializer::AppendElementEn
 {
   NS_ENSURE_ARG(aElement);
 
   nsIContent* content = aElement;
 
   nsIAtom *name = content->NodeInfo()->NameAtom();
   int32_t ns = content->GetNameSpaceID();
 
+  if (ns != kNameSpaceID_XHTML) {
+    nsAutoString nsStr;
+    nsresult rv = nsContentUtils::NameSpaceManager()->GetNameSpaceURI(ns, nsStr);
+    if (NS_SUCCEEDED(rv) && nsStr.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon"))
+      return NS_OK;
+  }
+
   if (ns == kNameSpaceID_XHTML &&
       (name == nsGkAtoms::script ||
        name == nsGkAtoms::style ||
        name == nsGkAtoms::noscript ||
        name == nsGkAtoms::noframes)) {
     --mDisableEntityEncoding;
   }
 
@@ -485,17 +501,18 @@ nsHTMLContentSerializer::AppendAndTransl
 
   if (mDisableEntityEncoding) {
     return aOutputStr.Append(aStr, mozilla::fallible);
   }
 
   bool nonBasicEntities =
     !!(mFlags & (nsIDocumentEncoder::OutputEncodeLatin1Entities |
                  nsIDocumentEncoder::OutputEncodeHTMLEntities   |
-                 nsIDocumentEncoder::OutputEncodeW3CEntities));
+                 nsIDocumentEncoder::OutputEncodeW3CEntities    |
+                 nsIDocumentEncoder::OutputEncodeCharacterEntities));
 
   if (!nonBasicEntities &&
       (mFlags & (nsIDocumentEncoder::OutputEncodeBasicEntities))) {
     const uint8_t* entityTable = mInAttribute ? kAttrEntities : kEntities;
     uint32_t start = 0;
     const uint32_t len = aStr.Length();
     for (uint32_t i = 0; i < len; ++i) {
       const char* entity = nullptr;
@@ -542,17 +559,23 @@ nsHTMLContentSerializer::AppendAndTransl
       const char* fullConstEntityText = nullptr;
       char* fullEntityText = nullptr;
 
       advanceLength = 0;
       // for each character in this chunk, check if it
       // needs to be replaced
       for (; c < fragmentEnd; c++, advanceLength++) {
         char16_t val = *c;
-        if (val <= kValNBSP && entityTable[val]) {
+        if ((val == kValNBSP || val > 127) &&
+            (mFlags & nsIDocumentEncoder::OutputEncodeCharacterEntities)) {
+          nsAutoString entityValue(char16_t('#'));
+          entityValue.AppendInt(val);
+          entityText = ToNewCString(entityValue);
+          break;
+        } else if (val <= kValNBSP && entityTable[val]) {
           fullConstEntityText = kEntityStrings[entityTable[val]];
           break;
         } else if (val > 127 &&
                   ((val < 256 &&
                     mFlags & nsIDocumentEncoder::OutputEncodeLatin1Entities) ||
                     mFlags & nsIDocumentEncoder::OutputEncodeHTMLEntities)) {
           entityReplacement.Truncate();
           parserService->HTMLConvertUnicodeToEntity(val, entityReplacement);
diff --git a/dom/base/nsIDocumentEncoder.idl b/dom/base/nsIDocumentEncoder.idl
--- a/dom/base/nsIDocumentEncoder.idl
+++ b/dom/base/nsIDocumentEncoder.idl
@@ -13,17 +13,17 @@ interface nsIOutputStream;
 
 %{ C++
 class nsINode;
 class nsIDocument;
 %}
 [ptr] native nsINodePtr(nsINode);
 [ptr] native nsIDocumentPtr(nsIDocument);
 
-[scriptable, uuid(3d9371d8-a2ad-403e-8b0e-8885ad3562e3)]
+[scriptable, uuid(30a3161c-09e0-425e-84e6-ff952c0fd859)]
 interface nsIDocumentEncoderNodeFixup : nsISupports
 {
   /**
    * Create a fixed up version of a node. This method is called before
    * each node in a document is about to be persisted. The implementor
    * may return a new node with fixed up attributes or null. If null is
    * returned the node should be used as-is.
    * @param aNode Node to fixup.
@@ -242,16 +242,21 @@ interface nsIDocumentEncoder : nsISuppor
 
   /**
    * Disallow breaking of long character strings. This is important
    * for serializing e-mail which contains CJK strings. These must
    * not be broken just as "normal" longs strings aren't broken.
    */
   const unsigned long OutputDisallowLineBreaking = (1 << 27);
 
+ /**
+   * Output all non-ascii characters as numeric entities
+   */                                                                                                                                         
+  const unsigned long OutputEncodeCharacterEntities = (1 << 28);
+
   /**
    * Initialize with a pointer to the document and the mime type.
    * @param aDocument Document to encode.
    * @param aMimeType MimeType to use. May also be set by SetMimeType.
    * @param aFlags Flags to use while encoding. May also be set by SetFlags.
    */
   void init(in nsIDOMDocument aDocument,
             in AString aMimeType,
diff --git a/dom/base/nsXHTMLContentSerializer.cpp b/dom/base/nsXHTMLContentSerializer.cpp
--- a/dom/base/nsXHTMLContentSerializer.cpp
+++ b/dom/base/nsXHTMLContentSerializer.cpp
@@ -59,24 +59,16 @@ nsXHTMLContentSerializer::~nsXHTMLConten
   NS_ASSERTION(mOLStateStack.IsEmpty(), "Expected OL State stack to be empty");
 }
 
 NS_IMETHODIMP
 nsXHTMLContentSerializer::Init(uint32_t aFlags, uint32_t aWrapColumn,
                               const char* aCharSet, bool aIsCopying,
                               bool aRewriteEncodingDeclaration)
 {
-  // The previous version of the HTML serializer did implicit wrapping
-  // when there is no flags, so we keep wrapping in order to keep
-  // compatibility with the existing calling code
-  // XXXLJ perhaps should we remove this default settings later ?
-  if (aFlags & nsIDocumentEncoder::OutputFormatted ) {
-      aFlags = aFlags | nsIDocumentEncoder::OutputWrap;
-  }
-
   nsresult rv;
   rv = nsXMLContentSerializer::Init(aFlags, aWrapColumn, aCharSet, aIsCopying, aRewriteEncodingDeclaration);
   NS_ENSURE_SUCCESS(rv, rv);
 
   mRewriteEncodingDeclaration = aRewriteEncodingDeclaration;
   mIsCopying = aIsCopying;
   mIsFirstChildOfOL = false;
   mInBody = 0;
@@ -656,17 +648,26 @@ nsXHTMLContentSerializer::LineBreakBefor
 
   if (aName == nsGkAtoms::title ||
       aName == nsGkAtoms::meta  ||
       aName == nsGkAtoms::link  ||
       aName == nsGkAtoms::style ||
       aName == nsGkAtoms::select ||
       aName == nsGkAtoms::option ||
       aName == nsGkAtoms::script ||
-      aName == nsGkAtoms::html) {
+      aName == nsGkAtoms::html ||
+      aName == nsGkAtoms::head ||
+      //aName == nsGkAtoms::body ||
+      aName == nsGkAtoms::table ||
+      aName == nsGkAtoms::caption ||
+      aName == nsGkAtoms::tbody ||
+      aName == nsGkAtoms::thead ||
+      aName == nsGkAtoms::tfoot ||
+      aName == nsGkAtoms::tr ||
+      aName == nsGkAtoms::td) {
     return true;
   }
   else {
     nsIParserService* parserService = nsContentUtils::GetParserService();
 
     if (parserService) {
       bool res;
       parserService->
@@ -683,22 +684,24 @@ nsXHTMLContentSerializer::LineBreakAfter
 {
 
   if (aNamespaceID != kNameSpaceID_XHTML) {
     return false;
   }
 
   if ((aName == nsGkAtoms::html) ||
       (aName == nsGkAtoms::head) ||
-      (aName == nsGkAtoms::body) ||
+      // (aName == nsGkAtoms::body) ||
       (aName == nsGkAtoms::ul) ||
       (aName == nsGkAtoms::ol) ||
       (aName == nsGkAtoms::dl) ||
       (aName == nsGkAtoms::table) ||
       (aName == nsGkAtoms::tbody) ||
+      (aName == nsGkAtoms::thead) ||
+      (aName == nsGkAtoms::tfoot) ||
       (aName == nsGkAtoms::tr) ||
       (aName == nsGkAtoms::br) ||
       (aName == nsGkAtoms::meta) ||
       (aName == nsGkAtoms::link) ||
       (aName == nsGkAtoms::script) ||
       (aName == nsGkAtoms::select) ||
       (aName == nsGkAtoms::map) ||
       (aName == nsGkAtoms::area) ||
@@ -776,39 +779,45 @@ nsXHTMLContentSerializer::LineBreakAfter
 void
 nsXHTMLContentSerializer::MaybeEnterInPreContent(nsIContent* aNode)
 {
   if (!ShouldMaintainPreLevel() ||
       !aNode->IsHTMLElement()) {
     return;
   }
 
-  if (IsElementPreformatted(aNode) ||
+  PRBool disableEntityEncoding =
       aNode->IsAnyOfHTMLElements(nsGkAtoms::script,
                                  nsGkAtoms::style,
                                  nsGkAtoms::noscript,
-                                 nsGkAtoms::noframes)) {
+                                 nsGkAtoms::noframes);
+  if (IsElementPreformatted(aNode) || disableEntityEncoding) {
     PreLevel()++;
+    if (disableEntityEncoding)
+      ++mDisableEntityEncoding;
   }
 }
 
 void
 nsXHTMLContentSerializer::MaybeLeaveFromPreContent(nsIContent* aNode)
 {
   if (!ShouldMaintainPreLevel() ||
       !aNode->IsHTMLElement()) {
     return;
   }
 
-  if (IsElementPreformatted(aNode) ||
+  PRBool disableEntityEncoding =
       aNode->IsAnyOfHTMLElements(nsGkAtoms::script,
                                  nsGkAtoms::style,
                                  nsGkAtoms::noscript,
-                                 nsGkAtoms::noframes)) {
+                                 nsGkAtoms::noframes);
+  if (IsElementPreformatted(aNode) || disableEntityEncoding) {
     --PreLevel();
+    if (disableEntityEncoding)
+      --mDisableEntityEncoding;
   }
 }
 
 bool
 nsXHTMLContentSerializer::IsElementPreformatted(nsIContent* aNode)
 {
   MOZ_ASSERT(ShouldMaintainPreLevel(), "We should not be calling this needlessly");
 
diff --git a/dom/base/nsXMLContentSerializer.cpp b/dom/base/nsXMLContentSerializer.cpp
--- a/dom/base/nsXMLContentSerializer.cpp
+++ b/dom/base/nsXMLContentSerializer.cpp
@@ -620,17 +620,36 @@ nsXMLContentSerializer::SerializeAttr(co
                                       bool aDoEscapeEntities)
 {
   nsAutoString attrString_;
   // For innerHTML we can do faster appending without
   // temporary strings.
   bool rawAppend = mDoRaw && aDoEscapeEntities;
   nsAString& attrString = (rawAppend) ? aStr : attrString_;
 
-  NS_ENSURE_TRUE(attrString.Append(char16_t(' '), mozilla::fallible), false);
+  //NS_ENSURE_TRUE(attrString.Append(char16_t(' '), mozilla::fallible), false);
+  if (mColPos + 1 >= mMaxColumn && !mDoRaw) {
+    if (PreLevel() > 0) {
+      AppendToStringConvertLF(mLineBreak, aStr);
+    }
+    else if (mDoFormat) {
+      AppendToStringFormatedWrapped(mLineBreak, aStr);
+      AppendIndentation(aStr);
+    }
+    else if (mDoWrap) {
+      AppendToStringWrapped(mLineBreak, aStr);
+      AppendIndentation(aStr);
+    }
+    else {
+      AppendToStringConvertLF(mLineBreak, aStr);
+    }
+  }
+  else
+    attrString.Append(char16_t(' '));
+
   if (!aPrefix.IsEmpty()) {
     NS_ENSURE_TRUE(attrString.Append(aPrefix, mozilla::fallible), false);
     NS_ENSURE_TRUE(attrString.Append(char16_t(':'), mozilla::fallible), false);
   }
   NS_ENSURE_TRUE(attrString.Append(aName, mozilla::fallible), false);
 
   if (aDoEscapeEntities) {
     // if problem characters are turned into character entity references
@@ -695,29 +714,32 @@ nsXMLContentSerializer::SerializeAttr(co
                                            NS_LITERAL_STRING("&amp;"), mozilla::fallible), false);
     if (bIncludesDouble && bIncludesSingle) {
       NS_ENSURE_TRUE(sValue.ReplaceSubstring(NS_LITERAL_STRING("\""),
                                              NS_LITERAL_STRING("&quot;"), mozilla::fallible), false);
     }
     NS_ENSURE_TRUE(attrString.Append(sValue, mozilla::fallible), false);
     NS_ENSURE_TRUE(attrString.Append(cDelimiter, mozilla::fallible), false);
   }
+  AppendToStringConvertLF(attrString, aStr);
+  /* XXX
   if (mDoRaw || PreLevel() > 0) {
     NS_ENSURE_TRUE(AppendToStringConvertLF(attrString, aStr), false);
   }
   else if (mDoFormat) {
     NS_ENSURE_TRUE(AppendToStringFormatedWrapped(attrString, aStr), false);
   }
   else if (mDoWrap) {
     NS_ENSURE_TRUE(AppendToStringWrapped(attrString, aStr), false);
   }
   else {
     NS_ENSURE_TRUE(AppendToStringConvertLF(attrString, aStr), false);
   }
 
+  */
   return true;
 }
 
 uint32_t 
 nsXMLContentSerializer::ScanNamespaceDeclarations(nsIContent* aContent,
                                                   nsIContent *aOriginalElement,
                                                   const nsAString& aTagNamespaceURI)
 {
@@ -901,77 +923,84 @@ nsXMLContentSerializer::AppendElementSta
 
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoString tagPrefix, tagLocalName, tagNamespaceURI;
   aElement->NodeInfo()->GetPrefix(tagPrefix);
   aElement->NodeInfo()->GetName(tagLocalName);
   aElement->NodeInfo()->GetNamespaceURI(tagNamespaceURI);
 
-  uint32_t skipAttr = ScanNamespaceDeclarations(content,
-                          aOriginalElement, tagNamespaceURI);
+  bool hideTag = tagNamespaceURI.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon");
+  if (!hideTag) {
+    uint32_t skipAttr = ScanNamespaceDeclarations(content,
+                            aOriginalElement, tagNamespaceURI);
 
-  nsIAtom *name = content->NodeInfo()->NameAtom();
-  bool lineBreakBeforeOpen = LineBreakBeforeOpen(content->GetNameSpaceID(), name);
+    nsIAtom *name = content->NodeInfo()->NameAtom();
+    bool lineBreakBeforeOpen = LineBreakBeforeOpen(content->GetNameSpaceID(), name);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    if (mColPos && lineBreakBeforeOpen) {
-      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    else {
-      NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    if (!mColPos) {
-      NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);
+    if (((mDoFormat || forceFormat) && !PreLevel()) || mDoRaw) {
+      if (mColPos && lineBreakBeforeOpen) {
+        AppendNewLineToString(aStr);
+      }
+      else {
+        MaybeAddNewlineForRootNode(aStr);
+      }
+      if (!mColPos) {
+        AppendIndentation(aStr);
+      }
+      else if (mAddSpace) {
+        AppendToString(char16_t(' '), aStr);
+        mAddSpace = false;
+      }
     }
     else if (mAddSpace) {
       NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
       mAddSpace = false;
     }
-  }
-  else if (mAddSpace) {
-    NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
-    mAddSpace = false;
-  }
-  else {
-    NS_ENSURE_TRUE(MaybeAddNewlineForRootNode(aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
+    else {
+      MaybeAddNewlineForRootNode(aStr);
+    }
 
-  // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
-  // called
-  mAddNewlineForRootNode = false;
+    // Always reset to avoid false newlines in case MaybeAddNewlineForRootNode wasn't
+    // called
+    mAddNewlineForRootNode = false;
 
-  bool addNSAttr;
-  addNSAttr = ConfirmPrefix(tagPrefix, tagNamespaceURI, aOriginalElement,
-                            false);
+    bool addNSAttr;
+    addNSAttr = ConfirmPrefix(tagPrefix, tagNamespaceURI, aOriginalElement,
+                              false);
 
-  // Serialize the qualified name of the element
-  NS_ENSURE_TRUE(AppendToString(kLessThan, aStr), NS_ERROR_OUT_OF_MEMORY);
-  if (!tagPrefix.IsEmpty()) {
-    NS_ENSURE_TRUE(AppendToString(tagPrefix, aStr), NS_ERROR_OUT_OF_MEMORY);
-    NS_ENSURE_TRUE(AppendToString(NS_LITERAL_STRING(":"), aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  NS_ENSURE_TRUE(AppendToString(tagLocalName, aStr), NS_ERROR_OUT_OF_MEMORY);
+    if (!mNameSpaceStack.Length()
+        && tagNamespaceURI.EqualsLiteral("http://www.w3.org/1999/xhtml")
+        && !tagLocalName.EqualsLiteral("html"))
+      addNSAttr = false;
 
-  MaybeEnterInPreContent(content);
+    // Serialize the qualified name of the element
+    AppendToString(kLessThan, aStr);
+    if (!tagPrefix.IsEmpty()) {
+      AppendToString(tagPrefix, aStr);
+      AppendToString(NS_LITERAL_STRING(":"), aStr);
+    }
+    AppendToString(tagLocalName, aStr);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    NS_ENSURE_TRUE(IncrIndentation(name), NS_ERROR_OUT_OF_MEMORY);
-  }
+    MaybeEnterInPreContent(content);
 
-  NS_ENSURE_TRUE(SerializeAttributes(content, aOriginalElement, tagPrefix, tagNamespaceURI,
-                                     name, aStr, skipAttr, addNSAttr),
-                 NS_ERROR_OUT_OF_MEMORY);
+    if ((mDoFormat || forceFormat) && !PreLevel() && !mDoRaw) {
+      IncrIndentation(name);
+    }
 
-  NS_ENSURE_TRUE(AppendEndOfElementStart(aElement, aOriginalElement, aStr),
-                 NS_ERROR_OUT_OF_MEMORY);
+    SerializeAttributes(content, aOriginalElement, tagPrefix, tagNamespaceURI,
+                        name, aStr, skipAttr, addNSAttr);
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()
-    && LineBreakAfterOpen(content->GetNameSpaceID(), name)) {
-    NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
+    AppendEndOfElementStart(aElement, aOriginalElement,
+                            aStr);
+
+    if ((mDoFormat || forceFormat) && !PreLevel()
+      && !mDoRaw && LineBreakAfterOpen(content->GetNameSpaceID(), name)) {
+      AppendNewLineToString(aStr);
+    }
   }
 
   NS_ENSURE_TRUE(AfterElementStart(content, aOriginalElement, aStr), NS_ERROR_OUT_OF_MEMORY);
 
   return NS_OK;
 }
 
 // aElement is the actual element we're outputting.  aOriginalElement is the one
@@ -1029,81 +1058,82 @@ nsXMLContentSerializer::AppendEndOfEleme
 NS_IMETHODIMP 
 nsXMLContentSerializer::AppendElementEnd(Element* aElement,
                                          nsAString& aStr)
 {
   NS_ENSURE_ARG(aElement);
 
   nsIContent* content = aElement;
 
-  bool forceFormat = false, outputElementEnd;
-  outputElementEnd = CheckElementEnd(aElement, forceFormat, aStr);
-
-  nsIAtom *name = content->NodeInfo()->NameAtom();
-
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
-    DecrIndentation(name);
-  }
-
-  if (!outputElementEnd) {
-    PopNameSpaceDeclsFor(aElement);
-    MaybeFlagNewlineForRootNode(aElement);
-    return NS_OK;
-  }
-
   nsAutoString tagPrefix, tagLocalName, tagNamespaceURI;
-  
   aElement->NodeInfo()->GetPrefix(tagPrefix);
   aElement->NodeInfo()->GetName(tagLocalName);
   aElement->NodeInfo()->GetNamespaceURI(tagNamespaceURI);
 
+  bool hideTag = tagNamespaceURI.LowerCaseEqualsLiteral("http://disruptive-innovations.com/zoo/bluegriffon");
+  if (!hideTag) {
+    bool forceFormat = false, outputElementEnd;
+    outputElementEnd = CheckElementEnd(aElement, forceFormat, aStr);
+
+    nsIAtom *name = content->NodeInfo()->NameAtom();
+
+    if ((mDoFormat || forceFormat) && !PreLevel() && !mDoRaw) {
+      DecrIndentation(name);
+    }
+
+    if (!outputElementEnd) {
+      PopNameSpaceDeclsFor(aElement);
+      MaybeFlagNewlineForRootNode(aElement);
+      return NS_OK;
+    }
+
 #ifdef DEBUG
-  bool debugNeedToPushNamespace =
+    bool debugNeedToPushNamespace =
 #endif
-  ConfirmPrefix(tagPrefix, tagNamespaceURI, aElement, false);
-  NS_ASSERTION(!debugNeedToPushNamespace, "Can't push namespaces in closing tag!");
+    ConfirmPrefix(tagPrefix, tagNamespaceURI, aElement, false);
+    NS_ASSERTION(!debugNeedToPushNamespace, "Can't push namespaces in closing tag!");
 
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
+    if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()) {
 
-    bool lineBreakBeforeClose = LineBreakBeforeClose(content->GetNameSpaceID(), name);
+      bool lineBreakBeforeClose = LineBreakBeforeClose(content->GetNameSpaceID(), name);
 
-    if (mColPos && lineBreakBeforeClose) {
-      NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-    }
-    if (!mColPos) {
-      NS_ENSURE_TRUE(AppendIndentation(aStr), NS_ERROR_OUT_OF_MEMORY);
+      if (mColPos && lineBreakBeforeClose) {
+        AppendNewLineToString(aStr);
+      }
+      if (!mColPos) {
+        AppendIndentation(aStr);
+      }
+      else if (mAddSpace) {
+        AppendToString(char16_t(' '), aStr);
+        mAddSpace = false;
+      }
     }
     else if (mAddSpace) {
       NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
       mAddSpace = false;
     }
-  }
-  else if (mAddSpace) {
-    NS_ENSURE_TRUE(AppendToString(char16_t(' '), aStr), NS_ERROR_OUT_OF_MEMORY);
-    mAddSpace = false;
-  }
+    AppendToString(kEndTag, aStr);
+    if (!tagPrefix.IsEmpty()) {
+      AppendToString(tagPrefix, aStr);
+      AppendToString(NS_LITERAL_STRING(":"), aStr);
+    }
+    AppendToString(tagLocalName, aStr);
+    AppendToString(kGreaterThan, aStr);
 
-  NS_ENSURE_TRUE(AppendToString(kEndTag, aStr), NS_ERROR_OUT_OF_MEMORY);
-  if (!tagPrefix.IsEmpty()) {
-    NS_ENSURE_TRUE(AppendToString(tagPrefix, aStr), NS_ERROR_OUT_OF_MEMORY);
-    NS_ENSURE_TRUE(AppendToString(NS_LITERAL_STRING(":"), aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  NS_ENSURE_TRUE(AppendToString(tagLocalName, aStr), NS_ERROR_OUT_OF_MEMORY);
-  NS_ENSURE_TRUE(AppendToString(kGreaterThan, aStr), NS_ERROR_OUT_OF_MEMORY);
+    PopNameSpaceDeclsFor(aElement);
 
-  PopNameSpaceDeclsFor(aElement);
+    MaybeLeaveFromPreContent(content);
 
-  MaybeLeaveFromPreContent(content);
-
-  if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()
-      && LineBreakAfterClose(content->GetNameSpaceID(), name)) {
-    NS_ENSURE_TRUE(AppendNewLineToString(aStr), NS_ERROR_OUT_OF_MEMORY);
-  }
-  else {
-    MaybeFlagNewlineForRootNode(aElement);
+    if ((mDoFormat || forceFormat) && !mDoRaw && !PreLevel()
+        && LineBreakAfterClose(content->GetNameSpaceID(), name)) {
+      AppendNewLineToString(aStr);
+    }
+    else {
+      MaybeFlagNewlineForRootNode(aElement);
+    }
   }
 
   AfterElementEnd(content, aStr);
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
@@ -1183,16 +1213,33 @@ nsXMLContentSerializer::AppendToString(c
 bool
 nsXMLContentSerializer::AppendToString(const nsAString& aStr,
                                        nsAString& aOutputStr)
 {
   if (mBodyOnly && !mInBody) {
     return true;
   }
   mColPos += aStr.Length();
+  nsASingleFragmentString::const_char_iterator pos, end, sequenceStart;
+
+  aStr.BeginReading(pos);
+  aStr.EndReading(end);
+  bool foundCR = PR_FALSE;
+  bool foundOtherThanCROrBlank = PR_FALSE;
+  while (pos < end) {
+    if (*pos == '\n' || *pos == '\r')
+      foundCR = PR_TRUE;
+    else if (*pos != ' ' && *pos != '\t')
+      foundOtherThanCROrBlank = PR_TRUE;
+    pos++;
+  }
+
+  if (foundCR && !foundOtherThanCROrBlank) {
+    mMayIgnoreLineBreakSequence = PR_TRUE;
+  }
   return aOutputStr.Append(aStr, mozilla::fallible);
 }
 
 
 static const uint16_t kGTVal = 62;
 
 #define _ 0
 
@@ -1314,16 +1361,20 @@ nsXMLContentSerializer::MaybeLeaveFromPr
     if (space.EqualsLiteral("preserve"))
       --PreLevel();
   }
 }
 
 bool
 nsXMLContentSerializer::AppendNewLineToString(nsAString& aStr)
 {
+  if (!PreLevel() && mMayIgnoreLineBreakSequence) {
+    mMayIgnoreLineBreakSequence = PR_FALSE;
+    return true;
+  }
   bool result = AppendToString(mLineBreak, aStr);
   mMayIgnoreLineBreakSequence = true;
   mColPos = 0;
   mAddSpace = false;
   mIsIndentationAddedOnCurrentLine = false;
   return result;
 }
 
@@ -1622,19 +1673,39 @@ nsXMLContentSerializer::AppendWrapped_No
           if (!mColPos && mDoFormat) {
             NS_ENSURE_TRUE(AppendIndentation(aOutputStr), false);
           }
           else if (mAddSpace) {
             bool result = aOutputStr.Append(char16_t(' '), mozilla::fallible);
             mAddSpace = false;
             NS_ENSURE_TRUE(result, false);
           }
+          bool CRDone = PR_FALSE;
+          if (wrapPosition) {
+            CRDone = (*(aSequenceStart + wrapPosition - 1) == '\n');
+          }
           NS_ENSURE_TRUE(aOutputStr.Append(aSequenceStart, wrapPosition, mozilla::fallible), false);
 
-          NS_ENSURE_TRUE(AppendNewLineToString(aOutputStr), false);
+          if (CRDone) {
+            // we found a wrapping spot but there is a newline
+            // char right before that point... So we don't need another CR.
+            mMayIgnoreLineBreakSequence = PR_TRUE;
+            mColPos = 0;
+            mAddSpace = PR_FALSE;
+            mIsIndentationAddedOnCurrentLine = PR_FALSE;
+          }
+          else {
+            AppendNewLineToString(aOutputStr);
+          }
+
+          if (mDoFormat) {
+            AppendIndentation(aOutputStr);
+          }
+
+          mMayIgnoreLineBreakSequence = PR_TRUE;
           aPos = aSequenceStart + wrapPosition;
           aMayIgnoreStartOfLineWhitespaceSequence = true;
         }
         else {
           // try some simple fallback logic
           // go forward up to the next whitespace position,
           // in the worst case this will be all the rest of the data
 
diff --git a/dom/html/HTMLInputElement.cpp b/dom/html/HTMLInputElement.cpp
--- a/dom/html/HTMLInputElement.cpp
+++ b/dom/html/HTMLInputElement.cpp
@@ -116,16 +116,18 @@
 #include "HTMLSplitOnSpacesTokenizer.h"
 #include "nsIController.h"
 #include "nsIMIMEInfo.h"
 #include "nsFrameSelection.h"
 
 // input type=date
 #include "js/Date.h"
 
+#include "nsCSSParser.h"
+
 NS_IMPL_NS_NEW_HTML_ELEMENT_CHECK_PARSER(Input)
 
 // XXX align=left, hspace, vspace, border? other nav4 attrs
 
 static NS_DEFINE_CID(kXULControllersCID,  NS_XULCONTROLLERS_CID);
 
 // This must come outside of any namespace, or else it won't overload with the
 // double based version in nsMathUtils.h
@@ -596,19 +598,23 @@ HTMLInputElement::InitColorPicker()
   nsContentUtils::GetLocalizedString(nsContentUtils::eFORMS_PROPERTIES,
                                      "ColorPicker", title);
 
   nsCOMPtr<nsIColorPicker> colorPicker = do_CreateInstance("@mozilla.org/colorpicker;1");
   if (!colorPicker) {
     return NS_ERROR_FAILURE;
   }
 
+  nsAutoString showtransparency;
+  GetAttr(kNameSpaceID_None, nsGkAtoms::showtransparency, showtransparency);
+  PRBool showAlpha = showtransparency.EqualsLiteral("true");
+
   nsAutoString initialValue;
   GetValueInternal(initialValue);
-  nsresult rv = colorPicker->Init(win, title, initialValue);
+  nsresult rv = colorPicker->Init(win, title, initialValue, showAlpha);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsCOMPtr<nsIColorPickerShownCallback> callback =
     new nsColorPickerShownCallback(this, colorPicker);
 
   rv = colorPicker->Open(callback);
   if (NS_SUCCEEDED(rv)) {
     mPickerRunning = true;
@@ -4493,27 +4499,27 @@ HTMLInputElement::SanitizeValue(nsAStrin
         }
       }
       break;
   }
 }
 
 bool HTMLInputElement::IsValidSimpleColor(const nsAString& aValue) const
 {
-  if (aValue.Length() != 7 || aValue.First() != '#') {
+  nsCSSValue value;
+  nsCSSParser parser;
+  if (!parser.ParseColorString(aValue, nullptr, 0, value)) {
     return false;
   }
 
-  for (int i = 1; i < 7; ++i) {
-    if (!nsCRT::IsAsciiDigit(aValue[i]) &&
-        !(aValue[i] >= 'a' && aValue[i] <= 'f') &&
-        !(aValue[i] >= 'A' && aValue[i] <= 'F')) {
-      return false;
-    }
-  }
+  nscolor color;
+  if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
+    return false;
+  }
+
   return true;
 }
 
 bool
 HTMLInputElement::IsValidDate(const nsAString& aValue) const
 {
   uint32_t year, month, day;
   return GetValueAsDate(aValue, &year, &month, &day);
diff --git a/dom/html/HTMLInputElement.h b/dom/html/HTMLInputElement.h
--- a/dom/html/HTMLInputElement.h
+++ b/dom/html/HTMLInputElement.h
@@ -791,26 +791,28 @@ protected:
     VALUE_MODE_DEFAULT_ON,
     // On getting, returns "C:\fakepath\" followed by the file name of the
     // first file of the selected files if any.
     // On setting the empty string, empties the selected files list, otherwise
     // throw the INVALID_STATE_ERR exception.
     VALUE_MODE_FILENAME
   };
 
+public:
   /**
    * This helper method returns true if aValue is a valid email address.
    * This is following the HTML5 specification:
    * http://dev.w3.org/html5/spec/forms.html#valid-e-mail-address
    *
    * @param aValue  the email address to check.
    * @result        whether the given string is a valid email address.
    */
   static bool IsValidEmailAddress(const nsAString& aValue);
 
+protected:
   /**
    * This helper method returns true if aValue is a valid email address list.
    * Email address list is a list of email address separated by comas (,) which
    * can be surrounded by space charecters.
    * This is following the HTML5 specification:
    * http://dev.w3.org/html5/spec/forms.html#valid-e-mail-address-list
    *
    * @param aValue  the email address list to check.
diff --git a/dom/interfaces/core/nsIDOMDocument.idl b/dom/interfaces/core/nsIDOMDocument.idl
--- a/dom/interfaces/core/nsIDOMDocument.idl
+++ b/dom/interfaces/core/nsIDOMDocument.idl
@@ -28,17 +28,17 @@ interface nsIDOMLocation;
  * cannot exist outside the context of a Document, the nsIDOMDocument 
  * interface also contains the factory methods needed to create these 
  * objects.
  *
  * For more information on this interface please see 
  * http://dvcs.w3.org/hg/domcore/raw-file/tip/Overview.html
  */
 
-[uuid(b15fa0f4-97c1-4388-af62-2ceff7a89bdf)]
+[uuid(D792B34B-8419-4729-9E09-43C61DC2FACE)]
 interface nsIDOMDocument : nsIDOMNode
 {
   readonly attribute nsIDOMDocumentType         doctype;
   readonly attribute nsIDOMDOMImplementation    implementation;
   readonly attribute nsIDOMElement              documentElement;
   nsIDOMElement                 createElement([Null(Stringify)] in DOMString tagName)
                                   raises(DOMException);
   nsIDOMDocumentFragment        createDocumentFragment();
@@ -75,16 +75,19 @@ interface nsIDOMDocument : nsIDOMNode
   // Introduced in DOM Level 3:
   readonly attribute DOMString       documentURI;
   // Alias introduced for all documents in recent DOM standards
   readonly attribute DOMString       URL;
   // Introduced in DOM Level 3:
   nsIDOMNode         adoptNode(in nsIDOMNode source)
                                         raises(DOMException);
 
+  // BLUEGRIFFON
+  readonly attribute boolean hasXMLDeclaration;
+
   /**
    * Create a range
    *
    * @see http://html5.org/specs/dom-range.html#dom-document-createrange
    */
   nsIDOMRange              createRange();
 
   [optional_argc] nsIDOMNodeIterator createNodeIterator(in nsIDOMNode root,
diff --git a/dom/ipc/ColorPickerParent.cpp b/dom/ipc/ColorPickerParent.cpp
--- a/dom/ipc/ColorPickerParent.cpp
+++ b/dom/ipc/ColorPickerParent.cpp
@@ -56,17 +56,17 @@ ColorPickerParent::CreateColorPicker()
     return false;
   }
 
   nsCOMPtr<nsPIDOMWindowOuter> window = ownerElement->OwnerDoc()->GetWindow();
   if (!window) {
     return false;
   }
 
-  return NS_SUCCEEDED(mPicker->Init(window, mTitle, mInitialColor));
+  return NS_SUCCEEDED(mPicker->Init(window, mTitle, mInitialColor, mShowsAlpha));
 }
 
 bool
 ColorPickerParent::RecvOpen()
 {
   if (!CreateColorPicker()) {
     Unused << Send__delete__(this, mInitialColor);
     return true;
diff --git a/dom/ipc/ColorPickerParent.h b/dom/ipc/ColorPickerParent.h
--- a/dom/ipc/ColorPickerParent.h
+++ b/dom/ipc/ColorPickerParent.h
@@ -12,19 +12,21 @@
 
 namespace mozilla {
 namespace dom {
 
 class ColorPickerParent : public PColorPickerParent
 {
  public:
   ColorPickerParent(const nsString& aTitle,
-                    const nsString& aInitialColor)
+                    const nsString& aInitialColor,
+                    bool aShowsAlpha)
   : mTitle(aTitle)
   , mInitialColor(aInitialColor)
+  , mShowsAlpha(aShowsAlpha)
   {}
 
   virtual bool RecvOpen() override;
   virtual void ActorDestroy(ActorDestroyReason aWhy) override;
 
   class ColorPickerShownCallback final
     : public nsIColorPickerShownCallback
   {
@@ -48,14 +50,15 @@ class ColorPickerParent : public PColorP
 
   bool CreateColorPicker();
 
   RefPtr<ColorPickerShownCallback> mCallback;
   nsCOMPtr<nsIColorPicker> mPicker;
 
   nsString mTitle;
   nsString mInitialColor;
+  bool     mShowsAlpha;
 };
 
 } // namespace dom
 } // namespace mozilla
 
 #endif // mozilla_dom_ColorPickerParent_h
diff --git a/dom/ipc/PBrowser.ipdl b/dom/ipc/PBrowser.ipdl
--- a/dom/ipc/PBrowser.ipdl
+++ b/dom/ipc/PBrowser.ipdl
@@ -376,17 +376,17 @@ parent:
      */
     async ShowTooltip(uint32_t x, uint32_t y, nsString tooltip);
     async HideTooltip();
 
     /**
      * Create an asynchronous color picker on the parent side,
      * but don't open it yet.
      */
-    async PColorPicker(nsString title, nsString initialColor);
+    async PColorPicker(nsString title, nsString initialColor, bool showsAlpha);
 
     async PFilePicker(nsString aTitle, int16_t aMode);
 
     /**
      * Initiates an asynchronous request for one of the special indexedDB
      * permissions for the provided principal.
      *
      * @param principal
diff --git a/dom/ipc/TabChild.cpp b/dom/ipc/TabChild.cpp
--- a/dom/ipc/TabChild.cpp
+++ b/dom/ipc/TabChild.cpp
@@ -2177,17 +2177,17 @@ TabChild::RecvPDocumentRendererConstruct
                                       renderSize, data);
     if (!ret)
         return true; // silently ignore
 
     return PDocumentRendererChild::Send__delete__(actor, renderSize, data);
 }
 
 PColorPickerChild*
-TabChild::AllocPColorPickerChild(const nsString&, const nsString&)
+TabChild::AllocPColorPickerChild(const nsString&, const nsString&, const bool &)
 {
   NS_RUNTIMEABORT("unused");
   return nullptr;
 }
 
 bool
 TabChild::DeallocPColorPickerChild(PColorPickerChild* aColorPicker)
 {
diff --git a/dom/ipc/TabChild.h b/dom/ipc/TabChild.h
--- a/dom/ipc/TabChild.h
+++ b/dom/ipc/TabChild.h
@@ -442,17 +442,18 @@ public:
                                    const nsString& aBgcolor,
                                    const uint32_t& aRenderFlags,
                                    const bool& aFlushLayout,
                                    const nsIntSize& aRenderSize) override;
 
 
   virtual PColorPickerChild*
   AllocPColorPickerChild(const nsString& aTitle,
-                         const nsString& aInitialColor) override;
+                         const nsString& aInitialColor,
+                         const bool &showsAlpha) override;
 
   virtual bool DeallocPColorPickerChild(PColorPickerChild* aActor) override;
 
   virtual PFilePickerChild*
   AllocPFilePickerChild(const nsString& aTitle, const int16_t& aMode) override;
 
   virtual bool
   DeallocPFilePickerChild(PFilePickerChild* aActor) override;
diff --git a/dom/ipc/TabParent.cpp b/dom/ipc/TabParent.cpp
--- a/dom/ipc/TabParent.cpp
+++ b/dom/ipc/TabParent.cpp
@@ -2528,19 +2528,20 @@ TabParent::GetAuthPrompt(uint32_t aPromp
   }
 
   *aResult = prompt.forget().take();
   return NS_OK;
 }
 
 PColorPickerParent*
 TabParent::AllocPColorPickerParent(const nsString& aTitle,
-                                   const nsString& aInitialColor)
+                                   const nsString& aInitialColor,
+                                   const bool &aShowsAlpha)
 {
-  return new ColorPickerParent(aTitle, aInitialColor);
+  return new ColorPickerParent(aTitle, aInitialColor, aShowsAlpha);
 }
 
 bool
 TabParent::DeallocPColorPickerParent(PColorPickerParent* actor)
 {
   delete actor;
   return true;
 }
diff --git a/dom/ipc/TabParent.h b/dom/ipc/TabParent.h
--- a/dom/ipc/TabParent.h
+++ b/dom/ipc/TabParent.h
@@ -303,17 +303,18 @@ public:
   virtual bool
   RecvDispatchMouseEvent(const mozilla::WidgetMouseEvent& aEvent) override;
 
   virtual bool
   RecvDispatchKeyboardEvent(const mozilla::WidgetKeyboardEvent& aEvent) override;
 
   virtual PColorPickerParent*
   AllocPColorPickerParent(const nsString& aTitle,
-                          const nsString& aInitialColor) override;
+                          const nsString& aInitialColor,
+                          const bool &aShowsAlpha) override;
 
   virtual bool
   DeallocPColorPickerParent(PColorPickerParent* aColorPicker) override;
 
   virtual PDocAccessibleParent*
   AllocPDocAccessibleParent(PDocAccessibleParent*, const uint64_t&) override;
 
   virtual bool DeallocPDocAccessibleParent(PDocAccessibleParent*) override;
diff --git a/dom/xbl/nsXBLContentSink.cpp b/dom/xbl/nsXBLContentSink.cpp
--- a/dom/xbl/nsXBLContentSink.cpp
+++ b/dom/xbl/nsXBLContentSink.cpp
@@ -164,16 +164,18 @@ nsXBLContentSink::FlushText(bool aReleas
 
   return nsXMLContentSink::FlushText(aReleaseTextNode);
 }
 
 NS_IMETHODIMP
 nsXBLContentSink::ReportError(const char16_t* aErrorText, 
                               const char16_t* aSourceText,
                               nsIScriptError *aError,
+                              uint32_t aLineNumber,
+                              uint32_t aColNumber,
                               bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 
   // XXX FIXME This function overrides and calls on
   // nsXMLContentSink::ReportError, and probably should die.  See bug 347826.
 
   // XXX We should make sure the binding has no effect, but that it also
@@ -189,16 +191,18 @@ nsXBLContentSink::ReportError(const char
           NS_LossyConvertUTF16toASCII(aSourceText).get());
 #endif
 
   // Most of what this does won't be too useful, but whatever...
   // nsXMLContentSink::ReportError will handle the console logging.
   return nsXMLContentSink::ReportError(aErrorText, 
                                        aSourceText, 
                                        aError,
+                                       aLineNumber,
+                                       aColNumber,
                                        _retval);
 }
 
 nsresult
 nsXBLContentSink::ReportUnexpectedElement(nsIAtom* aElementName,
                                           uint32_t aLineNumber)
 {
   // XXX we should really somehow stop the parse and drop the binding
diff --git a/dom/xbl/nsXBLContentSink.h b/dom/xbl/nsXBLContentSink.h
--- a/dom/xbl/nsXBLContentSink.h
+++ b/dom/xbl/nsXBLContentSink.h
@@ -116,16 +116,18 @@ protected:
 
   // nsXMLContentSink overrides
   nsresult FlushText(bool aReleaseTextNode = true) override;
 
   // nsIExpatSink overrides
   NS_IMETHOD ReportError(const char16_t* aErrorText,
                          const char16_t* aSourceText,
                          nsIScriptError *aError,
+                         uint32_t aLineNumber,
+                         uint32_t aColNumber,
                          bool *_retval) override;
 
 protected:
   nsresult ReportUnexpectedElement(nsIAtom* aElementName, uint32_t aLineNumber);
 
   void AddMember(nsXBLProtoImplMember* aMember);
   void AddField(nsXBLProtoImplField* aField);
   
diff --git a/dom/xml/nsXMLContentSink.cpp b/dom/xml/nsXMLContentSink.cpp
--- a/dom/xml/nsXMLContentSink.cpp
+++ b/dom/xml/nsXMLContentSink.cpp
@@ -1277,16 +1277,18 @@ nsXMLContentSink::HandleXMLDeclaration(c
 
   return DidProcessATokenImpl();
 }
 
 NS_IMETHODIMP
 nsXMLContentSink::ReportError(const char16_t* aErrorText,
                               const char16_t* aSourceText,
                               nsIScriptError *aError,
+                              uint32_t aLineNumber,
+                              uint32_t aColNumber,
                               bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
   nsresult rv = NS_OK;
 
   // The expat driver should report the error.  We're just cleaning up the mess.
   *_retval = true;
 
@@ -1328,26 +1330,34 @@ nsXMLContentSink::ReportError(const char
   // release the nodes on stack
   mContentStack.Clear();
   mNotifyLevel = 0;
 
   rv = HandleProcessingInstruction(MOZ_UTF16("xml-stylesheet"),
                                    MOZ_UTF16("href=\"chrome://global/locale/intl.css\" type=\"text/css\""));
   NS_ENSURE_SUCCESS(rv, rv);
 
-  const char16_t* noAtts[] = { 0, 0 };
+  nsAutoString lineString, colString;
+  lineString.AppendInt(aLineNumber);
+  colString.AppendInt(aColNumber);
+  const char16_t* noAtts[] = { NS_LITERAL_STRING("line").get(),
+                                lineString.get(),
+                                NS_LITERAL_STRING("col").get(),
+                                colString.get(),
+                                0,
+                                0 };
 
   NS_NAMED_LITERAL_STRING(errorNs,
                           "http://www.mozilla.org/newlayout/xml/parsererror.xml");
 
   nsAutoString parsererror(errorNs);
   parsererror.Append((char16_t)0xFFFF);
   parsererror.AppendLiteral("parsererror");
 
-  rv = HandleStartElement(parsererror.get(), noAtts, 0, (uint32_t)-1,
+  rv = HandleStartElement(parsererror.get(), noAtts, 2, (uint32_t)-1,
                           false);
   NS_ENSURE_SUCCESS(rv, rv);
 
   rv = HandleCharacterData(aErrorText, NS_strlen(aErrorText), false);
   NS_ENSURE_SUCCESS(rv, rv);
 
   nsAutoString sourcetext(errorNs);
   sourcetext.Append((char16_t)0xFFFF);
diff --git a/dom/xml/nsXMLFragmentContentSink.cpp b/dom/xml/nsXMLFragmentContentSink.cpp
--- a/dom/xml/nsXMLFragmentContentSink.cpp
+++ b/dom/xml/nsXMLFragmentContentSink.cpp
@@ -53,16 +53,18 @@ public:
   NS_IMETHOD HandleProcessingInstruction(const char16_t* aTarget,
                                          const char16_t* aData) override;
   NS_IMETHOD HandleXMLDeclaration(const char16_t* aVersion,
                                   const char16_t* aEncoding,
                                   int32_t aStandalone) override;
   NS_IMETHOD ReportError(const char16_t* aErrorText,
                          const char16_t* aSourceText,
                          nsIScriptError* aError,
+                         uint32_t aLineNumber,
+                         uint32_t aColNumber,
                          bool* aRetval) override;
 
   // nsIContentSink
   NS_IMETHOD WillBuildModel(nsDTDMode aDTDMode) override;
   NS_IMETHOD DidBuildModel(bool aTerminated) override;
   NS_IMETHOD SetDocumentCharset(nsACString& aCharset) override;
   virtual nsISupports* GetTarget() override;
   NS_IMETHOD DidProcessATokenImpl();
@@ -281,16 +283,18 @@ nsXMLFragmentContentSink::HandleXMLDecla
   NS_NOTREACHED("fragments shouldn't have XML declarations");
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsXMLFragmentContentSink::ReportError(const char16_t* aErrorText, 
                                       const char16_t* aSourceText,
                                       nsIScriptError *aError,
+                                      uint32_t aLineNumber,
+                                      uint32_t aColNumber,
                                       bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 
   // The expat driver should report the error.
   *_retval = true;
 
   mParseError = true;
diff --git a/dom/xslt/xslt/txMozillaStylesheetCompiler.cpp b/dom/xslt/xslt/txMozillaStylesheetCompiler.cpp
--- a/dom/xslt/xslt/txMozillaStylesheetCompiler.cpp
+++ b/dom/xslt/xslt/txMozillaStylesheetCompiler.cpp
@@ -201,16 +201,18 @@ txStylesheetSink::HandleXMLDeclaration(c
 {
     return NS_OK;
 }
 
 NS_IMETHODIMP
 txStylesheetSink::ReportError(const char16_t *aErrorText,
                               const char16_t *aSourceText,
                               nsIScriptError *aError,
+                              uint32_t aLineNumber,
+                              uint32_t aColNumber,
                               bool *_retval)
 {
     NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 
     // The expat driver should report the error.
     *_retval = true;
 
     mCompiler->cancel(NS_ERROR_FAILURE, aErrorText, aSourceText);
diff --git a/dom/xul/nsXULContentSink.cpp b/dom/xul/nsXULContentSink.cpp
--- a/dom/xul/nsXULContentSink.cpp
+++ b/dom/xul/nsXULContentSink.cpp
@@ -647,16 +647,18 @@ XULContentSinkImpl::HandleXMLDeclaration
   return NS_OK;
 }
 
 
 NS_IMETHODIMP
 XULContentSinkImpl::ReportError(const char16_t* aErrorText,
                                 const char16_t* aSourceText,
                                 nsIScriptError *aError,
+                                uint32_t aLineNumber,
+                                uint32_t aColNumber,
                                 bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 
   // The expat driver should report the error.
   *_retval = true;
 
   nsresult rv = NS_OK;
diff --git a/editor/composer/nsComposerCommands.cpp b/editor/composer/nsComposerCommands.cpp
--- a/editor/composer/nsComposerCommands.cpp
+++ b/editor/composer/nsComposerCommands.cpp
@@ -206,16 +206,23 @@ nsStyleUpdatingCommand::ToggleState(nsIE
 
   //create some params now...
   nsresult rv;
   nsCOMPtr<nsICommandParams> params =
       do_CreateInstance(NS_COMMAND_PARAMS_CONTRACTID,&rv);
   if (NS_FAILED(rv) || !params)
     return rv;
 
+  bool isCSS;
+  htmlEditor->GetIsCSSEnabled(&isCSS);
+  if (isCSS
+      && (mTagName == nsGkAtoms::b
+          || mTagName == nsGkAtoms::i
+          || mTagName == nsGkAtoms::u))
+    htmlEditor->SetIsCSSEnabled(false);
   // tags "href" and "name" are special cases in the core editor
   // they are used to remove named anchor/link and shouldn't be used for insertion
   bool doTagRemoval;
   if (mTagName == nsGkAtoms::href || mTagName == nsGkAtoms::name) {
     doTagRemoval = true;
   } else {
     // check current selection; set doTagRemoval if formatting should be removed
     rv = GetCurrentState(aEditor, params);
@@ -247,16 +254,17 @@ nsStyleUpdatingCommand::ToggleState(nsIE
       rv = RemoveTextProperty(htmlEditor, tagName);
     }
     if (NS_SUCCEEDED(rv))
       rv = SetTextProperty(htmlEditor, tagName);
 
     aEditor->EndTransaction();
   }
 
+  htmlEditor->SetIsCSSEnabled(isCSS);
   return rv;
 }
 
 nsListCommand::nsListCommand(nsIAtom* aTagName)
 : nsBaseStateUpdatingCommand(aTagName)
 {
 }
 
@@ -461,17 +469,25 @@ nsIndentCommand::IsCommandEnabled(const 
 NS_IMETHODIMP
 nsIndentCommand::DoCommand(const char *aCommandName, nsISupports *refCon)
 {
   nsCOMPtr<nsIHTMLEditor> editor = do_QueryInterface(refCon);
 
   nsresult rv = NS_OK;
   if (editor)
   {
+    bool isCssEnabled;
+    nsresult rv = editor->GetIsCSSEnabled(&isCssEnabled);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = editor->SetIsCSSEnabled(true);
+    NS_ENSURE_SUCCESS(rv, rv);
+
     rv = editor->Indent(NS_LITERAL_STRING("indent"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = editor->SetIsCSSEnabled(isCssEnabled);
   }
 
   return rv;
 }
 
 NS_IMETHODIMP
 nsIndentCommand::DoCommandParams(const char *aCommandName,
                                  nsICommandParams *aParams,
@@ -510,17 +526,27 @@ nsOutdentCommand::IsCommandEnabled(const
 }
 
 
 NS_IMETHODIMP
 nsOutdentCommand::DoCommand(const char *aCommandName, nsISupports *refCon)
 {
   nsCOMPtr<nsIHTMLEditor> htmlEditor = do_QueryInterface(refCon);
   if (htmlEditor)
-    return htmlEditor->Indent(NS_LITERAL_STRING("outdent"));
+  {
+    bool isCssEnabled;
+    nsresult rv = htmlEditor->GetIsCSSEnabled(&isCssEnabled);
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = htmlEditor->SetIsCSSEnabled(true);
+    NS_ENSURE_SUCCESS(rv, rv);
+
+    rv = htmlEditor->Indent(NS_LITERAL_STRING("outdent"));
+    NS_ENSURE_SUCCESS(rv, rv);
+    rv = htmlEditor->SetIsCSSEnabled(isCssEnabled);
+  }
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsOutdentCommand::DoCommandParams(const char *aCommandName,
                                   nsICommandParams *aParams,
                                   nsISupports *refCon)
@@ -921,22 +947,31 @@ nsAlignCommand::nsAlignCommand()
 nsresult
 nsAlignCommand::GetCurrentState(nsIEditor *aEditor, nsICommandParams *aParams)
 {
   NS_ASSERTION(aEditor, "Need an editor here");
 
   nsCOMPtr<nsIHTMLEditor> htmlEditor = do_QueryInterface(aEditor);
   NS_ENSURE_TRUE(htmlEditor, NS_ERROR_FAILURE);
 
+  bool isCssEnabled;
+  nsresult rv = htmlEditor->GetIsCSSEnabled(&isCssEnabled);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = htmlEditor->SetIsCSSEnabled(true);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   nsIHTMLEditor::EAlignment firstAlign;
   bool outMixed;
-  nsresult rv = htmlEditor->GetAlignment(&outMixed, &firstAlign);
+  rv = htmlEditor->GetAlignment(&outMixed, &firstAlign);
 
   NS_ENSURE_SUCCESS(rv, rv);
 
+  rv = htmlEditor->SetIsCSSEnabled(isCssEnabled);
+  NS_ENSURE_SUCCESS(rv, rv);
+
   nsAutoString outStateString;
   switch (firstAlign)
   {
     default:
     case nsIHTMLEditor::eLeft:
       outStateString.AssignLiteral("left");
       break;
 
@@ -962,17 +997,24 @@ nsAlignCommand::GetCurrentState(nsIEdito
 nsresult
 nsAlignCommand::SetState(nsIEditor *aEditor, nsString& newState)
 {
   NS_ASSERTION(aEditor, "Need an editor here");
 
   nsCOMPtr<nsIHTMLEditor> htmlEditor = do_QueryInterface(aEditor);
   NS_ENSURE_TRUE(htmlEditor, NS_ERROR_FAILURE);
 
-  return htmlEditor->Align(newState);
+  bool isCssEnabled;
+  nsresult rv = htmlEditor->GetIsCSSEnabled(&isCssEnabled);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = htmlEditor->SetIsCSSEnabled(true);
+  NS_ENSURE_SUCCESS(rv, rv);
+  rv = htmlEditor->Align(newState);
+  NS_ENSURE_SUCCESS(rv, rv);
+  return htmlEditor->SetIsCSSEnabled(isCssEnabled);
 }
 
 nsAbsolutePositioningCommand::nsAbsolutePositioningCommand()
 : nsBaseStateUpdatingCommand(nsGkAtoms::_empty)
 {
 }
 
 NS_IMETHODIMP
diff --git a/editor/libeditor/nsEditor.cpp b/editor/libeditor/nsEditor.cpp
--- a/editor/libeditor/nsEditor.cpp
+++ b/editor/libeditor/nsEditor.cpp
@@ -100,16 +100,17 @@
 #include "nsStyleSheetTxns.h"           // for AddStyleSheetTxn, etc
 #include "nsStyleStruct.h"              // for nsStyleDisplay, nsStyleText, etc
 #include "nsStyleStructFwd.h"           // for nsIFrame::StyleUIReset, etc
 #include "nsTextEditUtils.h"            // for nsTextEditUtils
 #include "nsTextNode.h"                 // for nsTextNode
 #include "nsThreadUtils.h"              // for nsRunnable
 #include "nsTransactionManager.h"       // for nsTransactionManager
 #include "prtime.h"                     // for PR_Now
+#include "nsIEditorMouseObserver.h"
 
 class nsIOutputStream;
 class nsIParserService;
 class nsITransferable;
 
 #ifdef DEBUG
 #include "nsIDOMHTMLDocument.h"         // for nsIDOMHTMLDocument
 #endif
@@ -169,16 +170,17 @@ NS_IMPL_CYCLE_COLLECTION_CLASS(nsEditor)
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsEditor)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mRootElement)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mInlineSpellChecker)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mTxnMgr)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mIMETextNode)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mActionListeners)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mEditorObservers)
+ NS_IMPL_CYCLE_COLLECTION_UNLINK(mEditorMouseObservers)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mDocStateListeners)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mEventTarget)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mEventListener)
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mSavedSel);
  NS_IMPL_CYCLE_COLLECTION_UNLINK(mRangeUpdater);
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsEditor)
@@ -189,16 +191,17 @@ NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(
    return NS_SUCCESS_INTERRUPTED_TRAVERSE;
  }
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mRootElement)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mInlineSpellChecker)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mTxnMgr)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mIMETextNode)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mActionListeners)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEditorObservers)
+ NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEditorMouseObservers)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mDocStateListeners)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEventTarget)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mEventListener)
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mSavedSel);
  NS_IMPL_CYCLE_COLLECTION_TRAVERSE(mRangeUpdater);
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsEditor)
@@ -455,16 +458,17 @@ nsEditor::PreDestroy(bool aDestroyingFra
   NotifyDocumentListeners(eDocumentToBeDestroyed);
 
   // Unregister event listeners
   RemoveEventListeners();
   // If this editor is still hiding the caret, we need to restore it.
   HideCaret(false);
   mActionListeners.Clear();
   mEditorObservers.Clear();
+  mEditorMouseObservers.Clear();
   mDocStateListeners.Clear();
   mInlineSpellChecker = nullptr;
   mSpellcheckCheckboxState = eTriUnset;
   mRootElement = nullptr;
 
   mDidPreDestroy = true;
   return NS_OK;
 }
@@ -1745,16 +1749,46 @@ nsEditor::RemoveEditorObserver(nsIEditor
 {
   NS_ENSURE_TRUE(aObserver, NS_ERROR_FAILURE);
 
   mEditorObservers.RemoveElement(aObserver);
 
   return NS_OK;
 }
 
+NS_IMETHODIMP
+nsEditor::AddEditorMouseObserver(nsIEditorMouseObserver *aObserver)
+{
+  // we don't keep ownership of the observers.  They must
+  // remove themselves as observers before they are destroyed.
+
+  NS_ENSURE_TRUE(aObserver, NS_ERROR_NULL_POINTER);
+
+  // Make sure the listener isn't already on the list
+  if (mEditorMouseObservers.IndexOf(aObserver) == -1)
+  {
+    if (!mEditorMouseObservers.AppendObject(aObserver))
+      return NS_ERROR_FAILURE;
+  }
+
+  return NS_OK;
+}
+
+
+NS_IMETHODIMP
+nsEditor::RemoveEditorMouseObserver(nsIEditorMouseObserver *aObserver)
+{
+  NS_ENSURE_TRUE(aObserver, NS_ERROR_FAILURE);
+
+  if (!mEditorMouseObservers.RemoveObject(aObserver))
+    return NS_ERROR_FAILURE;
+
+  return NS_OK;
+}
+
 class EditorInputEventDispatcher : public nsRunnable
 {
 public:
   EditorInputEventDispatcher(nsEditor* aEditor,
                              nsIContent* aTarget,
                              bool aIsComposing)
     : mEditor(aEditor)
     , mTarget(aTarget)
@@ -1851,16 +1885,36 @@ nsEditor::FireInputEvent()
 
   // NOTE: Don't refer IsIMEComposing() because it returns false even before
   //       compositionend.  However, DOM Level 3 Events defines it should be
   //       true after compositionstart and before compositionend.
   nsContentUtils::AddScriptRunner(
     new EditorInputEventDispatcher(this, target, !!GetComposition()));
 }
 
+bool nsEditor::NotifyEditorMouseObservers(MouseEventType aMouseEventType,
+                                          int32_t aClientX,
+                                          int32_t aClientY,
+                                          nsIDOMNode* aTarget,
+                                          bool aIsShiftKey)
+{
+  bool rv = false;
+  for (int32_t i = 0; i < mEditorMouseObservers.Count(); i++) {
+    bool oneRv = false;
+    switch (aMouseEventType) {
+    case nsEditor::kMouseDown: mEditorMouseObservers[i]->MouseDown(aClientX, aClientY, aTarget, aIsShiftKey, &rv); break;
+    case nsEditor::kMouseUp:   mEditorMouseObservers[i]->MouseUp(aClientX, aClientY, aTarget, aIsShiftKey, &rv); break;
+    case nsEditor::kMouseMove: mEditorMouseObservers[i]->MouseMove(aClientX, aClientY, aTarget, aIsShiftKey, &rv); break;
+    }
+    rv |= oneRv;
+  }
+
+  return rv;
+}
+
 NS_IMETHODIMP
 nsEditor::AddEditActionListener(nsIEditActionListener *aListener)
 {
   NS_ENSURE_TRUE(aListener, NS_ERROR_NULL_POINTER);
 
   // Make sure the listener isn't already on the list
   if (!mActionListeners.Contains(aListener)) {
     mActionListeners.AppendElement(*aListener);
@@ -2658,16 +2712,45 @@ struct SavedRange {
   RefPtr<Selection> mSelection;
   nsCOMPtr<nsINode> mStartNode;
   nsCOMPtr<nsINode> mEndNode;
   int32_t mStartOffset;
   int32_t mEndOffset;
 };
 
 nsresult
+nsEditor::RemoveNonCopyableAttributes(nsIDOMElement * aElement)
+{
+  NS_ENSURE_TRUE(aElement, NS_ERROR_NULL_POINTER);
+  nsresult res = NS_OK;
+
+  nsCOMPtr<nsIDOMMozNamedAttrMap> attributes;
+  aElement->GetAttributes(getter_AddRefs(attributes));
+  NS_ENSURE_TRUE(attributes, NS_ERROR_FAILURE);
+  uint32_t attrCount;
+  attributes->GetLength(&attrCount);
+  nsCOMPtr<nsIDOMAttr> attr;
+  for (int32_t i = attrCount - 1; i >= 0; i--)   {
+    if (NS_SUCCEEDED(attributes->Item(i, getter_AddRefs(attr))) && attr) {
+      nsString attrName;
+      if (NS_SUCCEEDED(attr->GetName(attrName))) {
+        ToLowerCase(attrName);
+          if (StringBeginsWith(attrName, NS_LITERAL_STRING("its-")) ||
+              attrName.EqualsLiteral("translate") ||
+              attrName.EqualsLiteral("id")) {
+            res = RemoveAttribute(aElement, attrName);
+            NS_ENSURE_SUCCESS(res, res);
+        }
+      }
+    }
+  }
+  return res;
+}
+
+nsresult
 nsEditor::SplitNodeImpl(nsIContent& aExistingRightNode,
                         int32_t aOffset,
                         nsIContent& aNewLeftNode)
 {
   // Remember all selection points.
   AutoTArray<SavedRange, 10> savedRanges;
   for (size_t i = 0; i < nsISelectionController::NUM_SELECTIONTYPES - 1; ++i) {
     SelectionType type(1 << i);
@@ -3838,16 +3921,21 @@ nsEditor::SplitNodeDeep(nsIContent& aNod
     if ((aEmptyContainers == EmptyContainers::yes &&
          !nodeToSplit->GetAsText()) ||
         (offset && offset != (int32_t)nodeToSplit->Length())) {
       didSplit = true;
       ErrorResult rv;
       nsCOMPtr<nsIContent> newLeftNode = SplitNode(nodeToSplit, offset, rv);
       NS_ENSURE_TRUE(!NS_FAILED(rv.StealNSResult()), -1);
 
+      nsCOMPtr<nsIDOMElement> elt = do_QueryInterface(nodeToSplit);
+      if (elt) {
+        RemoveNonCopyableAttributes(elt);
+      }
+
       rightNode = nodeToSplit;
       leftNode = newLeftNode;
     }
 
     NS_ENSURE_TRUE(nodeToSplit->GetParent(), -1);
     OwningNonNull<nsIContent> parentNode = *nodeToSplit->GetParent();
 
     if (!didSplit && offset) {
diff --git a/editor/libeditor/nsEditor.h b/editor/libeditor/nsEditor.h
--- a/editor/libeditor/nsEditor.h
+++ b/editor/libeditor/nsEditor.h
@@ -145,16 +145,23 @@ class nsEditor : public nsIEditor,
 public:
 
   enum IterDirection
   {
     kIterForward,
     kIterBackward
   };
 
+  enum MouseEventType
+  {
+    kMouseDown,
+    kMouseUp,
+    kMouseMove
+  };
+
   /** The default constructor. This should suffice. the setting of the interfaces is done
    *  after the construction of the editor class.
    */
   nsEditor();
 
 protected:
   /** The default destructor. This should suffice. Should this be pure virtual
    *  for someone to derive from the nsEditor later? I don't believe so.
@@ -175,16 +182,21 @@ public:
   already_AddRefed<nsIWidget> GetWidget();
   enum NotificationForEditorObservers
   {
     eNotifyEditorObserversOfEnd,
     eNotifyEditorObserversOfBefore,
     eNotifyEditorObserversOfCancel
   };
   void NotifyEditorObservers(NotificationForEditorObservers aNotification);
+  bool NotifyEditorMouseObservers(MouseEventType aMouseEventType,
+                                  int32_t aClientX,
+                                  int32_t aClientY,
+                                  nsIDOMNode* aTarget,
+                                  bool aIsShiftKey);
 
   /* ------------ nsIEditor methods -------------- */
   NS_DECL_NSIEDITOR
 
   /* ------------ nsIEditorIMESupport methods -------------- */
   NS_DECL_NSIEDITORIMESUPPORT
 
   // nsIPhonetic
@@ -798,16 +810,18 @@ public:
                                           nsIDOMNode *aDestinationNode,
                                           int32_t aDestOffset,
                                           bool aDoDeleteSelection) = 0;
 
   virtual nsresult InsertFromDrop(nsIDOMEvent* aDropEvent) = 0;
 
   virtual already_AddRefed<nsIDOMNode> FindUserSelectAllNode(nsIDOMNode* aNode) { return nullptr; }
 
+  nsresult RemoveNonCopyableAttributes(nsIDOMElement * aElement);
+
   /**
    * GetIMESelectionStartOffsetIn() returns the start offset of IME selection in
    * the aTextNode.  If there is no IME selection, returns -1.
    */
   int32_t GetIMESelectionStartOffsetIn(nsINode* aTextNode);
 
   /**
    * FindBetterInsertionPoint() tries to look for better insertion point which
@@ -849,16 +863,18 @@ protected:
   // compositionend.
   RefPtr<mozilla::TextComposition> mComposition;
 
   // various listeners
   // Listens to all low level actions on the doc
   nsTArray<mozilla::OwningNonNull<nsIEditActionListener>> mActionListeners;
   // Just notify once per high level change
   nsTArray<mozilla::OwningNonNull<nsIEditorObserver>> mEditorObservers;
+  // Listen to mouse events
+  nsCOMArray<nsIEditorMouseObserver> mEditorMouseObservers;
   // Listen to overall doc state (dirty or not, just created, etc)
   nsTArray<mozilla::OwningNonNull<nsIDocumentStateListener>> mDocStateListeners;
 
   nsSelectionState  mSavedSel;           // cached selection for nsAutoSelectionReset
   nsRangeUpdater    mRangeUpdater;       // utility class object for maintaining preserved ranges
 
   uint32_t          mModCount;     // number of modifications (for undo/redo stack)
   uint32_t          mFlags;        // behavior flags. See nsIPlaintextEditor.idl for the flags we use.
diff --git a/editor/libeditor/nsEditorEventListener.cpp b/editor/libeditor/nsEditorEventListener.cpp
--- a/editor/libeditor/nsEditorEventListener.cpp
+++ b/editor/libeditor/nsEditorEventListener.cpp
@@ -181,16 +181,19 @@ nsEditorEventListener::InstallToEditor()
   //     code need to check if it's editable.  It makes easier create new bugs.
   elmP->AddEventListenerByType(this,
                                NS_LITERAL_STRING("mousedown"),
                                TrustedEventsAtCapture());
   elmP->AddEventListenerByType(this,
                                NS_LITERAL_STRING("mouseup"),
                                TrustedEventsAtCapture());
   elmP->AddEventListenerByType(this,
+                               NS_LITERAL_STRING("mousemove"),
+                               TrustedEventsAtCapture());
+  elmP->AddEventListenerByType(this,
                                NS_LITERAL_STRING("click"),
                                TrustedEventsAtCapture());
 // Focus event doesn't bubble so adding the listener to capturing phase.
 // Make sure this works after bug 235441 gets fixed.
   elmP->AddEventListenerByType(this,
                                NS_LITERAL_STRING("blur"),
                                TrustedEventsAtCapture());
   elmP->AddEventListenerByType(this,
@@ -272,16 +275,19 @@ nsEditorEventListener::UninstallFromEdit
                                   TrustedEventsAtSystemGroupBubble());
   elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("mousedown"),
                                   TrustedEventsAtCapture());
   elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("mouseup"),
                                   TrustedEventsAtCapture());
   elmP->RemoveEventListenerByType(this,
+                                  NS_LITERAL_STRING("mousemove"),
+                                  TrustedEventsAtCapture());
+  elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("click"),
                                   TrustedEventsAtCapture());
   elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("blur"),
                                   TrustedEventsAtCapture());
   elmP->RemoveEventListenerByType(this,
                                   NS_LITERAL_STRING("focus"),
                                   TrustedEventsAtCapture());
@@ -435,16 +441,22 @@ nsEditorEventListener::HandleEvent(nsIDO
       // only by eMouseClick case but click event is fired only in case #1.
       // So, before a click event is fired, mMouseDownOrUpConsumedByIME is
       // always initialized in the eMouseDown case if it's referred.
       if (NotifyIMEOfMouseButtonEvent(mouseEvent)) {
         mMouseDownOrUpConsumedByIME = true;
       }
       return mMouseDownOrUpConsumedByIME ? NS_OK : MouseUp(mouseEvent);
     }
+    // mousemove:
+    case eMouseMove: {
+      nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
+      NS_ENSURE_TRUE(mouseEvent, NS_OK);
+      return NS_OK;
+    }
     // click
     case eMouseClick: {
       nsCOMPtr<nsIDOMMouseEvent> mouseEvent = do_QueryInterface(aEvent);
       NS_ENSURE_TRUE(mouseEvent, NS_OK);
       // If the preceding mousedown event or mouseup event was consumed,
       // editor shouldn't handle this click event.
       if (mMouseDownOrUpConsumedByIME) {
         mMouseDownOrUpConsumedByIME = false;
diff --git a/editor/libeditor/nsEditorEventListener.h b/editor/libeditor/nsEditorEventListener.h
--- a/editor/libeditor/nsEditorEventListener.h
+++ b/editor/libeditor/nsEditorEventListener.h
@@ -58,16 +58,17 @@ protected:
   nsresult KeyUp(nsIDOMKeyEvent* aKeyEvent);
 #endif
   nsresult KeyPress(nsIDOMKeyEvent* aKeyEvent);
   nsresult HandleText(nsIDOMEvent* aTextEvent);
   nsresult HandleStartComposition(nsIDOMEvent* aCompositionEvent);
   void HandleEndComposition(nsIDOMEvent* aCompositionEvent);
   virtual nsresult MouseDown(nsIDOMMouseEvent* aMouseEvent);
   virtual nsresult MouseUp(nsIDOMMouseEvent* aMouseEvent) { return NS_OK; }
+  virtual nsresult MouseMove(nsIDOMMouseEvent* aMouseEvent) { return NS_OK; }
   virtual nsresult MouseClick(nsIDOMMouseEvent* aMouseEvent);
   nsresult Focus(nsIDOMEvent* aEvent);
   nsresult Blur(nsIDOMEvent* aEvent);
   nsresult DragEnter(nsIDOMDragEvent* aDragEvent);
   nsresult DragOver(nsIDOMDragEvent* aDragEvent);
   nsresult DragExit(nsIDOMDragEvent* aDragEvent);
   nsresult Drop(nsIDOMDragEvent* aDragEvent);
   nsresult DragGesture(nsIDOMDragEvent* aDragEvent);
diff --git a/editor/libeditor/nsHTMLCSSUtils.cpp b/editor/libeditor/nsHTMLCSSUtils.cpp
--- a/editor/libeditor/nsHTMLCSSUtils.cpp
+++ b/editor/libeditor/nsHTMLCSSUtils.cpp
@@ -309,21 +309,22 @@ nsHTMLCSSUtils::IsCSSEditableProperty(ns
   nsINode* node = aNode;
   // we need an element node here
   if (node->NodeType() == nsIDOMNode::TEXT_NODE) {
     node = node->GetParentNode();
     NS_ENSURE_TRUE(node, false);
   }
 
   // html inline styles B I TT U STRIKE and COLOR/FACE on FONT
-  if (nsGkAtoms::b == aProperty ||
-      nsGkAtoms::i == aProperty ||
+  if (//nsGkAtoms::b == aProperty ||
+      //nsGkAtoms::i == aProperty ||
       nsGkAtoms::tt == aProperty ||
-      nsGkAtoms::u == aProperty ||
+      //nsGkAtoms::u == aProperty ||
       nsGkAtoms::strike == aProperty ||
+      nsGkAtoms::nobr == aProperty ||
       (nsGkAtoms::font == aProperty && aAttribute &&
        (aAttribute->EqualsLiteral("color") ||
         aAttribute->EqualsLiteral("face")))) {
     return true;
   }
 
   // ALIGN attribute on elements supporting it
   if (aAttribute && (aAttribute->EqualsLiteral("align")) &&
@@ -792,16 +793,18 @@ nsHTMLCSSUtils::GenerateCSSDeclarationsF
   if (nsGkAtoms::b == aHTMLProperty) {
     equivTable = boldEquivTable;
   } else if (nsGkAtoms::i == aHTMLProperty) {
     equivTable = italicEquivTable;
   } else if (nsGkAtoms::u == aHTMLProperty) {
     equivTable = underlineEquivTable;
   } else if (nsGkAtoms::strike == aHTMLProperty) {
     equivTable = strikeEquivTable;
+  } else if (nsGkAtoms::nobr == aHTMLProperty) {
+    equivTable = nowrapEquivTable;
   } else if (nsGkAtoms::tt == aHTMLProperty) {
     equivTable = ttEquivTable;
   } else if (aAttribute) {
     if (nsGkAtoms::font == aHTMLProperty &&
         aAttribute->EqualsLiteral("color")) {
       equivTable = fontColorEquivTable;
     } else if (nsGkAtoms::font == aHTMLProperty &&
                aAttribute->EqualsLiteral("face")) {
diff --git a/editor/libeditor/nsHTMLDataTransfer.cpp b/editor/libeditor/nsHTMLDataTransfer.cpp
--- a/editor/libeditor/nsHTMLDataTransfer.cpp
+++ b/editor/libeditor/nsHTMLDataTransfer.cpp
@@ -1175,24 +1175,50 @@ nsHTMLEditor::InsertFromTransferable(nsI
           nsAutoCString text;
           textDataObj->GetData(text);
           NS_ASSERTION(text.Length() <= len, "Invalid length!");
           stuffToPaste.Assign(NS_ConvertUTF8toUTF16(Substring(text, 0, len)));
         }
       }
 
       if (!stuffToPaste.IsEmpty()) {
+
+        // Find where the <body> tag starts.
+        nsAString::const_iterator beginbody, endbody;
+        stuffToPaste.BeginReading(beginbody);
+        stuffToPaste.EndReading(endbody);
+        bool foundbody = CaseInsensitiveFindInReadable(NS_LITERAL_STRING("<body"),
+                                                         beginbody, endbody);
+        nsAutoString realStuffToPaste;
+        if (foundbody) {
+          nsAString::const_iterator endstartbody;
+          stuffToPaste.EndReading(endstartbody);
+         bool foundstartbody = CaseInsensitiveFindInReadable(NS_LITERAL_STRING(">"),
+                                                              endbody, endstartbody);
+          if (!foundstartbody)
+            return NS_ERROR_FAILURE;
+
+          nsAString::const_iterator beginclosebody, endclosebody;
+          stuffToPaste.BeginReading(beginclosebody);
+          stuffToPaste.EndReading(endclosebody);
+
+          // Find the index before "</body>"
+          CaseInsensitiveFindInReadable(NS_LITERAL_STRING("</body>"), beginclosebody, endclosebody);
+          realStuffToPaste.Assign(Substring(endstartbody, beginclosebody));
+        }
+        else
+          realStuffToPaste.Assign(stuffToPaste);
         nsAutoEditBatch beginBatching(this);
         if (0 == nsCRT::strcmp(bestFlavor, kHTMLMime)) {
-          rv = DoInsertHTMLWithContext(stuffToPaste,
+          rv = DoInsertHTMLWithContext(realStuffToPaste,
                                        aContextStr, aInfoStr, flavor,
                                        aSourceDoc,
                                        aDestinationNode, aDestOffset,
                                        aDoDeleteSelection,
-                                       isSafe);
+                                       true);
         } else {
           rv = InsertTextAt(stuffToPaste, aDestinationNode, aDestOffset, aDoDeleteSelection);
         }
       }
     }
   }
 
   // Try to scroll the selection into view if the paste succeeded
diff --git a/editor/libeditor/nsHTMLEditRules.cpp b/editor/libeditor/nsHTMLEditRules.cpp
--- a/editor/libeditor/nsHTMLEditRules.cpp
+++ b/editor/libeditor/nsHTMLEditRules.cpp
@@ -1388,55 +1388,18 @@ nsHTMLEditRules::WillInsertText(EditActi
     int32_t pos = 0;
     NS_NAMED_LITERAL_STRING(newlineStr, LFSTR);
 
     // for efficiency, break out the pre case separately.  This is because
     // its a lot cheaper to search the input string for only newlines than
     // it is to search for both tabs and newlines.
     if (isPRE || IsPlaintextEditor())
     {
-      while (unicodeBuf && (pos != -1) && (pos < (int32_t)(*inString).Length()))
-      {
-        int32_t oldPos = pos;
-        int32_t subStrLen;
-        pos = tString.FindChar(nsCRT::LF, oldPos);
-
-        if (pos != -1)
-        {
-          subStrLen = pos - oldPos;
-          // if first char is newline, then use just it
-          if (subStrLen == 0)
-            subStrLen = 1;
-        }
-        else
-        {
-          subStrLen = tString.Length() - oldPos;
-          pos = tString.Length();
-        }
-
-        nsDependentSubstring subStr(tString, oldPos, subStrLen);
-
-        // is it a return?
-        if (subStr.Equals(newlineStr))
-        {
-          NS_ENSURE_STATE(mHTMLEditor);
-          nsCOMPtr<Element> br =
-            mHTMLEditor->CreateBRImpl(address_of(curNode), &curOffset,
-                                      nsIEditor::eNone);
-          NS_ENSURE_STATE(br);
-          pos++;
-        }
-        else
-        {
-          NS_ENSURE_STATE(mHTMLEditor);
-          res = mHTMLEditor->InsertTextImpl(subStr, address_of(curNode),
-                                            &curOffset, doc);
-          NS_ENSURE_SUCCESS(res, res);
-        }
-      }
+      res = mHTMLEditor->InsertTextImpl(tString, address_of(curNode), &curOffset, doc);
+      NS_ENSURE_SUCCESS(res, res);
     }
     else
     {
       NS_NAMED_LITERAL_STRING(tabStr, "\t");
       NS_NAMED_LITERAL_STRING(spacesStr, "    ");
       char specialChars[] = {TAB, nsCRT::LF, 0};
       while (unicodeBuf && (pos != -1) && (pos < (int32_t)inString->Length()))
       {
@@ -4574,17 +4537,17 @@ nsHTMLEditRules::CreateStyleForInsertTex
       }
     }
 
     while (item) {
       NS_ENSURE_STATE(mHTMLEditor);
       nsCOMPtr<nsIContent> content = do_QueryInterface(node);
       NS_ENSURE_STATE(content || !node);
       res = mHTMLEditor->SetInlinePropertyOnNode(*content, *item->tag,
-                                                 &item->attr, item->value);
+                                                 &item->attr, item->value, false);
       NS_ENSURE_SUCCESS(res, res);
       item = mHTMLEditor->mTypeInState->TakeSetProperty();
     }
   }
   if (weDidSomething) {
     return aSelection->Collapse(node, offset);
   }
 
@@ -6635,16 +6598,17 @@ nsHTMLEditRules::SplitParagraph(nsIDOMNo
     aSelection->Collapse(child,0);
   }
   else
   {
     int32_t offset;
     nsCOMPtr<nsIDOMNode> parent = nsEditor::GetNodeLocation(child, &offset);
     aSelection->Collapse(parent,offset);
   }
+  ClearCachedStyles();
   return res;
 }
 
 
 ///////////////////////////////////////////////////////////////////////////
 // ReturnInListItem: do the right thing for returns pressed in list items
 //
 nsresult
@@ -6706,16 +6670,19 @@ nsHTMLEditRules::ReturnInListItem(Select
     }
     else
     {
       // otherwise kill this listitem
       NS_ENSURE_STATE(mHTMLEditor);
       res = mHTMLEditor->DeleteNode(aListItem);
       NS_ENSURE_SUCCESS(res, res);
 
+      ClearCachedStyles();
+      mHTMLEditor->mTypeInState->ClearAllProps();
+
       // time to insert a paragraph
       NS_NAMED_LITERAL_STRING(pType, "p");
       nsCOMPtr<nsIDOMNode> pNode;
       NS_ENSURE_STATE(mHTMLEditor);
       res = mHTMLEditor->CreateNode(pType, GetAsDOMNode(listParent),
                                     offset + 1, getter_AddRefs(pNode));
       NS_ENSURE_SUCCESS(res, res);
 
@@ -6767,16 +6734,18 @@ nsHTMLEditRules::ReturnInListItem(Select
         if (nodeAtom == nsGkAtoms::dd || nodeAtom == nsGkAtoms::dt) {
           int32_t itemOffset;
           nsCOMPtr<nsIDOMNode> list = nsEditor::GetNodeLocation(aListItem, &itemOffset);
 
           nsAutoString listTag(nodeAtom == nsGkAtoms::dt
             ? NS_LITERAL_STRING("dd") : NS_LITERAL_STRING("dt"));
           nsCOMPtr<nsIDOMNode> newListItem;
           NS_ENSURE_STATE(mHTMLEditor);
+          ClearCachedStyles();
+          mHTMLEditor->mTypeInState->ClearAllProps();
           res = mHTMLEditor->CreateNode(listTag, list, itemOffset+1, getter_AddRefs(newListItem));
           NS_ENSURE_SUCCESS(res, res);
           res = mEditor->DeleteNode(aListItem);
           NS_ENSURE_SUCCESS(res, res);
           return aSelection->Collapse(newListItem, 0);
         }
 
         nsCOMPtr<nsIDOMNode> brNode;
diff --git a/editor/libeditor/nsHTMLEditUtils.cpp b/editor/libeditor/nsHTMLEditUtils.cpp
--- a/editor/libeditor/nsHTMLEditUtils.cpp
+++ b/editor/libeditor/nsHTMLEditUtils.cpp
@@ -711,17 +711,17 @@ static const nsElementInfo kElements[eHT
   ELEM(mark, true, true, GROUP_PHRASE, GROUP_INLINE_ELEMENT),
   ELEM(marquee, false, false, GROUP_NONE, GROUP_NONE),
   ELEM(menu, true, true, GROUP_BLOCK, GROUP_LI | GROUP_FLOW_ELEMENT),
   ELEM(menuitem, false, false, GROUP_NONE, GROUP_NONE),
   ELEM(meta, false, false, GROUP_HEAD_CONTENT, GROUP_NONE),
   ELEM(meter, true, false, GROUP_SPECIAL, GROUP_FLOW_ELEMENT),
   ELEM(multicol, false, false, GROUP_NONE, GROUP_NONE),
   ELEM(nav, true, true, GROUP_BLOCK, GROUP_FLOW_ELEMENT),
-  ELEM(nobr, false, false, GROUP_NONE, GROUP_NONE),
+  ELEM(nobr, false, false, GROUP_PHRASE, GROUP_INLINE_ELEMENT),
   ELEM(noembed, false, false, GROUP_NONE, GROUP_NONE),
   ELEM(noframes, true, true, GROUP_BLOCK, GROUP_FLOW_ELEMENT),
   ELEM(noscript, true, true, GROUP_BLOCK, GROUP_FLOW_ELEMENT),
   ELEM(object, true, true, GROUP_SPECIAL | GROUP_BLOCK,
        GROUP_FLOW_ELEMENT | GROUP_OBJECT_CONTENT),
   // XXX Can contain self and ul because editor does sublists illegally.
   ELEM(ol, true, true, GROUP_BLOCK | GROUP_OL_UL,
        GROUP_LI | GROUP_OL_UL),
diff --git a/editor/libeditor/nsHTMLEditor.cpp b/editor/libeditor/nsHTMLEditor.cpp
--- a/editor/libeditor/nsHTMLEditor.cpp
+++ b/editor/libeditor/nsHTMLEditor.cpp
@@ -301,17 +301,18 @@ nsHTMLEditor::Init(nsIDOMDocument *aDoc,
     // init the type-in state
     mTypeInState = new TypeInState();
 
     // init the selection listener for image resizing
     mSelectionListenerP = new ResizerSelectionListener(this);
 
     if (!IsInteractionAllowed()) {
       // ignore any errors from this in case the file is missing
-      AddOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/EditorOverride.css"));
+      // BlueGriffon uses its own EditorOverride.css
+      //AddOverrideStyleSheet(NS_LITERAL_STRING("resource://gre/res/EditorOverride.css"));
     }
 
     RefPtr<Selection> selection = GetSelection();
     if (selection)
     {
       nsCOMPtr<nsISelectionListener>listener;
       listener = do_QueryInterface(mTypeInState);
       if (listener) {
@@ -2578,21 +2579,16 @@ nsHTMLEditor::CreateElementWithDefaults(
       return nullptr;
     }
     newElement->SetAttribute(NS_LITERAL_STRING("border"),
                              NS_LITERAL_STRING("1"), rv);
     if (NS_WARN_IF(rv.Failed())) {
       rv.SuppressException();
       return nullptr;
     }
-  } else if (tagName.EqualsLiteral("td")) {
-    nsresult res = SetAttributeOrEquivalent(
-        static_cast<nsIDOMElement*>(newElement->AsDOMNode()),
-        NS_LITERAL_STRING("valign"), NS_LITERAL_STRING("top"), true);
-    NS_ENSURE_SUCCESS(res, nullptr);
   }
   // ADD OTHER TAGS HERE
 
   return newElement.forget();
 }
 
 NS_IMETHODIMP
 nsHTMLEditor::CreateElementWithDefaults(const nsAString& aTagName, nsIDOMElement** aReturn)
@@ -3595,17 +3591,17 @@ void nsHTMLEditor::IsTextPropertySetByCo
   while (node)
   {
     nsCOMPtr<nsIDOMElement>element;
     element = do_QueryInterface(node);
     if (element)
     {
       nsAutoString tag, value;
       element->GetTagName(tag);
-      if (propName.Equals(tag, nsCaseInsensitiveStringComparator()))
+      if (propName.IsEmpty() || propName.Equals(tag, nsCaseInsensitiveStringComparator()))
       {
         bool found = false;
         if (aAttribute && 0!=aAttribute->Length())
         {
           element->GetAttribute(*aAttribute, value);
           if (outValue) *outValue = value;
           if (!value.IsEmpty())
           {
@@ -5288,8 +5284,39 @@ nsHTMLEditor::IsEditable(nsINode* aNode)
 }
 
 // virtual override
 dom::Element*
 nsHTMLEditor::GetEditorRoot()
 {
   return GetActiveEditingHost();
 }
+
+NS_IMETHODIMP
+nsHTMLEditor::GetMedium(nsAString & outValue)
+{
+  nsCOMPtr<nsIPresShell> ps = GetPresShell();
+
+  if (ps && ps->GetPresContext())
+  {
+    nsIAtom* medium = ps->GetPresContext()->Medium();
+    if (medium == nsGkAtoms::screen)
+      outValue.AssignLiteral("screen");
+    else
+      outValue.AssignLiteral("print");
+    return NS_OK;
+  }
+  return NS_ERROR_FAILURE;
+}
+
+NS_IMETHODIMP
+nsHTMLEditor::SetMedium(const nsAString& aMedium)
+{
+  nsCOMPtr<nsIPresShell> ps = GetPresShell();
+
+  if (ps && ps->GetPresContext())
+  {
+    ps->GetPresContext()->SetMedium(aMedium);
+    return NS_OK;
+  }
+  return NS_ERROR_FAILURE;
+}
+
diff --git a/editor/libeditor/nsHTMLEditor.h b/editor/libeditor/nsHTMLEditor.h
--- a/editor/libeditor/nsHTMLEditor.h
+++ b/editor/libeditor/nsHTMLEditor.h
@@ -652,17 +652,18 @@ protected:
                                        int32_t aStartOffset,
                                        int32_t aEndOffset,
                                        nsIAtom& aProperty,
                                        const nsAString* aAttribute,
                                        const nsAString& aValue);
   nsresult SetInlinePropertyOnNode(nsIContent& aNode,
                                    nsIAtom& aProperty,
                                    const nsAString* aAttribute,
-                                   const nsAString& aValue);
+                                   const nsAString& aValue,
+                                   bool aAvoidNestingForCSS);
 
   nsresult PromoteInlineRange(nsRange* aRange);
   nsresult PromoteRangeIfStartsOrEndsInNamedAnchor(nsRange* aRange);
   nsresult SplitStyleAboveRange(nsRange* aRange,
                                 nsIAtom *aProperty,
                                 const nsAString *aAttribute);
   nsresult SplitStyleAbovePoint(nsCOMPtr<nsIDOMNode> *aNode,
                                 int32_t *aOffset,
@@ -964,17 +965,18 @@ private:
   // Helpers
   bool IsSimpleModifiableNode(nsIContent* aContent,
                               nsIAtom* aProperty,
                               const nsAString* aAttribute,
                               const nsAString* aValue);
   nsresult SetInlinePropertyOnNodeImpl(nsIContent& aNode,
                                        nsIAtom& aProperty,
                                        const nsAString* aAttribute,
-                                       const nsAString& aValue);
+                                       const nsAString& aValue,
+                                       bool aAvoidNestingForCSS);
   typedef enum { eInserted, eAppended } InsertedOrAppended;
   void DoContentInserted(nsIDocument* aDocument, nsIContent* aContainer,
                          nsIContent* aChild, int32_t aIndexInContainer,
                          InsertedOrAppended aInsertedOrAppended);
   already_AddRefed<mozilla::dom::Element> GetElementOrParentByTagName(
       const nsAString& aTagName, nsINode* aNode);
   already_AddRefed<mozilla::dom::Element> CreateElementWithDefaults(
       const nsAString& aTagName);
diff --git a/editor/libeditor/nsHTMLEditorEventListener.cpp b/editor/libeditor/nsHTMLEditorEventListener.cpp
--- a/editor/libeditor/nsHTMLEditorEventListener.cpp
+++ b/editor/libeditor/nsHTMLEditorEventListener.cpp
@@ -66,33 +66,84 @@ nsHTMLEditorEventListener::MouseUp(nsIDO
   NS_ENSURE_TRUE(target, NS_ERROR_NULL_POINTER);
   nsCOMPtr<nsIDOMElement> element = do_QueryInterface(target);
 
   int32_t clientX, clientY;
   aMouseEvent->GetClientX(&clientX);
   aMouseEvent->GetClientY(&clientY);
   htmlEditor->MouseUp(clientX, clientY, element);
 
+  bool isShiftKey;
+  rv = aMouseEvent->GetShiftKey(&isShiftKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (htmlEditor->NotifyEditorMouseObservers(nsEditor::kMouseUp,
+                                             clientX, clientY,
+                                             element, isShiftKey)) {
+    nsCOMPtr<nsIDOMEvent> event = do_QueryInterface(aMouseEvent);
+    event->PreventDefault();
+    return NS_OK;
+  }
+
   return nsEditorEventListener::MouseUp(aMouseEvent);
 }
 
 nsresult
+nsHTMLEditorEventListener::MouseMove(nsIDOMMouseEvent* aMouseEvent)
+{
+  NS_ENSURE_TRUE(mEditor, NS_ERROR_NOT_AVAILABLE);
+
+  if (!aMouseEvent) {
+    //non-ui event passed in.  bad things.
+    return NS_OK;
+  }
+
+  nsHTMLEditor* htmlEditor = GetHTMLEditor();
+
+  nsCOMPtr<nsIDOMEventTarget> target;
+  nsCOMPtr<nsIDOMEvent> event = do_QueryInterface(aMouseEvent);
+  nsresult res = event->GetExplicitOriginalTarget(getter_AddRefs(target));
+  NS_ENSURE_SUCCESS(res, res);
+  NS_ENSURE_TRUE(target, NS_ERROR_NULL_POINTER);
+  nsCOMPtr<nsIDOMElement> element = do_QueryInterface(target);
+
+  int32_t clientX, clientY;
+  aMouseEvent->GetClientX(&clientX);
+  aMouseEvent->GetClientY(&clientY);
+
+  bool isShiftKey;
+  res = aMouseEvent->GetShiftKey(&isShiftKey);
+  NS_ENSURE_SUCCESS(res, res);
+  if (htmlEditor->NotifyEditorMouseObservers(nsEditor::kMouseMove,
+                                             clientX, clientY,
+                                             element, isShiftKey)) {
+    event->PreventDefault();
+    return NS_OK;
+  }
+
+  return nsEditorEventListener::MouseMove(aMouseEvent);
+}
+
+nsresult
 nsHTMLEditorEventListener::MouseDown(nsIDOMMouseEvent* aMouseEvent)
 {
   nsHTMLEditor* htmlEditor = GetHTMLEditor();
   // Contenteditable should disregard mousedowns outside it.
   // IsAcceptableInputEvent() checks it for a mouse event.
   if (!htmlEditor->IsAcceptableInputEvent(aMouseEvent->AsEvent())) {
     // If it's not acceptable mousedown event (including when mousedown event
     // is fired outside of the active editing host), we need to commit
     // composition because it will be change the selection to the clicked
     // point.  Then, we won't be able to commit the composition.
     return nsEditorEventListener::MouseDown(aMouseEvent);
   }
 
+  int32_t clientX, clientY;
+  aMouseEvent->GetClientX(&clientX);
+  aMouseEvent->GetClientY(&clientY);
+
   // Detect only "context menu" click
   // XXX This should be easier to do!
   // But eDOMEvents_contextmenu and eContextMenu is not exposed in any event
   // interface :-(
   int16_t buttonNumber;
   nsresult rv = aMouseEvent->GetButton(&buttonNumber);
   NS_ENSURE_SUCCESS(rv, rv);
 
@@ -190,22 +241,31 @@ nsHTMLEditorEventListener::MouseDown(nsI
     // Prevent bubbling if we changed selection or
     //   for all context clicks
     if (element || isContextClick) {
       aMouseEvent->AsEvent()->PreventDefault();
       return NS_OK;
     }
   } else if (!isContextClick && buttonNumber == 0 && clickCount == 1) {
     // if the target element is an image, we have to display resizers
-    int32_t clientX, clientY;
-    aMouseEvent->GetClientX(&clientX);
-    aMouseEvent->GetClientY(&clientY);
     htmlEditor->MouseDown(clientX, clientY, element, aMouseEvent->AsEvent());
   }
 
+  nsCOMPtr<nsIDOMNode> targetNode = do_QueryInterface(target);
+  bool isShiftKey;
+  rv = aMouseEvent->GetShiftKey(&isShiftKey);
+  NS_ENSURE_SUCCESS(rv, rv);
+  if (htmlEditor->NotifyEditorMouseObservers(nsEditor::kMouseDown,
+                                             clientX, clientY,
+                                             element, isShiftKey)) {
+    nsCOMPtr<nsIDOMEvent> event = do_QueryInterface(aMouseEvent);
+    event->PreventDefault();
+    return NS_OK;
+  }
+
   return nsEditorEventListener::MouseDown(aMouseEvent);
 }
 
 nsresult
 nsHTMLEditorEventListener::MouseClick(nsIDOMMouseEvent* aMouseEvent)
 {
   nsCOMPtr<nsIDOMEventTarget> target;
   nsresult rv = aMouseEvent->AsEvent()->GetTarget(getter_AddRefs(target));
diff --git a/editor/libeditor/nsHTMLEditorEventListener.h b/editor/libeditor/nsHTMLEditorEventListener.h
--- a/editor/libeditor/nsHTMLEditorEventListener.h
+++ b/editor/libeditor/nsHTMLEditorEventListener.h
@@ -28,14 +28,15 @@ public:
   // WARNING: You must be use nsHTMLEditor or its sub class for this class.
   virtual nsresult Connect(nsEditor* aEditor) override;
 #endif
 
 protected:
   virtual nsresult MouseDown(nsIDOMMouseEvent* aMouseEvent) override;
   virtual nsresult MouseUp(nsIDOMMouseEvent* aMouseEvent) override;
   virtual nsresult MouseClick(nsIDOMMouseEvent* aMouseEvent) override;
+  virtual nsresult MouseMove(nsIDOMMouseEvent* aMouseEvent) override;
 
   inline nsHTMLEditor* GetHTMLEditor();
 };
 
 #endif // nsHTMLEditorEventListener_h__
 
diff --git a/editor/libeditor/nsHTMLEditorStyle.cpp b/editor/libeditor/nsHTMLEditorStyle.cpp
--- a/editor/libeditor/nsHTMLEditorStyle.cpp
+++ b/editor/libeditor/nsHTMLEditorStyle.cpp
@@ -196,18 +196,20 @@ nsHTMLEditor::SetInlineProperty(nsIAtom*
         res = SetInlinePropertyOnTextNode(*startNode->GetAsText(),
                                           range->StartOffset(),
                                           startNode->Length(), *aProperty,
                                           &aAttribute, aValue);
         NS_ENSURE_SUCCESS(res, res);
       }
 
       // Then loop through the list, set the property on each node
+      int32_t listCount = arrayOfNodes.Length();
       for (auto& node : arrayOfNodes) {
-        res = SetInlinePropertyOnNode(*node, *aProperty, &aAttribute, aValue);
+        res = SetInlinePropertyOnNode(*node, *aProperty, &aAttribute, aValue,
+                                      (1 == listCount));
         NS_ENSURE_SUCCESS(res, res);
       }
 
       // Last check the end parent of the range to see if it needs to be
       // separately handled (it does if it's a text node, due to how the
       // subtree iterator works - it will not have reported it).
       if (endNode && endNode->GetAsText() && IsEditable(endNode)) {
         res = SetInlinePropertyOnTextNode(*endNode->GetAsText(), 0,
@@ -238,24 +240,27 @@ nsHTMLEditor::IsSimpleModifiableNode(nsI
   MOZ_ASSERT(aProperty);
   MOZ_ASSERT_IF(aAttribute, aValue);
 
   nsCOMPtr<dom::Element> element = do_QueryInterface(aContent);
   if (!element) {
     return false;
   }
 
+  uint32_t attrCount = aContent->GetAttrCount();
+  bool noAttr = !attrCount
+                || (attrCount == 1 && aContent->GetAttrNameAt(0)->Equals(nsGkAtoms::mozdirty));
   // First check for <b>, <i>, etc.
-  if (element->IsHTMLElement(aProperty) && !element->GetAttrCount() &&
+  if (element->IsHTMLElement(aProperty) && noAttr &&
       (!aAttribute || aAttribute->IsEmpty())) {
     return true;
   }
 
   // Special cases for various equivalencies: <strong>, <em>, <s>
-  if (!element->GetAttrCount() &&
+  if (noAttr &&
       ((aProperty == nsGkAtoms::b &&
         element->IsHTMLElement(nsGkAtoms::strong)) ||
        (aProperty == nsGkAtoms::i &&
         element->IsHTMLElement(nsGkAtoms::em)) ||
        (aProperty == nsGkAtoms::strike &&
         element->IsHTMLElement(nsGkAtoms::s)))) {
     return true;
   }
@@ -277,17 +282,18 @@ nsHTMLEditor::IsSimpleModifiableNode(nsI
     }
   }
 
   // No luck so far.  Now we check for a <span> with a single style=""
   // attribute that sets only the style we're looking for, if this type of
   // style supports it
   if (!mHTMLCSSUtils->IsCSSEditableProperty(element, aProperty, aAttribute) ||
       !element->IsHTMLElement(nsGkAtoms::span) ||
-      element->GetAttrCount() != 1 ||
+      !(attrCount == 1 || (attrCount == 2 && (element->GetAttrNameAt(0)->Equals(nsGkAtoms::mozdirty) ||
+                                              element->GetAttrNameAt(1)->Equals(nsGkAtoms::mozdirty)))) ||
       !element->HasAttr(kNameSpaceID_None, nsGkAtoms::style)) {
     return false;
   }
 
   // Some CSS styles are not so simple.  For instance, underline is
   // "text-decoration: underline", which decomposes into four different text-*
   // properties.  So for now, we just create a span, add the desired style, and
   // see if it matches.
@@ -358,25 +364,26 @@ nsHTMLEditor::SetInlinePropertyOnTextNod
     sibling = GetNextHTMLSibling(text);
     if (IsSimpleModifiableNode(sibling, &aProperty, aAttribute, &aValue)) {
       // Following sib is already right kind of inline node; slide this over
       return MoveNode(text, sibling, 0);
     }
   }
 
   // Reparent the node inside inline node with appropriate {attribute,value}
-  return SetInlinePropertyOnNode(*text, aProperty, aAttribute, aValue);
+  return SetInlinePropertyOnNode(*text, aProperty, aAttribute, aValue, false);
 }
 
 
 nsresult
 nsHTMLEditor::SetInlinePropertyOnNodeImpl(nsIContent& aNode,
                                           nsIAtom& aProperty,
                                           const nsAString* aAttribute,
-                                          const nsAString& aValue)
+                                          const nsAString& aValue,
+                                          bool aAvoidNestingForCSS)
 {
   nsCOMPtr<nsIAtom> attrAtom = aAttribute ? do_GetAtom(*aAttribute) : nullptr;
 
   // If this is an element that can't be contained in a span, we have to
   // recurse to its children.
   if (!TagCanContain(*nsGkAtoms::span, aNode)) {
     if (aNode.HasChildren()) {
       nsTArray<OwningNonNull<nsIContent>> arrayOfNodes;
@@ -388,17 +395,17 @@ nsHTMLEditor::SetInlinePropertyOnNodeImp
         if (IsEditable(child) && !IsEmptyTextNode(this, child)) {
           arrayOfNodes.AppendElement(*child);
         }
       }
 
       // Then loop through the list, set the property on each node.
       for (auto& node : arrayOfNodes) {
         nsresult rv = SetInlinePropertyOnNode(node, aProperty, aAttribute,
-                                              aValue);
+                                              aValue, false);
         NS_ENSURE_SUCCESS(rv, rv);
       }
     }
     return NS_OK;
   }
 
   // First check if there's an adjacent sibling we can put our node into.
   nsresult res;
@@ -434,18 +441,19 @@ nsHTMLEditor::SetInlinePropertyOnNodeImp
                  mHTMLCSSUtils->IsCSSEditableProperty(&aNode, &aProperty, aAttribute)) ||
                 // bgcolor is always done using CSS
                 aAttribute->EqualsLiteral("bgcolor");
 
   if (useCSS) {
     nsCOMPtr<dom::Element> tmp;
     // We only add style="" to <span>s with no attributes (bug 746515).  If we
     // don't have one, we need to make one.
-    if (aNode.IsHTMLElement(nsGkAtoms::span) &&
-        !aNode.AsElement()->GetAttrCount()) {
+    if (aNode.IsElement() &&
+        (aAvoidNestingForCSS ||
+         (aNode.AsElement()->IsHTMLElement(nsGkAtoms::span) && !aNode.AsElement()->GetAttrCount()))) {
       tmp = aNode.AsElement();
     } else {
       tmp = InsertContainerAbove(&aNode, nsGkAtoms::span);
       NS_ENSURE_STATE(tmp);
     }
 
     // Add the CSS styles corresponding to the HTML style request
     int32_t count;
@@ -471,30 +479,31 @@ nsHTMLEditor::SetInlinePropertyOnNodeImp
   return NS_OK;
 }
 
 
 nsresult
 nsHTMLEditor::SetInlinePropertyOnNode(nsIContent& aNode,
                                       nsIAtom& aProperty,
                                       const nsAString* aAttribute,
-                                      const nsAString& aValue)
+                                      const nsAString& aValue,
+                                      bool aAvoidNestingForCSS)
 {
   nsCOMPtr<nsIContent> previousSibling = aNode.GetPreviousSibling(),
                        nextSibling = aNode.GetNextSibling();
   NS_ENSURE_STATE(aNode.GetParentNode());
   OwningNonNull<nsINode> parent = *aNode.GetParentNode();
 
   nsresult res = RemoveStyleInside(aNode, &aProperty, aAttribute);
   NS_ENSURE_SUCCESS(res, res);
 
   if (aNode.GetParentNode()) {
     // The node is still where it was
     return SetInlinePropertyOnNodeImpl(aNode, aProperty,
-                                       aAttribute, aValue);
+                                       aAttribute, aValue, aAvoidNestingForCSS);
   }
 
   // It's vanished.  Use the old siblings for reference to construct a
   // list.  But first, verify that the previous/next siblings are still
   // where we expect them; otherwise we have to give up.
   if ((previousSibling && previousSibling->GetParentNode() != parent) ||
       (nextSibling && nextSibling->GetParentNode() != parent)) {
     return NS_ERROR_UNEXPECTED;
@@ -504,17 +513,17 @@ nsHTMLEditor::SetInlinePropertyOnNode(ns
     ? previousSibling->GetNextSibling() : parent->GetFirstChild();
   for (; cur && cur != nextSibling; cur = cur->GetNextSibling()) {
     if (IsEditable(cur)) {
       nodesToSet.AppendElement(*cur);
     }
   }
 
   for (auto& node : nodesToSet) {
-    res = SetInlinePropertyOnNodeImpl(node, aProperty, aAttribute, aValue);
+    res = SetInlinePropertyOnNodeImpl(node, aProperty, aAttribute, aValue, false);
     NS_ENSURE_SUCCESS(res, res);
   }
 
   return NS_OK;
 }
 
 
 nsresult
@@ -1393,17 +1402,17 @@ nsHTMLEditor::RemoveInlinePropertyImpl(n
               // startNode's computed style indicates the CSS equivalence to
               // the HTML style to remove is applied; but we found no element
               // in the ancestors of startNode carrying specified styles;
               // assume it comes from a rule and let's try to insert a span
               // "inverting" the style
               mHTMLCSSUtils->IsCSSInvertible(*aProperty, aAttribute)) {
             NS_NAMED_LITERAL_STRING(value, "-moz-editor-invert-value");
             SetInlinePropertyOnNode(*node->AsContent(), *aProperty,
-                                    aAttribute, value);
+                                    aAttribute, value, false);
           }
         }
       }
     }
   }
   if (!cancel) {
     // Post-process
     res = mRules->DidDoAction(selection, &ruleInfo, res);
diff --git a/editor/libeditor/nsPlaintextDataTransfer.cpp b/editor/libeditor/nsPlaintextDataTransfer.cpp
--- a/editor/libeditor/nsPlaintextDataTransfer.cpp
+++ b/editor/libeditor/nsPlaintextDataTransfer.cpp
@@ -434,19 +434,17 @@ bool nsPlaintextEditor::IsSafeToInsertDa
 
   nsCOMPtr<nsIDocument> destdoc = GetDocument();
   NS_ASSERTION(destdoc, "Where is our destination doc?");
   nsCOMPtr<nsIDocShellTreeItem> dsti = destdoc->GetDocShell();
   nsCOMPtr<nsIDocShellTreeItem> root;
   if (dsti)
     dsti->GetRootTreeItem(getter_AddRefs(root));
   nsCOMPtr<nsIDocShell> docShell = do_QueryInterface(root);
-  uint32_t appType;
-  if (docShell && NS_SUCCEEDED(docShell->GetAppType(&appType)))
-    isSafe = appType == nsIDocShell::APP_TYPE_EDITOR;
+
   if (!isSafe && aSourceDoc) {
     nsCOMPtr<nsIDocument> srcdoc = do_QueryInterface(aSourceDoc);
     NS_ASSERTION(srcdoc, "Where is our source doc?");
 
     nsIPrincipal* srcPrincipal = srcdoc->NodePrincipal();
     nsIPrincipal* destPrincipal = destdoc->NodePrincipal();
     NS_ASSERTION(srcPrincipal && destPrincipal, "How come we don't have a principal?");
     srcPrincipal->Subsumes(destPrincipal, &isSafe);
diff --git a/editor/libeditor/nsTableEditor.cpp b/editor/libeditor/nsTableEditor.cpp
--- a/editor/libeditor/nsTableEditor.cpp
+++ b/editor/libeditor/nsTableEditor.cpp
@@ -2297,38 +2297,86 @@ nsHTMLEditor::MergeCells(nsCOMPtr<nsIDOM
   nsCOMPtr<dom::Element> targetCell = do_QueryInterface(aTargetCell);
   nsCOMPtr<dom::Element> cellToMerge = do_QueryInterface(aCellToMerge);
   NS_ENSURE_TRUE(targetCell && cellToMerge, NS_ERROR_NULL_POINTER);
 
   // Prevent rules testing until we're done
   nsAutoRules beginRulesSniffing(this, EditAction::deleteNode, nsIEditor::eNext);
 
   // Don't need to merge if cell is empty
+  nsresult res;
   if (!IsEmptyCell(cellToMerge)) {
     // Get index of last child in target cell
     // If we fail or don't have children,
     //  we insert at index 0
     int32_t insertIndex = 0;
 
     // Start inserting just after last child
     uint32_t len = targetCell->GetChildCount();
-    if (len == 1 && IsEmptyCell(targetCell)) {
+    bool isTargetCellEmpty = IsEmptyCell(targetCell);
+    if (len == 1 && isTargetCellEmpty) {
       // Delete the empty node
       nsIContent* cellChild = targetCell->GetFirstChild();
       nsresult res = DeleteNode(cellChild->AsDOMNode());
       NS_ENSURE_SUCCESS(res, res);
       insertIndex = 0;
     } else {
       insertIndex = (int32_t)len;
+      // Insert a break at the beginning of source cell if we need it.
+      // We need it if both cells are non-empty from a content point of view.
+      if (!isTargetCellEmpty) {
+        // Let's look for the last child of the target cell that is not
+        // an empty text node
+        nsIContent* targetCellChild = targetCell->GetLastChild();
+        nsCOMPtr<nsIDOMNode> targetCellChildNode = targetCellChild->AsDOMNode();
+        bool isEmptyTextNode = false;
+        while (targetCellChildNode
+               && nsEditor::IsTextNode(targetCellChildNode)
+               && (NS_SUCCEEDED(IsEmptyNode(targetCellChildNode, &isEmptyTextNode)) && isEmptyTextNode)) {
+          res = targetCellChildNode->GetPreviousSibling(getter_AddRefs(targetCellChildNode));
+          NS_ENSURE_SUCCESS(res, res);
+        }
+        // we know targetCellChildNode cannot be null at this point because
+        // we tested isTargetCellEmpty above...
+        bool isBlock = false;
+        NodeIsBlock(targetCellChildNode, &isBlock);
+        // Lets check if targetCellChildNode is a block or a break
+        if (!isBlock && !nsTextEditUtils::IsBreak(targetCellChildNode)) {
+          // It's not, we may have to insert a break...
+          // Let's look for the first child of the source cell that is not
+          // an empty text node
+          nsCOMPtr<nsIDOMNode> cellChildNode = cellToMerge->GetFirstChild()->AsDOMNode();
+          while (cellChildNode
+                 && nsEditor::IsTextNode(cellChildNode)
+                 && (NS_SUCCEEDED(IsEmptyNode(cellChildNode, &isEmptyTextNode)) && isEmptyTextNode)) {
+            res = cellChildNode->GetPreviousSibling(getter_AddRefs(cellChildNode));
+            NS_ENSURE_SUCCESS(res, res);
+          }
+          // we also know cellChildNode cannot be null at this point because
+          // we tested IsEmptyCell(cellToMerge) above...
+          isBlock = false;
+          NodeIsBlock(cellChildNode, &isBlock);
+          // Lets check if targetCellChildNode is a block or a break
+          if (!isBlock && !nsTextEditUtils::IsBreak(cellChildNode)) {
+            // so both last visible node of target cell and first visible node of
+            // source cell are not blocks or breaks. We need to insert
+            // a break as first child of source cell so the merged contents
+            // are separated by that break.
+            nsCOMPtr<nsIDOMNode> brNode;
+            res = CreateBR(aCellToMerge, 0, address_of(brNode));
+            NS_ENSURE_SUCCESS(res, res);
+          }
+        }
+      }
     }
 
     // Move the contents
     while (cellToMerge->HasChildren()) {
       nsCOMPtr<nsIDOMNode> cellChild = cellToMerge->GetLastChild()->AsDOMNode();
-      nsresult res = DeleteNode(cellChild);
+      res = DeleteNode(cellChild);
       NS_ENSURE_SUCCESS(res, res);
 
       res = InsertNode(cellChild, aTargetCell, insertIndex);
       NS_ENSURE_SUCCESS(res, res);
     }
   }
 
   // Delete cells whose contents were moved
@@ -2687,17 +2735,17 @@ nsHTMLEditor::GetCellDataAt(nsIDOMElemen
   }
 
   nsTableOuterFrame* tableFrame = GetTableFrame(aTable);
   NS_ENSURE_TRUE(tableFrame, NS_ERROR_FAILURE);
 
   nsTableCellFrame* cellFrame =
     tableFrame->GetCellFrameAt(aRowIndex, aColIndex);
   if (!cellFrame)
-    return NS_ERROR_FAILURE;
+    return NS_EDITOR_ELEMENT_NOT_FOUND;
 
   *aIsSelected = cellFrame->IsSelected();
   cellFrame->GetRowIndex(*aStartRowIndex);
   cellFrame->GetColIndex(*aStartColIndex);
   *aRowSpan = cellFrame->GetRowSpan();
   *aColSpan = cellFrame->GetColSpan();
   *aActualRowSpan = tableFrame->GetEffectiveRowSpanAt(aRowIndex, aColIndex);
   *aActualColSpan = tableFrame->GetEffectiveColSpanAt(aRowIndex, aColIndex);
diff --git a/editor/libeditor/nsWSRunObject.cpp b/editor/libeditor/nsWSRunObject.cpp
--- a/editor/libeditor/nsWSRunObject.cpp
+++ b/editor/libeditor/nsWSRunObject.cpp
@@ -498,17 +498,17 @@ nsWSRunObject::PriorVisibleNode(nsINode*
   // anything return start of ws.
   MOZ_ASSERT(aNode && outVisNode && outVisOffset && outType);
 
   WSFragment* run;
   FindRun(aNode, aOffset, &run, false);
 
   // Is there a visible run there or earlier?
   for (; run; run = run->mLeft) {
-    if (run->mType == WSType::normalWS) {
+    if (run->mType == WSType::normalWS || run->mType == WSType::trailingWS) {
       WSPoint point = GetCharBefore(aNode, aOffset);
       if (point.mTextNode) {
         *outVisNode = point.mTextNode;
         *outVisOffset = point.mOffset + 1;
         if (nsCRT::IsAsciiSpace(point.mChar) || point.mChar == nbsp) {
           *outType = WSType::normalWS;
         } else if (!point.mChar) {
           // MOOSE: not possible?
diff --git a/editor/moz.build b/editor/moz.build
--- a/editor/moz.build
+++ b/editor/moz.build
@@ -13,16 +13,17 @@ DIRS += [
 
 XPIDL_SOURCES += [
     'nsIContentFilter.idl',
     'nsIDocumentStateListener.idl',
     'nsIEditActionListener.idl',
     'nsIEditor.idl',
     'nsIEditorIMESupport.idl',
     'nsIEditorMailSupport.idl',
+    'nsIEditorMouseObserver.idl',
     'nsIEditorObserver.idl',
     'nsIEditorSpellCheck.idl',
     'nsIEditorStyleSheets.idl',
     'nsIHTMLAbsPosEditor.idl',
     'nsIHTMLEditor.idl',
     'nsIHTMLInlineTableEditor.idl',
     'nsIHTMLObjectResizeListener.idl',
     'nsIHTMLObjectResizer.idl',
diff --git a/editor/nsIEditor.idl b/editor/nsIEditor.idl
--- a/editor/nsIEditor.idl
+++ b/editor/nsIEditor.idl
@@ -12,21 +12,22 @@ interface nsIAtom;
 interface nsIContent;
 interface nsISelection;
 interface nsISelectionController;
 interface nsIDocumentStateListener;
 interface nsIOutputStream;
 interface nsITransactionManager;
 interface nsITransaction;
 interface nsIEditorObserver;
+interface nsIEditorMouseObserver;
 interface nsIEditActionListener;
 interface nsIInlineSpellChecker;
 interface nsITransferable;
 
-[scriptable, uuid(094be624-f0bf-400f-89e2-6a84baab9474)]
+[scriptable, uuid(EE1D66E6-1F4E-4A70-AEA9-23E1EFC17E92)]
 interface nsIEditor  : nsISupports
 {
 %{C++
   typedef short EDirection;
   typedef short EStripWrappers;
 %}
   const short eNone = 0;
   const short eNext = 1;
@@ -521,16 +522,19 @@ interface nsIEditor  : nsISupports
    */
 
   /** add an EditorObserver to the editors list of observers. */
   void addEditorObserver(in nsIEditorObserver observer);
 
   /** Remove an EditorObserver from the editor's list of observers. */
   void removeEditorObserver(in nsIEditorObserver observer);
 
+  void addEditorMouseObserver(in nsIEditorMouseObserver observer);
+  void removeEditorMouseObserver(in nsIEditorMouseObserver observer);
+
   /** add an EditActionListener to the editors list of listeners. */
   void addEditActionListener(in nsIEditActionListener listener);
 
   /** Remove an EditActionListener from the editor's list of listeners. */
   void removeEditActionListener(in nsIEditActionListener listener);
 
   /** Add a DocumentStateListener to the editors list of doc state listeners. */
   void addDocumentStateListener(in nsIDocumentStateListener listener);
diff --git a/editor/nsIEditorMouseObserver.idl b/editor/nsIEditorMouseObserver.idl
new file mode 100644
--- /dev/null
+++ b/editor/nsIEditorMouseObserver.idl
@@ -0,0 +1,17 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+#include "domstubs.idl"
+
+
+[scriptable, uuid(7A76F573-7512-4051-BB20-E6E279F26F55)]
+
+interface nsIEditorMouseObserver : nsISupports {
+
+  bool MouseDown(in int32_t aClientX, in int32_t aClientY, in nsIDOMNode aTarget, in boolean aShiftKey);
+  bool MouseUp(in int32_t aClientX, in int32_t aClientY, in nsIDOMNode aTarget, in boolean aShiftKey);
+  bool MouseMove(in int32_t aClientX, in int32_t aClientY, in nsIDOMNode aTarget, in boolean aShiftKey);
+};
diff --git a/editor/nsIHTMLEditor.idl b/editor/nsIHTMLEditor.idl
--- a/editor/nsIHTMLEditor.idl
+++ b/editor/nsIHTMLEditor.idl
@@ -17,17 +17,17 @@ namespace mozilla {
 namespace dom {
 class Element;
 }
 }
 %}
 
 [ptr] native Element (mozilla::dom::Element);
 
-[scriptable, uuid(87ee993e-985f-4a43-a974-0d9512da2fb0)]
+[scriptable, uuid(BFA533D9-358C-47CC-92FF-E89D5263D264)]
 interface nsIHTMLEditor : nsISupports
 {
 %{C++
   typedef short EAlignment;
 %}
 
   // used by GetAlignment()
   const short eLeft = 0;
@@ -492,16 +492,19 @@ interface nsIHTMLEditor : nsISupports
   /**
    * A boolean which is true is the HTMLEditor has been instantiated
    * with CSS knowledge and if the CSS pref is currently checked
    *
    * @return    true if CSS handled and enabled
    */
   attribute boolean isCSSEnabled;
 
+  AString getMedium();
+  void setMedium(in AString aMedium);
+
   /**
    * Add listener for insertion override
    * @param inFilter  function which callers want called during insertion
    */
   void addInsertionListener(in nsIContentFilter inFilter);
 
   /**
    * Remove listener for insertion override
diff --git a/extensions/moz.build b/extensions/moz.build
--- a/extensions/moz.build
+++ b/extensions/moz.build
@@ -1,7 +1,7 @@
-# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
-# vim: set filetype=python:
-# This Source Code Form is subject to the terms of the Mozilla Public
-# License, v. 2.0. If a copy of the MPL was not distributed with this
-# file, You can obtain one at http://mozilla.org/MPL/2.0/.
-
-DIRS += CONFIG['MOZ_EXTENSIONS']
+DIRS += [
+    'svg-edit',
+    'gfd',
+    'fs',
+    'markdown',
+    'op1'
+]
diff --git a/gfx/src/nsColor.cpp b/gfx/src/nsColor.cpp
--- a/gfx/src/nsColor.cpp
+++ b/gfx/src/nsColor.cpp
@@ -195,16 +195,37 @@ bool NS_ColorNameToRGB(const nsAString& 
     if (aResult) {
       *aResult = kColors[id];
     }
     return true;
   }
   return false;
 }
 
+bool NS_RGBToColorName(nscolor aColor, nsAString& aResult)
+{
+  uint8_t a = NS_GET_A(aColor);
+  if (a < 255)
+    return false;
+  uint8_t r = NS_GET_R(aColor);
+  uint8_t g = NS_GET_G(aColor);
+  uint8_t b = NS_GET_B(aColor);
+  uint32_t colorIndex;
+  for (colorIndex = 0; colorIndex < eColorName_COUNT; colorIndex++) {
+    nscolor matchingColor = kColors[colorIndex];
+    if (NS_GET_R(matchingColor) == r
+        && NS_GET_G(matchingColor) == g
+        && NS_GET_B(matchingColor) == b) {
+      aResult.AppendASCII(kColorNames[colorIndex]);
+      return true;
+    }
+  }
+  return false;
+}
+
 // Returns kColorNames, an array of all possible color names, and sets
 // *aSizeArray to the size of that array. Do NOT call free() on this array.
 const char * const * NS_AllColorNames(size_t *aSizeArray)
 {
   *aSizeArray = ArrayLength(kColorNames);
   return kColorNames;
 }
 
diff --git a/gfx/src/nsColor.h b/gfx/src/nsColor.h
--- a/gfx/src/nsColor.h
+++ b/gfx/src/nsColor.h
@@ -61,16 +61,20 @@ bool NS_LooseHexToRGB(const nsString& aB
 
 // There is no function to translate a color to a hex string, because
 // the hex-string syntax does not support transparency.
 
 // Translate a color name to a color. Return true if it parses ok,
 // otherwise return false.
 bool NS_ColorNameToRGB(const nsAString& aBuf, nscolor* aResult);
 
+// Translate a color to a color name. Return true if it parses ok,
+// otherwise return false.
+bool NS_RGBToColorName(nscolor aColor, nsAString& aResult);
+
 // Returns an array of all possible color names, and sets
 // *aSizeArray to the size of that array. Do NOT call |free()| on this array.
 const char * const * NS_AllColorNames(size_t *aSizeArray);
 
 // function to convert from HSL color space to RGB color space
 // the float parameters are all expected to be in the range 0-1
 nscolor NS_HSL2RGB(float h, float s, float l);
 
diff --git a/image/imgICache.idl b/image/imgICache.idl
--- a/image/imgICache.idl
+++ b/image/imgICache.idl
@@ -14,27 +14,29 @@ interface nsIURI;
 
 /**
  * imgICache interface
  *
  * @author Stuart Parmenter <pavlov@netscape.com>
  * @version 0.1
  * @see imagelib2
  */
-[scriptable, builtinclass, uuid(bfdf23ff-378e-402e-8a6c-840f0c82b6c3)]
+[scriptable, builtinclass, uuid(862388D5-EB14-4E0D-931C-F4FAD05FB5F2)]
 interface imgICache : nsISupports
 {
   /**
    * Evict images from the cache.
    *
    * @param chrome If TRUE,  evict only chrome images.
    *               If FALSE, evict everything except chrome images.
    */
   void clearCache(in boolean chrome);
 
+  void removeEntry(in nsIURI uri, in nsIDOMDocument doc);
+
   /**
    * Find Properties
    * Used to get properties such as 'type' and 'content-disposition'
    * 'type' is a nsISupportsCString containing the images' mime type such as
    * 'image/png'
    * 'content-disposition' will be a nsISupportsCString containing the header
    * If you call this before any data has been loaded from a URI, it will
    * succeed, but come back empty.
diff --git a/image/imgLoader.cpp b/image/imgLoader.cpp
--- a/image/imgLoader.cpp
+++ b/image/imgLoader.cpp
@@ -1321,17 +1321,27 @@ imgLoader::ClearCache(bool chrome)
 {
   if (chrome) {
     return ClearChromeImageCache();
   } else {
     return ClearImageCache();
   }
 }
 
-NS_IMETHODIMP
+ NS_IMETHODIMP
+imgLoader::RemoveEntry(nsIURI* aURI, nsIDOMDocument* doc)
+{
+  if (aURI && RemoveFromCache(ImageCacheKey(aURI, doc))) {
+    return NS_OK;
+  }
+
+  return NS_ERROR_NOT_AVAILABLE;
+}
+
+ NS_IMETHODIMP
 imgLoader::FindEntryProperties(nsIURI* uri,
                                nsIDOMDocument* doc,
                                nsIProperties** _retval)
 {
   *_retval = nullptr;
 
   ImageCacheKey key(uri, doc);
   imgCacheTable& cache = GetCache(key);
diff --git a/layout/base/nsPresContext.cpp b/layout/base/nsPresContext.cpp
--- a/layout/base/nsPresContext.cpp
+++ b/layout/base/nsPresContext.cpp
@@ -2229,16 +2229,30 @@ nsPresContext::SetPaginatedScrolling(boo
 
 void
 nsPresContext::SetPrintSettings(nsIPrintSettings *aPrintSettings)
 {
   if (mMedium == nsGkAtoms::print)
     mPrintSettings = aPrintSettings;
 }
 
+void
+nsPresContext::SetMedium(const nsAString& aMedium)
+{
+  if (aMedium.EqualsLiteral("screen")) {
+    mMedium = nsGkAtoms::screen;
+    mType =  eContext_Galley;
+  } else {
+    mMedium = nsGkAtoms::print;
+    mType =  eContext_PageLayout;
+    mPaginated = true;
+  }
+  MediaFeatureValuesChanged(eRestyle_ForceDescendants, NS_STYLE_HINT_REFLOW);
+}
+
 bool
 nsPresContext::EnsureVisible()
 {
   nsCOMPtr<nsIDocShell> docShell(mContainer);
   if (docShell) {
     nsCOMPtr<nsIContentViewer> cv;
     docShell->GetContentViewer(getter_AddRefs(cv));
     // Make sure this is the content viewer we belong with
diff --git a/layout/base/nsPresContext.h b/layout/base/nsPresContext.h
--- a/layout/base/nsPresContext.h
+++ b/layout/base/nsPresContext.h
@@ -330,16 +330,17 @@ public:
   /**
    * Get medium of presentation
    */
   nsIAtom* Medium() {
     if (!mIsEmulatingMedia)
       return mMedium;
     return mMediaEmulated;
   }
+  void SetMedium(const nsAString& aMedium);
 
   /*
    * Render the document as if being viewed on a device with the specified
    * media type.
    */
   void EmulateMedium(const nsAString& aMediaType);
 
   /*
diff --git a/layout/forms/nsColorControlFrame.cpp b/layout/forms/nsColorControlFrame.cpp
--- a/layout/forms/nsColorControlFrame.cpp
+++ b/layout/forms/nsColorControlFrame.cpp
@@ -97,16 +97,18 @@ nsColorControlFrame::AppendAnonymousCont
 nsresult
 nsColorControlFrame::UpdateColor()
 {
   // Get the color from the "value" property of our content; it will return the
   // default color (through the sanitization algorithm) if there is none.
   nsAutoString color;
   nsCOMPtr<nsIDOMHTMLInputElement> elt = do_QueryInterface(mContent);
   elt->GetValue(color);
+  if (color.IsEmpty())
+    return NS_OK;
   MOZ_ASSERT(!color.IsEmpty(),
              "Content node's GetValue() should return a valid color string "
              "(the default color, in case no valid color is set)");
 
   // Set the background-color style property of the swatch element to this color
   return mColorContent->SetAttr(kNameSpaceID_None, nsGkAtoms::style,
       NS_LITERAL_STRING("background-color:") + color, true);
 }
diff --git a/layout/style/Loader.cpp b/layout/style/Loader.cpp
--- a/layout/style/Loader.cpp
+++ b/layout/style/Loader.cpp
@@ -1117,17 +1117,18 @@ Loader::CreateSheet(nsIURI* aURI,
           sheet = cache->GetStyleSheet(aURI);
           LOG(("  From XUL cache: %p", sheet->AsVoidPtr()));
         }
       }
     }
 #endif
 
     bool fromCompleteSheets = false;
-    if (!sheet) {
+    //XXX BlueGriffon forces reload of stylesheets each time we need them
+    if (false /*!sheet*/) {
       // Then our per-document complete sheets.
       URIPrincipalReferrerPolicyAndCORSModeHashKey key(aURI, aLoaderPrincipal, aCORSMode, aReferrerPolicy);
 
       StyleSheetHandle completeSheet;
       mSheets->mCompleteSheets.Get(&key, &completeSheet);
       sheet = completeSheet;
       LOG(("  From completed: %p", sheet->AsVoidPtr()));
 
diff --git a/layout/style/nsCSSParser.cpp b/layout/style/nsCSSParser.cpp
--- a/layout/style/nsCSSParser.cpp
+++ b/layout/style/nsCSSParser.cpp
@@ -50,16 +50,18 @@
 #include "nsLayoutUtils.h"
 #include "mozilla/Preferences.h"
 #include "nsRuleData.h"
 #include "mozilla/CSSVariableValues.h"
 #include "mozilla/dom/AnimationEffectReadOnlyBinding.h"
 #include "mozilla/dom/URL.h"
 #include "gfxFontFamilyList.h"
 
+#define BG_CONSOLE_SHOW_INVALID_VARIABLES "bluegriffon.console.showInvalidVariables"
+
 using namespace mozilla;
 using namespace mozilla::css;
 
 typedef nsCSSProps::KTableEntry KTableEntry;
 
 // pref-backed bool values (hooked up in nsCSSParser::Startup)
 static bool sOpentypeSVGEnabled;
 static bool sWebkitPrefixedAliasesEnabled;
@@ -2902,17 +2904,17 @@ CSSParserImpl::ParsePropertyWithVariable
   {
     nsCSSScanner scanner(aValue, 0);
     css::ErrorReporter reporter(scanner, aSheet, mChildLoader, aDocURL);
     InitScanner(scanner, reporter, aDocURL, aBaseURL, aDocPrincipal);
 
     nsCSSTokenSerializationType firstToken, lastToken;
     valid = ResolveValueWithVariableReferences(aVariables, expandedValue,
                                                firstToken, lastToken);
-    if (!valid) {
+    if (!valid && Preferences::GetBool(BG_CONSOLE_SHOW_INVALID_VARIABLES)) {
       NS_ConvertASCIItoUTF16 propName(nsCSSProps::GetStringValue(aPropertyID));
       REPORT_UNEXPECTED(PEInvalidVariableReference);
       REPORT_UNEXPECTED_P(PEValueParsingError, propName);
       if (nsCSSProps::IsInherited(aPropertyID)) {
         REPORT_UNEXPECTED(PEValueWithVariablesFallbackInherit);
       } else {
         REPORT_UNEXPECTED(PEValueWithVariablesFallbackInitial);
       }
diff --git a/layout/style/nsCSSValue.cpp b/layout/style/nsCSSValue.cpp
--- a/layout/style/nsCSSValue.cpp
+++ b/layout/style/nsCSSValue.cpp
@@ -1379,16 +1379,27 @@ nsCSSValue::AppendToString(nsCSSProperty
     nsAutoCString str;
     if (nsCSSProps::GetColorName(GetIntValue(), str)){
       AppendASCIItoUTF16(str, aResult);
     } else {
       MOZ_ASSERT(false, "bad color value");
     }
   }
   else if (IsNumericColorUnit(unit)) {
+    bool outputCssNames = false;
+    nsXPIDLCString colorOutputType;
+    nsresult rv;
+    nsCOMPtr<nsIPrefBranch> prefBranch = do_GetService(NS_PREFSERVICE_CONTRACTID, &rv);
+    if (NS_SUCCEEDED(rv) && prefBranch) {
+      prefBranch->GetBoolPref("bluegriffon.css.colors.names.enabled", &outputCssNames);
+      prefBranch->GetCharPref("bluegriffon.css.colors.type", getter_Copies(colorOutputType));
+    }
+    bool serializeName = false;
+    bool forceHexSerialization = false;
+
     if (aSerialization == eNormalized ||
         unit == eCSSUnit_RGBColor ||
         unit == eCSSUnit_RGBAColor) {
       nscolor color = GetColorValue();
       if (aSerialization == eNormalized &&
           color == NS_RGBA(0, 0, 0, 0)) {
         // Use the strictest match for 'transparent' so we do correct
         // round-tripping of all other rgba() values.
@@ -1397,31 +1408,62 @@ nsCSSValue::AppendToString(nsCSSProperty
         uint8_t a = NS_GET_A(color);
         bool showAlpha =
           (aSerialization == eNormalized && a < 255) ||
           (aSerialization == eAuthorSpecified &&
            unit == eCSSUnit_RGBAColor);
         if (showAlpha) {
           aResult.AppendLiteral("rgba(");
         } else {
-          aResult.AppendLiteral("rgb(");
+          if (outputCssNames) {
+            nsAutoString nameToSerialize;
+            serializeName = NS_RGBToColorName(color, nameToSerialize);
+            if (serializeName) {
+              aResult.Append(nameToSerialize);
+            }
+            else {
+              if (!PL_strcmp(colorOutputType, "hex")) {
+                forceHexSerialization = true;
+              }
+              else
+                aResult.AppendLiteral("rgb(");
+            }
+          }
+          else {
+            if (!PL_strcmp(colorOutputType, "hex")) {
+              forceHexSerialization = true;
+            }
+            else
+              aResult.AppendLiteral("rgb(");
+          }
         }
 
-        NS_NAMED_LITERAL_STRING(comma, ", ");
+        if (!serializeName) {
+          if (forceHexSerialization) {
+            nscolor color = GetColorValue();
+            aResult.Append('#');
+            aResult.AppendPrintf("%02x", NS_GET_R(color));
+            aResult.AppendPrintf("%02x", NS_GET_G(color));
+            aResult.AppendPrintf("%02x", NS_GET_B(color));
+          }
+          else {
+            NS_NAMED_LITERAL_STRING(comma, ", ");
 
-        aResult.AppendInt(NS_GET_R(color), 10);
-        aResult.Append(comma);
-        aResult.AppendInt(NS_GET_G(color), 10);
-        aResult.Append(comma);
-        aResult.AppendInt(NS_GET_B(color), 10);
-        if (showAlpha) {
-          aResult.Append(comma);
-          aResult.AppendFloat(nsStyleUtil::ColorComponentToFloat(a));
+            aResult.AppendInt(NS_GET_R(color), 10);
+            aResult.Append(comma);
+            aResult.AppendInt(NS_GET_G(color), 10);
+            aResult.Append(comma);
+            aResult.AppendInt(NS_GET_B(color), 10);
+            if (showAlpha) {
+              aResult.Append(comma);
+              aResult.AppendFloat(nsStyleUtil::ColorComponentToFloat(a));
+            }
+            aResult.Append(char16_t(')'));
+          }
         }
-        aResult.Append(char16_t(')'));
       }
     } else if (eCSSUnit_HexColor == unit) {
       nscolor color = GetColorValue();
       aResult.Append('#');
       aResult.AppendPrintf("%02x", NS_GET_R(color));
       aResult.AppendPrintf("%02x", NS_GET_G(color));
       aResult.AppendPrintf("%02x", NS_GET_B(color));
     } else if (eCSSUnit_ShortHexColor == unit) {
diff --git a/netwerk/protocol/res/nsResProtocolHandler.cpp b/netwerk/protocol/res/nsResProtocolHandler.cpp
--- a/netwerk/protocol/res/nsResProtocolHandler.cpp
+++ b/netwerk/protocol/res/nsResProtocolHandler.cpp
@@ -87,13 +87,13 @@ nsResProtocolHandler::ResolveSpecialCase
     }
     aResult.Append(aPath);
     return true;
 }
 
 nsresult
 nsResProtocolHandler::SetSubstitution(const nsACString& aRoot, nsIURI* aBaseURI)
 {
-    MOZ_ASSERT(!aRoot.Equals(""));
+    /*MOZ_ASSERT(!aRoot.Equals(""));
     MOZ_ASSERT(!aRoot.Equals(kAPP));
-    MOZ_ASSERT(!aRoot.Equals(kGRE));
+    MOZ_ASSERT(!aRoot.Equals(kGRE));*/
     return SubstitutingProtocolHandler::SetSubstitution(aRoot, aBaseURI);
 }
diff --git a/parser/htmlparser/nsExpatDriver.cpp b/parser/htmlparser/nsExpatDriver.cpp
--- a/parser/htmlparser/nsExpatDriver.cpp
+++ b/parser/htmlparser/nsExpatDriver.cpp
@@ -957,17 +957,19 @@ nsExpatDriver::HandleError()
   }
 
   // If it didn't initialize, we can't do any logging.
   bool shouldReportError = NS_SUCCEEDED(rv);
 
   if (mSink && shouldReportError) {
     rv = mSink->ReportError(errorText.get(), 
                             sourceText.get(), 
-                            serr, 
+                            serr,
+                            lineNumber,
+                            colNumber,
                             &shouldReportError);
     if (NS_FAILED(rv)) {
       shouldReportError = true;
     }
   }
 
   if (shouldReportError) {
     nsCOMPtr<nsIConsoleService> cs
diff --git a/parser/htmlparser/nsIExpatSink.idl b/parser/htmlparser/nsIExpatSink.idl
--- a/parser/htmlparser/nsIExpatSink.idl
+++ b/parser/htmlparser/nsIExpatSink.idl
@@ -100,10 +100,12 @@ interface nsIExpatSink : nsISupports
    * @param aErrorText  Error message to pass to content sink.
    * @param aSourceText Source text of the document we're parsing.
    * @param aError      Script error object with line number & column number
    *
    * @retval True if the expat driver should report the error.
    */
   boolean ReportError(in wstring aErrorText,
                       in wstring aSourceText,
-                      in nsIScriptError aError);
+                      in nsIScriptError aError,
+                      in unsigned long aLineNumber,
+                      in unsigned long aColNumber);
 }; 
diff --git a/parser/xml/nsSAXXMLReader.cpp b/parser/xml/nsSAXXMLReader.cpp
--- a/parser/xml/nsSAXXMLReader.cpp
+++ b/parser/xml/nsSAXXMLReader.cpp
@@ -301,16 +301,18 @@ nsSAXXMLReader::HandleXMLDeclaration(con
   }
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsSAXXMLReader::ReportError(const char16_t* aErrorText,
                             const char16_t* aSourceText,
                             nsIScriptError *aError,
+                            PRUint32 aLineNumber,
+                            PRUint32 aColNumber,
                             bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
   // Normally, the expat driver should report the error.
   *_retval = true;
 
   if (mErrorHandler) {
     uint32_t lineNumber;
diff --git a/rdf/base/nsRDFContentSink.cpp b/rdf/base/nsRDFContentSink.cpp
--- a/rdf/base/nsRDFContentSink.cpp
+++ b/rdf/base/nsRDFContentSink.cpp
@@ -517,16 +517,18 @@ RDFContentSinkImpl::HandleXMLDeclaration
 {
     return NS_OK;
 }
 
 NS_IMETHODIMP
 RDFContentSinkImpl::ReportError(const char16_t* aErrorText, 
                                 const char16_t* aSourceText,
                                 nsIScriptError *aError,
+                                PRUint32 aLineNumber,
+                                PRUint32 aColNumber,
                                 bool *_retval)
 {
   NS_PRECONDITION(aError && aSourceText && aErrorText, "Check arguments!!!");
 
   // The expat driver should report the error.
   *_retval = true;
   return NS_OK;
 }
diff --git a/toolkit/components/console/content/console.js b/toolkit/components/console/content/console.js
--- a/toolkit/components/console/content/console.js
+++ b/toolkit/components/console/content/console.js
@@ -91,21 +91,19 @@ function evaluateTypein()
   // reset the iframe first; the code will be evaluated in loadOrDisplayResult
   // below, once about:blank has completed loading (see bug 385092)
   gEvaluator.contentWindow.location = "about:blank";
 }
 
 function loadOrDisplayResult()
 {
   if (gCodeToEvaluate) {
-    gEvaluator.contentWindow.location = "javascript: " +
-                                        gCodeToEvaluate.replace(/%/g, "%25");
+    var s = gEvaluator.contentDocument.createElement("script");
+    var t = gEvaluator.contentDocument.createTextNode("javascript:document.write(" + gCodeToEvaluate + ")");
+    s.appendChild(t);
+    gEvaluator.contentDocument.body.previousElementSibling.appendChild(s);
     gCodeToEvaluate = "";
-    return;
   }
-
-  var resultRange = gEvaluator.contentDocument.createRange();
-  resultRange.selectNode(gEvaluator.contentDocument.documentElement);
-  var result = resultRange.toString();
+  var result = gEvaluator.contentDocument.documentElement.textContent;
   if (result)
     Services.console.logStringMessage(result);
     // or could use appendMessage which doesn't persist
 }
diff --git a/toolkit/components/console/content/consoleBindings.xml b/toolkit/components/console/content/consoleBindings.xml
--- a/toolkit/components/console/content/consoleBindings.xml
+++ b/toolkit/components/console/content/consoleBindings.xml
@@ -146,19 +146,24 @@
             this.appendItem(messages[i]);
         ]]></body>
       </method>
 
       <method name="appendItem">
         <parameter name="aObject"/>
         <body><![CDATA[
           try {
+            const CM_RESOURCE_URL = "resource://gre/res/codemirror/";
             // Try to QI it to a script error to get more info
             var scriptError = aObject.QueryInterface(Components.interfaces.nsIScriptError);
 
+            // don't show codemirror errors
+            if (scriptError.sourceName.substr(0, CM_RESOURCE_URL.length) == CM_RESOURCE_URL)
+              return;
+
             // filter chrome urls
             if (!this.showChromeErrors && scriptError.sourceName.substr(0, 9) == "chrome://")
               return;
 
             // filter private windows
             if (scriptError.isFromPrivateWindow)
               return;
 
diff --git a/toolkit/content/widgets/menu.xml b/toolkit/content/widgets/menu.xml
--- a/toolkit/content/widgets/menu.xml
+++ b/toolkit/content/widgets/menu.xml
@@ -219,16 +219,25 @@
       <xul:label class="menu-iconic-text" flex="1" xbl:inherits="value=label,accesskey,crop" crop="right"/>
       <children/>
       <xul:hbox class="menu-accel-container" anonid="accel">
         <xul:label class="menu-iconic-accel" xbl:inherits="value=acceltext"/>
       </xul:hbox>
     </content>
   </binding>
 
+  <binding id="menuitem-non-iconic-accel" extends="chrome://global/content/bindings/menu.xml#menuitem">
+    <content>
+      <xul:label class="menu-iconic-text" flex="1" xbl:inherits="value=label,accesskey,crop" crop="right"/>
+      <xul:hbox class="menu-accel-container" anonid="accel">
+        <xul:label class="menu-iconic-accel" xbl:inherits="value=acceltext"/>
+      </xul:hbox>
+    </content>
+  </binding>
+
   <binding id="menuitem-iconic-noaccel" extends="chrome://global/content/bindings/menu.xml#menuitem">
     <content>
       <xul:hbox class="menu-iconic-left" align="center" pack="center"
                 xbl:inherits="selected,disabled,checked">
         <xul:image class="menu-iconic-icon" xbl:inherits="src=image,validate,src"/>
       </xul:hbox>
       <xul:label class="menu-iconic-text" flex="1" xbl:inherits="value=label,accesskey,crop" crop="right"/>
     </content>
diff --git a/toolkit/content/widgets/menulist.xml b/toolkit/content/widgets/menulist.xml
--- a/toolkit/content/widgets/menulist.xml
+++ b/toolkit/content/widgets/menulist.xml
@@ -540,16 +540,23 @@
                                          else this.removeAttribute('readonly'); return val;"
                                   onget="return this.inputField.readOnly;"/>
 
       <method name="select">
         <body>
           this.inputField.select();
         </body>
       </method>
+
+      <method name="getChild">
+        <parameter name="aChildName"/>
+        <body><![CDATA[
+          return document.getAnonymousElementByAttribute(this, "anonid", aChildName);
+        ]]></body>
+      </method>
     </implementation>
 
     <handlers>
       <handler event="focus" phase="capturing">
         <![CDATA[
           this.setAttribute('focused','true');
         ]]>
       </handler>
@@ -574,24 +581,40 @@
               // For now, only do this when the outermost menupopup opens.
               this.menuBoxObject.activeChild = this.mSelectedInternal;
           }
         ]]>
       </handler>
 
       <handler event="keypress">
         <![CDATA[
+          if (event.ctrlKey && event.shiftKey)
+            return;
+
+          if (this.getAttribute("bgtype") == "csslength") {
+            var _self = this;
+            if (event.keyCode == KeyEvent.DOM_VK_UP) {
+              IncreaseLength(this, this.getAttribute("units"));
+              if (this.oninput)
+                this.oninput.call(_self);
+              event.preventDefault();
+            }
+            else if (event.keyCode == KeyEvent.DOM_VK_DOWN) {
+              DecreaseLength(this, this.getAttribute("units"), !(this.getAttribute("unsigned") == "true"));
+              if (this.oninput)
+                this.oninput.call(_self);
+              event.preventDefault();
+            }
+          }
           // open popup if key is up arrow, down arrow, or F4
-          if (!event.ctrlKey && !event.shiftKey) {
-            if (event.keyCode == KeyEvent.DOM_VK_UP ||
-                event.keyCode == KeyEvent.DOM_VK_DOWN ||
-                (event.keyCode == KeyEvent.DOM_VK_F4 && !event.altKey)) {
-              event.preventDefault();
-              this.open = true;
-            }
+          else if (event.keyCode == KeyEvent.DOM_VK_UP ||
+                   event.keyCode == KeyEvent.DOM_VK_DOWN ||
+                   (event.keyCode == KeyEvent.DOM_VK_F4 && !event.altKey)) {
+            event.preventDefault();
+            this.open = true;
           }
         ]]>
       </handler>
     </handlers>
   </binding>
 
   <binding id="menulist-description" display="xul:menu"
            extends="chrome://global/content/bindings/menulist.xml#menulist">
diff --git a/toolkit/content/widgets/tree.xml b/toolkit/content/widgets/tree.xml
--- a/toolkit/content/widgets/tree.xml
+++ b/toolkit/content/widgets/tree.xml
@@ -709,17 +709,18 @@
       <handler event="MozSwipeGesture" preventdefault="true">
         <![CDATA[
           // Figure out which row to show
           let targetRow = 0;
 
           // Only handle swipe gestures up and down
           switch (event.direction) {
             case event.DIRECTION_DOWN:
-              targetRow = this.view.rowCount - 1;
+              if (this.view)
+                targetRow = this.view.rowCount - 1;
               // Fall through for actual action
             case event.DIRECTION_UP:
               this.treeBoxObject.ensureRowIsVisible(targetRow);
               break;
           }
         ]]>
       </handler>
       <handler event="select" phase="target"
@@ -1465,35 +1466,37 @@
           <![CDATA[
             // We no longer cache the picker content, remove the old content.
             while (aPopup.childNodes.length > 2)
               aPopup.removeChild(aPopup.firstChild);
 
             var refChild = aPopup.firstChild;
 
             var tree = this.parentNode.parentNode;
-            for (var currCol = tree.columns.getFirstColumn(); currCol;
-                 currCol = currCol.getNext()) {
-              // Construct an entry for each column in the row, unless
-              // it is not being shown.
-              var currElement = currCol.element;
-              if (!currElement.hasAttribute("ignoreincolumnpicker")) {
-                var popupChild = document.createElement("menuitem");
-                popupChild.setAttribute("type", "checkbox");
-                var columnName = currElement.getAttribute("display") ||
-                                 currElement.getAttribute("label");
-                popupChild.setAttribute("label", columnName);
-                popupChild.setAttribute("colindex", currCol.index);
-                if (currElement.getAttribute("hidden") != "true")
-                  popupChild.setAttribute("checked", "true");
-                if (currCol.primary)
-                  popupChild.setAttribute("disabled", "true");
-                aPopup.insertBefore(popupChild, refChild);
+            if (tree.columns) // sanity case
+              for (var currCol = tree.columns.getFirstColumn(); currCol;
+                   currCol = currCol.getNext()) {
+                // Construct an entry for each column in the row, unless
+                // it is not being shown.
+                var currElement = currCol.element;
+                if (!currElement.hasAttribute("ignoreincolumnpicker")) {
+                  var popupChild = document.createElement("menuitem");
+                  popupChild.setAttribute("type", "checkbox");
+                  var columnName = currElement.getAttribute("display") ||
+                                   currElement.getAttribute("label");
+                  popupChild.setAttribute("label", columnName);
+                  popupChild.setAttribute("colindex", currCol.index);
+                  if (currElement.getAttribute("hidden") != "true")
+                    popupChild.setAttribute("checked", "true");
+                  if (currCol.primary)
+                    popupChild.setAttribute("disabled", "true");
+                  aPopup.insertBefore(popupChild, refChild);
+                }
               }
-            }
+
 
             var hidden = !tree.enableColumnDrag;
             const anonids = ["menuseparator", "menuitem"];
             for (var i = 0; i < anonids.length; i++) {
               var element = document.getAnonymousElementByAttribute(this, "anonid", anonids[i]);
               element.hidden = hidden;
             }
           ]]>
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -370,16 +370,20 @@ menubar > menu:empty {
 menuitem {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem");
 }
 
 menuitem.menuitem-iconic {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic");
 }
 
+menuitem.menuitem-non-iconic-accel {
+  -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-non-iconic-accel");
+}
+
 menuitem[description] {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic-desc-noaccel");
 }
 
 menuitem[type="checkbox"],
 menuitem[type="radio"] {
   -moz-binding: url("chrome://global/content/bindings/menu.xml#menuitem-iconic");
 }
diff --git a/toolkit/mozapps/extensions/content/extensions.js b/toolkit/mozapps/extensions/content/extensions.js
--- a/toolkit/mozapps/extensions/content/extensions.js
+++ b/toolkit/mozapps/extensions/content/extensions.js
@@ -33,16 +33,17 @@ XPCOMUtils.defineLazyModuleGetter(this, 
 const PREF_DISCOVERURL = "extensions.webservice.discoverURL";
 const PREF_DISCOVER_ENABLED = "extensions.getAddons.showPane";
 const PREF_XPI_ENABLED = "xpinstall.enabled";
 const PREF_MAXRESULTS = "extensions.getAddons.maxResults";
 const PREF_GETADDONS_CACHE_ENABLED = "extensions.getAddons.cache.enabled";
 const PREF_GETADDONS_CACHE_ID_ENABLED = "extensions.%ID%.getAddons.cache.enabled";
 const PREF_UI_TYPE_HIDDEN = "extensions.ui.%TYPE%.hidden";
 const PREF_UI_LASTCATEGORY = "extensions.ui.lastCategory";
+const PREF_CLOSE_ADDONS_MANAGER_ON_ESCAPE = "extensions.closeOnEscape";
 
 const LOADING_MSG_DELAY = 100;
 
 const SEARCH_SCORE_MULTIPLIER_NAME = 2;
 const SEARCH_SCORE_MULTIPLIER_DESCRIPTION = 2;
 
 // Use integers so search scores are sortable by nsIXULSortService
 const SEARCH_SCORE_MATCH_WHOLEWORD = 10;
@@ -89,16 +90,27 @@ Object.defineProperty(this, "gIsInitiali
 function initialize(event) {
   // XXXbz this listener gets _all_ load events for all nodes in the
   // document... but relies on not being called "too early".
   if (event.target instanceof XMLStylesheetProcessingInstruction) {
     return;
   }
   document.removeEventListener("load", initialize, true);
 
+  // should we allow the window to close when the user hits the ESC key?
+  let closeOnEscape = false; // default for Firefox 4+
+  try {
+    closeOnEscape = Services.prefs.getBoolPref(PREF_CLOSE_ADDONS_MANAGER_ON_ESCAPE);
+  } catch(e) { }
+  if (!closeOnEscape) {
+    let escapeKeyElt = document.getElementById("escapeKey");
+    if (escapeKeyElt)
+      escapeKeyElt.setAttribute("disabled", "true");
+  }
+
   let globalCommandSet = document.getElementById("globalCommandSet");
   globalCommandSet.addEventListener("command", function(event) {
     gViewController.doCommand(event.target.id);
   });
 
   let viewCommandSet = document.getElementById("viewCommandSet");
   viewCommandSet.addEventListener("commandupdate", function(event) {
     gViewController.updateCommands();
@@ -2808,17 +2820,17 @@ var gListView = {
     this._listBox.insertBefore(item, this._listBox.firstChild);
     this.showEmptyNotice(false);
   },
 
   removeItem: function(aObj, aIsInstall) {
     let prop = aIsInstall ? "mInstall" : "mAddon";
 
     for (let item of this._listBox.childNodes) {
-      if (item[prop] == aObj) {
+      if (prop in item && item[prop] == aObj) {
         this._listBox.removeChild(item);
         this.showEmptyNotice(this._listBox.itemCount == 0);
         return;
       }
     }
   },
 
   getSelectedAddon: function() {
diff --git a/toolkit/mozapps/extensions/content/extensions.xul b/toolkit/mozapps/extensions/content/extensions.xul
--- a/toolkit/mozapps/extensions/content/extensions.xul
+++ b/toolkit/mozapps/extensions/content/extensions.xul
@@ -23,16 +23,20 @@
   <xhtml:link rel="shortcut icon"
               href="chrome://mozapps/skin/extensions/extensionGeneric-16.png"/>
 
   <script type="application/javascript"
           src="chrome://mozapps/content/extensions/extensions.js"/>
   <script type="application/javascript"
           src="chrome://global/content/contentAreaUtils.js"/>
 
+  <keyset>
+    <key id="escapeKey" keycode="VK_ESCAPE" oncommand="window.close()"/>
+  </keyset>
+
   <popupset>
     <!-- menu for an addon item -->
     <menupopup id="addonitem-popup">
       <menuitem id="menuitem_showDetails" command="cmd_showItemDetails"
                 default="true" label="&cmd.showDetails.label;"
                 accesskey="&cmd.showDetails.accesskey;"/>
       <menuitem id="menuitem_enableItem" command="cmd_enableItem"
                 label="&cmd.enableAddon.label;"
diff --git a/toolkit/mozapps/extensions/internal/XPIProvider.jsm b/toolkit/mozapps/extensions/internal/XPIProvider.jsm
--- a/toolkit/mozapps/extensions/internal/XPIProvider.jsm
+++ b/toolkit/mozapps/extensions/internal/XPIProvider.jsm
@@ -1205,17 +1205,21 @@ function loadManifestFromRDF(aUri, aStre
   addon.icons = {};
 
   return addon;
 }
 
 function defineSyncGUID(aAddon) {
   // Load the storage service before NSS (nsIRandomGenerator),
   // to avoid a SQLite initialization error (bug 717904).
-  let storage = Services.storage;
+  try {
+    // BLUEGRIFFON BMO bug 1277295
+    let storage = Services.storage;
+  }
+  catch(e) {}
 
   // Define .syncGUID as a lazy property which is also settable
   Object.defineProperty(aAddon, "syncGUID", {
     get: () => {
       // Generate random GUID used for Sync.
       // This was lifted from util.js:makeGUID() from services-sync.
       let rng = Cc["@mozilla.org/security/random-generator;1"].
         createInstance(Ci.nsIRandomGenerator);
@@ -7314,17 +7318,18 @@ function defineAddonWrapperProperty(name
 }
 
 ["id", "syncGUID", "version", "isCompatible", "isPlatformCompatible",
  "providesUpdatesSecurely", "blocklistState", "blocklistURL", "appDisabled",
  "softDisabled", "skinnable", "size", "foreignInstall", "hasBinaryComponents",
  "strictCompatibility", "compatibilityOverrides", "updateURL",
  "getDataDirectory", "multiprocessCompatible", "signedState"].forEach(function(aProp) {
    defineAddonWrapperProperty(aProp, function() {
-     return addonFor(this)[aProp];
+		let addon = addonFor(this);
+		return (aProp in addon) ? addon[aProp] : undefined;
    });
 });
 
 ["fullDescription", "developerComments", "eula", "supportURL",
  "contributionURL", "contributionAmount", "averageRating", "reviewCount",
  "reviewURL", "totalDownloads", "weeklyDownloads", "dailyUsers",
  "repositoryStatus"].forEach(function(aProp) {
   defineAddonWrapperProperty(aProp, function() {
diff --git a/toolkit/mozapps/handling/nsContentDispatchChooser.js b/toolkit/mozapps/handling/nsContentDispatchChooser.js
--- a/toolkit/mozapps/handling/nsContentDispatchChooser.js
+++ b/toolkit/mozapps/handling/nsContentDispatchChooser.js
@@ -62,22 +62,54 @@ nsContentDispatchChooser.prototype =
       let string = new SupportsString;
       string.data = text;
       params.appendElement(string, false);
     }
     params.appendElement(aHandler, false);
     params.appendElement(aURI, false);
     params.appendElement(aWindowContext, false);
 
+    // if a modal window is already shown, we need to open the app chooser
+    // as a modal window otherwise it will be unresponsive; bug 687423
+    var wm = Cc["@mozilla.org/appshell/window-mediator;1"].
+               getService(Ci.nsIWindowMediator);
+    var enumerator = wm.getXULWindowEnumerator(null);
+    var inModalState = false;
+    while (!inModalState && enumerator.hasMoreElements()) {
+      var win = enumerator.getNext();
+      var windowDocShell = win.QueryInterface(Ci.nsIXULWindow).docShell;
+  
+      var containedDocShells = windowDocShell.getDocShellEnumerator(
+                                        Ci.nsIDocShellTreeItem.typeChrome,
+                                        Ci.nsIDocShell.ENUMERATE_FORWARDS);
+
+      while (!inModalState && containedDocShells.hasMoreElements()) {
+        // Get the corresponding document for this docshell
+        var childDocShell = containedDocShells.getNext();
+
+        // We don't want it if it's not done loading.
+        if (childDocShell.busyFlags != Ci.nsIDocShell.BUSY_FLAGS_NONE)
+          continue;
+
+        // Ensure that we are only returning true if it is indeed modal
+        var chrome = win.QueryInterface(Ci.nsIInterfaceRequestor).
+                         getInterface(Ci.nsIWebBrowserChrome);
+        if (chrome.isWindowModal()) {
+          inModalState = true;
+        }
+      }
+    }
+
     var ww = Cc["@mozilla.org/embedcomp/window-watcher;1"].
              getService(Ci.nsIWindowWatcher);
     ww.openWindow(window,
                   CONTENT_HANDLING_URL,
                   null,
-                  "chrome,dialog=yes,resizable,centerscreen",
+                  "chrome,dialog=yes,resizable,centerscreen"
+                    + (inModalState ? ",modal" : ""),
                   params);
   },
 
   //////////////////////////////////////////////////////////////////////////////
   //// nsISupports
 
   QueryInterface: XPCOMUtils.generateQI([Ci.nsIContentDispatchChooser])
 };
diff --git a/toolkit/toolkit.mozbuild b/toolkit/toolkit.mozbuild
--- a/toolkit/toolkit.mozbuild
+++ b/toolkit/toolkit.mozbuild
@@ -159,17 +159,16 @@ if 'gtk' in CONFIG['MOZ_WIDGET_TOOLKIT']
     DIRS += ['/toolkit/system/gnome']
 
 DIRS += ['/addon-sdk']
 
 if CONFIG['ENABLE_MARIONETTE'] or CONFIG['MOZ_WIDGET_TOOLKIT'] not in ('gonk', 'android'):
     DIRS += ['/testing/marionette']
 
 DIRS += [
-    '/tools/quitter',
     '/media/gmp-clearkey/0.1',
 ]
 
 if CONFIG['ENABLE_TESTS']:
     DIRS += [
         '/testing/mochitest',
         '/testing/xpcshell',
         '/testing/tools/minidumpwriter',
diff --git a/widget/PuppetWidget.cpp b/widget/PuppetWidget.cpp
--- a/widget/PuppetWidget.cpp
+++ b/widget/PuppetWidget.cpp
@@ -1341,16 +1341,24 @@ NS_IMETHODIMP
 PuppetScreenManager::ScreenForId(uint32_t aId,
                                  nsIScreen** outScreen)
 {
   NS_IF_ADDREF(*outScreen = mOneScreen.get());
   return NS_OK;
 }
 
 NS_IMETHODIMP
+PuppetScreenManager::ScreenForIndex(uint32_t aId,
+                                    nsIScreen** outScreen)
+{
+  NS_IF_ADDREF(*outScreen = mOneScreen.get());
+  return NS_OK;
+}
+
+NS_IMETHODIMP
 PuppetScreenManager::GetPrimaryScreen(nsIScreen** outScreen)
 {
   NS_IF_ADDREF(*outScreen = mOneScreen.get());
   return NS_OK;
 }
 
 NS_IMETHODIMP
 PuppetScreenManager::ScreenForRect(int32_t inLeft,
diff --git a/widget/cocoa/VibrancyManager.h b/widget/cocoa/VibrancyManager.h
--- a/widget/cocoa/VibrancyManager.h
+++ b/widget/cocoa/VibrancyManager.h
@@ -6,16 +6,17 @@
 
 #ifndef VibrancyManager_h
 #define VibrancyManager_h
 
 #include "mozilla/Assertions.h"
 #include "nsClassHashtable.h"
 #include "nsRegion.h"
 #include "nsTArray.h"
+#include "ViewRegion.h"
 
 #import <Foundation/NSGeometry.h>
 
 @class NSColor;
 @class NSView;
 class nsChildView;
 
 namespace mozilla {
@@ -95,27 +96,20 @@ public:
 
   /**
    * Check whether the operating system supports vibrancy at all.
    * You may only create a VibrancyManager instance if this returns true.
    * @return Whether VibrancyManager can be used on this OS.
    */
   static bool SystemSupportsVibrancy();
 
-  // The following are only public because otherwise ClearVibrantRegionFunc
-  // can't see them.
-  struct VibrantRegion {
-    LayoutDeviceIntRegion region;
-    nsTArray<NSView*> effectViews;
-  };
-  void ClearVibrantRegion(const VibrantRegion& aVibrantRegion) const;
-
 protected:
-  NSView* CreateEffectView(VibrancyType aType, NSRect aRect);
+  void ClearVibrantRegion(const LayoutDeviceIntRegion& aVibrantRegion) const;
+  NSView* CreateEffectView(VibrancyType aType);
 
   const nsChildView& mCoordinateConverter;
   NSView* mContainerView;
-  nsClassHashtable<nsUint32HashKey, VibrantRegion> mVibrantRegions;
+  nsClassHashtable<nsUint32HashKey, ViewRegion> mVibrantRegions;
 };
 
 } // namespace mozilla
 
 #endif // VibrancyManager_h
diff --git a/widget/cocoa/VibrancyManager.mm b/widget/cocoa/VibrancyManager.mm
--- a/widget/cocoa/VibrancyManager.mm
+++ b/widget/cocoa/VibrancyManager.mm
@@ -10,75 +10,35 @@
 
 using namespace mozilla;
 
 void
 VibrancyManager::UpdateVibrantRegion(VibrancyType aType,
                                      const LayoutDeviceIntRegion& aRegion)
 {
   auto& vr = *mVibrantRegions.LookupOrAdd(uint32_t(aType));
-  if (vr.region == aRegion) {
-    return;
-  }
-
-  // We need to construct the required region using as many EffectViews
-  // as necessary. We try to update the geometry of existing views if
-  // possible, or create new ones or remove old ones if the number of
-  // rects in the region has changed.
-
-  nsTArray<NSView*> viewsToRecycle;
-  vr.effectViews.SwapElements(viewsToRecycle);
-  // vr.effectViews is now empty.
-
-  size_t i = 0;
-  for (auto iter = aRegion.RectIter();
-       !iter.Done() || i < viewsToRecycle.Length();
-       i++) {
-    if (!iter.Done()) {
-      NSView* view = nil;
-      NSRect rect = mCoordinateConverter.DevPixelsToCocoaPoints(iter.Get());
-      if (i < viewsToRecycle.Length()) {
-        view = viewsToRecycle[i];
-        [view setFrame:rect];
-        [view setNeedsDisplay:YES];
-      } else {
-        view = CreateEffectView(aType, rect);
-        [mContainerView addSubview:view];
-
-        // Now that the view is in the view hierarchy, it'll be kept alive by
-        // its superview, so we can drop our reference.
-        [view release];
-      }
-      vr.effectViews.AppendElement(view);
-      iter.Next();
-    } else {
-      // Our new region is made of less rects than the old region, so we can
-      // remove this view. We only have a weak reference to it, so removing it
-      // from the view hierarchy will release it.
-      [viewsToRecycle[i] removeFromSuperview];
-    }
-  }
-
-  vr.region = aRegion;
+  vr.UpdateRegion(aRegion, mCoordinateConverter, mContainerView, ^() {
+    return this->CreateEffectView(aType);
+  });
 }
 
 void
 VibrancyManager::ClearVibrantAreas() const
 {
   for (auto iter = mVibrantRegions.ConstIter(); !iter.Done(); iter.Next()) {
-    ClearVibrantRegion(*iter.UserData());
+    ClearVibrantRegion(iter.UserData()->Region());
   }
 }
 
 void
-VibrancyManager::ClearVibrantRegion(const VibrantRegion& aVibrantRegion) const
+VibrancyManager::ClearVibrantRegion(const LayoutDeviceIntRegion& aVibrantRegion) const
 {
   [[NSColor clearColor] set];
 
-  for (auto iter = aVibrantRegion.region.RectIter(); !iter.Done(); iter.Next()) {
+  for (auto iter = aVibrantRegion.RectIter(); !iter.Done(); iter.Next()) {
     NSRectFill(mCoordinateConverter.DevPixelsToCocoaPoints(iter.Get()));
   }
 }
 
 @interface NSView(CurrentFillColor)
 - (NSColor*)_currentFillColor;
 @end
 
@@ -93,42 +53,38 @@ AdjustedColor(NSColor* aFillColor, Vibra
     return [NSColor colorWithDeviceWhite:0.96 alpha:1.0];
   }
   return aFillColor;
 }
 
 NSColor*
 VibrancyManager::VibrancyFillColorForType(VibrancyType aType)
 {
-  const nsTArray<NSView*>& views =
-    mVibrantRegions.LookupOrAdd(uint32_t(aType))->effectViews;
+  NSView* view = mVibrantRegions.LookupOrAdd(uint32_t(aType))->GetAnyView();
 
-  if (!views.IsEmpty() &&
-      [views[0] respondsToSelector:@selector(_currentFillColor)]) {
+  if (view && [view respondsToSelector:@selector(_currentFillColor)]) {
     // -[NSVisualEffectView _currentFillColor] is the color that our view
     // would draw during its drawRect implementation, if we hadn't
     // disabled that.
-    return AdjustedColor([views[0] _currentFillColor], aType);
+    return AdjustedColor([view _currentFillColor], aType);
   }
   return [NSColor whiteColor];
 }
 
 @interface NSView(FontSmoothingBackgroundColor)
 - (NSColor*)fontSmoothingBackgroundColor;
 @end
 
 NSColor*
 VibrancyManager::VibrancyFontSmoothingBackgroundColorForType(VibrancyType aType)
 {
-  const nsTArray<NSView*>& views =
-    mVibrantRegions.LookupOrAdd(uint32_t(aType))->effectViews;
+  NSView* view = mVibrantRegions.LookupOrAdd(uint32_t(aType))->GetAnyView();
 
-  if (!views.IsEmpty() &&
-      [views[0] respondsToSelector:@selector(fontSmoothingBackgroundColor)]) {
-    return [views[0] fontSmoothingBackgroundColor];
+  if (view && [view respondsToSelector:@selector(fontSmoothingBackgroundColor)]) {
+    return [view fontSmoothingBackgroundColor];
   }
   return [NSColor clearColor];
 }
 
 static void
 DrawRectNothing(id self, SEL _cmd, NSRect aRect)
 {
   // The super implementation would clear the background.
@@ -246,24 +202,24 @@ enum {
 
 @interface NSView(NSVisualEffectViewMethods)
 - (void)setState:(NSUInteger)state;
 - (void)setMaterial:(NSUInteger)material;
 - (void)setEmphasized:(BOOL)emphasized;
 @end
 
 NSView*
-VibrancyManager::CreateEffectView(VibrancyType aType, NSRect aRect)
+VibrancyManager::CreateEffectView(VibrancyType aType)
 {
   static Class EffectViewClassWithoutForegroundVibrancy = CreateEffectViewClass(NO);
   static Class EffectViewClassWithForegroundVibrancy = CreateEffectViewClass(YES);
 
   Class EffectViewClass = HasVibrantForeground(aType)
     ? EffectViewClassWithForegroundVibrancy : EffectViewClassWithoutForegroundVibrancy;
-  NSView* effectView = [[EffectViewClass alloc] initWithFrame:aRect];
+  NSView* effectView = [[EffectViewClass alloc] initWithFrame:NSZeroRect];
   [effectView performSelector:@selector(setAppearance:)
                    withObject:AppearanceForVibrancyType(aType)];
   [effectView setState:VisualEffectStateForVibrancyType(aType)];
 
   if (aType == VibrancyType::MENU) {
     if (nsCocoaFeatures::OnElCapitanOrLater()) {
       [effectView setMaterial:NSVisualEffectMaterialMenu];
     } else {
diff --git a/widget/cocoa/moz.build b/widget/cocoa/moz.build
--- a/widget/cocoa/moz.build
+++ b/widget/cocoa/moz.build
@@ -53,16 +53,17 @@ UNIFIED_SOURCES += [
     'nsSystemStatusBarCocoa.mm',
     'nsToolkit.mm',
     'nsWidgetFactory.mm',
     'nsWindowMap.mm',
     'OSXNotificationCenter.mm',
     'SwipeTracker.mm',
     'TextInputHandler.mm',
     'VibrancyManager.mm',
+    'ViewRegion.mm',
     'WidgetTraceEvent.mm',
 ]
 
 # These files cannot be built in unified mode because they cause symbol conflicts
 SOURCES += [
     'nsChildView.mm',
     'nsClipboard.mm',
     'nsCocoaDebugUtils.mm',
diff --git a/widget/cocoa/nsChildView.h b/widget/cocoa/nsChildView.h
--- a/widget/cocoa/nsChildView.h
+++ b/widget/cocoa/nsChildView.h
@@ -23,16 +23,17 @@
 #include "GLContextTypes.h"
 #include "mozilla/Mutex.h"
 #include "nsRegion.h"
 #include "mozilla/MouseEvents.h"
 #include "mozilla/UniquePtr.h"
 
 #include "nsString.h"
 #include "nsIDragService.h"
+#include "ViewRegion.h"
 
 #import <Carbon/Carbon.h>
 #import <Cocoa/Cocoa.h>
 #import <AppKit/NSOpenGL.h>
 
 class nsChildView;
 class nsCocoaWindow;
 
@@ -494,17 +495,17 @@ public:
   virtual bool PreRender(LayerManagerComposite* aManager) override;
   virtual void PostRender(LayerManagerComposite* aManager) override;
   virtual void DrawWindowOverlay(LayerManagerComposite* aManager,
                                  LayoutDeviceIntRect aRect) override;
 
   virtual void UpdateThemeGeometries(const nsTArray<ThemeGeometry>& aThemeGeometries) override;
 
   virtual void UpdateWindowDraggingRegion(const LayoutDeviceIntRegion& aRegion) override;
-  const LayoutDeviceIntRegion& GetDraggableRegion() { return mDraggableRegion; }
+  LayoutDeviceIntRegion GetNonDraggableRegion() { return mNonDraggableRegion.Region(); }
 
   virtual void ReportSwipeStarted(uint64_t aInputBlockId, bool aStartSwipe) override;
 
   void              ResetParent();
 
   static bool DoHasPendingInputEvent();
   static uint32_t GetCurrentInputEventCount();
   static void UpdateCurrentInputEventCount();
@@ -654,17 +655,17 @@ protected:
   nsAutoPtr<RectTextureImage> mCornerMaskImage;
   nsAutoPtr<RectTextureImage> mTitlebarImage;
   nsAutoPtr<RectTextureImage> mBasicCompositorImage;
 
   // The area of mTitlebarCGContext that has changed and needs to be
   // uploaded to to mTitlebarImage. Main thread only.
   nsIntRegion           mDirtyTitlebarRegion;
 
-  LayoutDeviceIntRegion mDraggableRegion;
+  mozilla::ViewRegion   mNonDraggableRegion;
 
   // Cached value of [mView backingScaleFactor], to avoid sending two obj-c
   // messages (respondsToSelector, backingScaleFactor) every time we need to
   // use it.
   // ** We'll need to reinitialize this if the backing resolution changes. **
   mutable CGFloat       mBackingScaleFactor;
 
   bool                  mVisible;
diff --git a/widget/cocoa/nsChildView.mm b/widget/cocoa/nsChildView.mm
--- a/widget/cocoa/nsChildView.mm
+++ b/widget/cocoa/nsChildView.mm
@@ -2690,22 +2690,51 @@ nsChildView::DoRemoteComposition(const L
   // anything during the basic compositor transaction. Draw the overlay now.
   DrawWindowOverlay(mGLPresenter, aRenderRect);
 
   mGLPresenter->EndFrame();
 
   [(ChildView*)mView postRender:mGLPresenter->GetNSOpenGLContext()];
 }
 
+@interface NonDraggableView : NSView
+@end
+
+@implementation NonDraggableView
+- (BOOL)mouseDownCanMoveWindow { return NO; }
+- (NSView*)hitTest:(NSPoint)aPoint { return nil; }
+@end
+
 void
 nsChildView::UpdateWindowDraggingRegion(const LayoutDeviceIntRegion& aRegion)
 {
-  if (mDraggableRegion != aRegion) {
-    mDraggableRegion = aRegion;
-    [(ChildView*)mView updateWindowDraggableState];
+  // mView returns YES from mouseDownCanMoveWindow, so we need to put NSViews
+  // that return NO from mouseDownCanMoveWindow in the places that shouldn't
+  // be draggable. We can't do it the other way round because returning
+  // YES from mouseDownCanMoveWindow doesn't have any effect if there's a
+  // superview that returns NO.
+  LayoutDeviceIntRegion nonDraggable;
+  nonDraggable.Sub(LayoutDeviceIntRect(0, 0, mBounds.width, mBounds.height), aRegion);
+
+  __block bool changed = false;
+
+  // Suppress calls to setNeedsDisplay during NSView geometry changes.
+  ManipulateViewWithoutNeedingDisplay(mView, ^() {
+    changed = mNonDraggableRegion.UpdateRegion(nonDraggable, *this, mView, ^() {
+      return [[NonDraggableView alloc] initWithFrame:NSZeroRect];
+    });
+  });
+
+  if (changed) {
+    // Trigger an update to the window server. This will call
+    // mouseDownCanMoveWindow.
+    // Doing this manually is only necessary because we're suppressing
+    // setNeedsDisplay calls above.
+    [[mView window] setMovableByWindowBackground:NO];
+    [[mView window] setMovableByWindowBackground:YES];
   }
 }
 
 void
 nsChildView::ReportSwipeStarted(uint64_t aInputBlockId,
                                 bool aStartSwipe)
 {
   if (mSwipeEventQueue && mSwipeEventQueue->inputBlockId == aInputBlockId) {
@@ -3544,18 +3573,20 @@ NSEvent* gLastDragMouseDownEvent = nil;
   }
   [super scrollRect:aRect by:offset];
 
   NS_OBJC_END_TRY_ABORT_BLOCK;
 }
 
 - (BOOL)mouseDownCanMoveWindow
 {
-  // Return YES so that _regionForOpaqueDescendants gets called, where the
-  // actual draggable region will be assembled.
+  // Return YES so that parts of this view can be draggable. The non-draggable                   
+  // parts will be covered by NSViews that return NO from                                        
+  // mouseDownCanMoveWindow and thus override draggability from the inside.                      
+  // These views are assembled in nsChildView::UpdateWindowDraggingRegion.                       
   return YES;
 }
 
 -(void)updateGLContext
 {
   if (mGLContext) {
     CGLLockContext((CGLContextObj)[mGLContext CGLContextObj]);
     [mGLContext setView:self];
@@ -4545,17 +4576,17 @@ NSEvent* gLastDragMouseDownEvent = nil;
   // This might destroy our widget (and null out mGeckoChild).
   bool defaultPrevented =
     (mGeckoChild->DispatchInputEvent(&geckoEvent) == nsEventStatus_eConsumeNoDefault);
 
   // Check to see if we are double-clicking in the titlebar.
   CGFloat locationInTitlebar = [[self window] frame].size.height - [theEvent locationInWindow].y;
   LayoutDeviceIntPoint pos = geckoEvent.refPoint;
   if (!defaultPrevented && [theEvent clickCount] == 2 &&
-      mGeckoChild->GetDraggableRegion().Contains(pos.x, pos.y) &&
+      !mGeckoChild->GetNonDraggableRegion().Contains(pos.x, pos.y) &&
       [[self window] isKindOfClass:[ToolbarWindow class]] &&
       (locationInTitlebar < [(ToolbarWindow*)[self window] titlebarHeight] ||
        locationInTitlebar < [(ToolbarWindow*)[self window] unifiedToolbarHeight])) {
     if ([self shouldZoomOnDoubleClick]) {
       [[self window] performZoom:nil];
     } else if ([self shouldMinimizeOnTitlebarDoubleClick]) {
       NSButton *minimizeButton = [[self window] standardWindowButton:NSWindowMiniaturizeButton];
       [minimizeButton performClick:self];
@@ -4580,85 +4611,16 @@ NSEvent* gLastDragMouseDownEvent = nil;
   event.refPoint = mGeckoChild->CocoaPointsToDevPixels(localEventLocation);
 
   event.exit = aType;
 
   nsEventStatus status; // ignored
   mGeckoChild->DispatchEvent(&event, status);
 }
 
-- (void)updateWindowDraggableState
-{
-  // Trigger update to the window server.
-  [[self window] setMovableByWindowBackground:NO];
-  [[self window] setMovableByWindowBackground:YES];
-}
-
-// aRect is in view coordinates relative to this NSView.
-- (CGRect)convertToFlippedWindowCoordinates:(NSRect)aRect
-{
-  // First, convert the rect to regular window coordinates...
-  NSRect inWindowCoords = [self convertRect:aRect toView:nil];
-  // ... and then flip it again because window coordinates have their origin
-  // in the bottom left corner, and we need it to be in the top left corner.
-  inWindowCoords.origin.y = [[self window] frame].size.height - NSMaxY(inWindowCoords);
-  return NSRectToCGRect(inWindowCoords);
-}
-
-static CGSRegionObj
-NewCGSRegionFromRegion(const LayoutDeviceIntRegion& aRegion,
-                       CGRect (^aRectConverter)(const LayoutDeviceIntRect&))
-{
-  nsTArray<CGRect> rects;
-  for (auto iter = aRegion.RectIter(); !iter.Done(); iter.Next()) {
-    rects.AppendElement(aRectConverter(iter.Get()));
-  }
-
-  CGSRegionObj region;
-  CGSNewRegionWithRectList(rects.Elements(), rects.Length(), &region);
-  return region;
-}
-
-// This function is called with forMove:YES to calculate the draggable region
-// of the window which will be submitted to the window server. Window dragging
-// is handled on the window server without calling back into our process, so it
-// also works while our app is unresponsive.
-- (CGSRegionObj)_regionForOpaqueDescendants:(NSRect)aRect forMove:(BOOL)aForMove
-{
-  if (!aForMove || !mGeckoChild) {
-    return [super _regionForOpaqueDescendants:aRect forMove:aForMove];
-  }
-
-  LayoutDeviceIntRect boundingRect = mGeckoChild->CocoaPointsToDevPixels(aRect);
-
-  LayoutDeviceIntRegion opaqueRegion;
-  opaqueRegion.Sub(boundingRect, mGeckoChild->GetDraggableRegion());
-
-  return NewCGSRegionFromRegion(opaqueRegion, ^(const LayoutDeviceIntRect& r) {
-    return [self convertToFlippedWindowCoordinates:mGeckoChild->DevPixelsToCocoaPoints(r)];
-  });
-}
-
-// Starting with 10.10, in addition to the traditional
-// -[NSView _regionForOpaqueDescendants:forMove:] method, there's a new form with
-// an additional forUnderTitlebar argument, which is sometimes called instead of
-// the old form. We need to override the new variant as well.
-- (CGSRegionObj)_regionForOpaqueDescendants:(NSRect)aRect
-                                    forMove:(BOOL)aForMove
-                           forUnderTitlebar:(BOOL)aForUnderTitlebar
-{
-  if (!aForMove || !mGeckoChild) {
-    return [super _regionForOpaqueDescendants:aRect
-                                      forMove:aForMove
-                             forUnderTitlebar:aForUnderTitlebar];
-  }
-
-  return [self _regionForOpaqueDescendants:aRect forMove:aForMove];
-}
-
 - (void)handleMouseMoved:(NSEvent*)theEvent
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 
   if (!mGeckoChild)
     return;
 
   WidgetMouseEvent geckoEvent(true, eMouseMove, mGeckoChild,
diff --git a/widget/cocoa/nsCocoaUtils.mm b/widget/cocoa/nsCocoaUtils.mm
--- a/widget/cocoa/nsCocoaUtils.mm
+++ b/widget/cocoa/nsCocoaUtils.mm
@@ -301,39 +301,42 @@ void nsCocoaUtils::PrepareForNativeAppMo
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 
   // Don't do anything if this is embedding. We'll assume that if there is no hidden
   // window we shouldn't do anything, and that should cover the embedding case.
   nsMenuBarX* hiddenWindowMenuBar = nsMenuUtilsX::GetHiddenWindowMenuBar();
   if (!hiddenWindowMenuBar)
     return;
 
+  // XXX BLUEGRIFFON ; do NOT paint the hidden menubar because otherwise, that's
+  // what's show when you close a filepicker... And in that case, menus are mostly
+  // disabled and inable to operate even on a visible window...
   // First put up the hidden window menu bar so that app menu event handling is correct.
-  hiddenWindowMenuBar->Paint();
+  //hiddenWindowMenuBar->Paint();
 
   NSMenu* mainMenu = [NSApp mainMenu];
   NS_ASSERTION([mainMenu numberOfItems] > 0, "Main menu does not have any items, something is terribly wrong!");
-  
+
   // Create new menu bar for use with modal dialog
   NSMenu* newMenuBar = [[NSMenu alloc] initWithTitle:@""];
-  
+
   // Swap in our app menu. Note that the event target is whatever window is up when
   // the app modal dialog goes up.
   NSMenuItem* firstMenuItem = [[mainMenu itemAtIndex:0] retain];
   [mainMenu removeItemAtIndex:0];
   [newMenuBar insertItem:firstMenuItem atIndex:0];
   [firstMenuItem release];
-  
+
   // Add standard edit menu
   [newMenuBar addItem:nsMenuUtilsX::GetStandardEditMenuItem()];
-  
+
   // Show the new menu bar
   [NSApp setMainMenu:newMenuBar];
   [newMenuBar release];
-  
+
   NS_OBJC_END_TRY_ABORT_BLOCK;
 }
 
 void nsCocoaUtils::CleanUpAfterNativeAppModalDialog()
 {
   NS_OBJC_BEGIN_TRY_ABORT_BLOCK;
 
   // Don't do anything if this is embedding. We'll assume that if there is no hidden
diff --git a/widget/cocoa/nsColorPicker.h b/widget/cocoa/nsColorPicker.h
--- a/widget/cocoa/nsColorPicker.h
+++ b/widget/cocoa/nsColorPicker.h
@@ -17,17 +17,17 @@ class mozIDOMWindowProxy;
 @class NSColor;
 
 class nsColorPicker final : public nsIColorPicker
 {
 public:
   NS_DECL_ISUPPORTS
 
   NS_IMETHOD Init(mozIDOMWindowProxy* aParent, const nsAString& aTitle,
-                  const nsAString& aInitialColor) override;
+                  const nsAString& aInitialColor, bool aShowAlpha) override;
   NS_IMETHOD Open(nsIColorPickerShownCallback* aCallback) override;
 
   // For NSColorPanelWrapper.
   void Update(NSColor* aColor);
   // Call this method if you are done with this input, but the color picker needs to
   // stay open as it will be associated to another input
   void DoneWithRetarget();
   // Same as DoneWithRetarget + clean the static instance of sColorPanelWrapper,
@@ -39,12 +39,13 @@ private:
 
   static NSColor* GetNSColorFromHexString(const nsAString& aColor);
   static void GetHexStringFromNSColor(NSColor* aColor, nsAString& aResult);
 
   static NSColorPanelWrapper* sColorPanelWrapper;
 
   nsString             mTitle;
   nsString             mColor;
+  bool               mShowsAlpha;
   nsCOMPtr<nsIColorPickerShownCallback> mCallback;
 };
 
 #endif // nsColorPicker_h_
diff --git a/widget/cocoa/nsColorPicker.mm b/widget/cocoa/nsColorPicker.mm
--- a/widget/cocoa/nsColorPicker.mm
+++ b/widget/cocoa/nsColorPicker.mm
@@ -4,16 +4,18 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #import <Cocoa/Cocoa.h>
 
 #include "nsColorPicker.h"
 #include "nsCocoaUtils.h"
 #include "nsThreadUtils.h"
 
+#include "nsCSSParser.h"
+
 using namespace mozilla;
 
 static unsigned int
 HexStrToInt(NSString* str)
 {
   unsigned int result = 0;
 
   for (unsigned int i = 0; i < [str length]; ++i) {
@@ -32,39 +34,40 @@ HexStrToInt(NSString* str)
 }
 
 @interface NSColorPanelWrapper : NSObject <NSWindowDelegate>
 {
   NSColorPanel*  mColorPanel;
   nsColorPicker* mColorPicker;
 }
 - (id)initWithPicker:(nsColorPicker*)aPicker;
-- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle;
+- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle showsAlpha:(BOOL)aShowsAlpha;
 - (void)retarget:(nsColorPicker*)aPicker;
 - (void)colorChanged:(NSColorPanel*)aPanel;
 @end
 
 @implementation NSColorPanelWrapper
 - (id)initWithPicker:(nsColorPicker*)aPicker
 {
   mColorPicker = aPicker;
   mColorPanel = [NSColorPanel sharedColorPanel];
 
   self = [super init];
   return self;
 }
 
-- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle
+- (void)open:(NSColor*)aInitialColor title:(NSString*)aTitle showsAlpha:(BOOL)aShowsAlpha
 {
   [mColorPanel setTitle:aTitle];
   [mColorPanel setColor:aInitialColor];
   [mColorPanel setTarget:self];
+  [mColorPanel setShowsAlpha:aShowsAlpha];
   [mColorPanel setAction:@selector(colorChanged:)];
   [mColorPanel setDelegate:self];
-  [mColorPanel makeKeyAndOrderFront:nil];
+  [mColorPanel orderFront:nil];
 }
 
 - (void)colorChanged:(NSColorPanel*)aPanel
 {
   mColorPicker->Update([mColorPanel color]);
 }
 
 - (void)windowWillClose:(NSNotification*)aNotification
@@ -98,76 +101,100 @@ NS_IMPL_ISUPPORTS(nsColorPicker, nsIColo
 NSColorPanelWrapper* nsColorPicker::sColorPanelWrapper = nullptr;
 
 nsColorPicker::~nsColorPicker()
 {
 }
 
 NS_IMETHODIMP
 nsColorPicker::Init(mozIDOMWindowProxy* aParent, const nsAString& aTitle,
-                    const nsAString& aInitialColor)
+                    const nsAString& aInitialColor, bool aShowAlpha)
 {
   MOZ_ASSERT(NS_IsMainThread(),
       "Color pickers can only be opened from main thread currently");
   mTitle = aTitle;
   mColor = aInitialColor;
+  mShowsAlpha = aShowAlpha;
 
   if (sColorPanelWrapper) {
     // Update current wrapper to target the new input instead
     [sColorPanelWrapper retarget:this];
   } else {
     // Create a brand new color panel wrapper
     sColorPanelWrapper = [[NSColorPanelWrapper alloc] initWithPicker:this];
   }
   return NS_OK;
 }
 
 /* static */ NSColor*
 nsColorPicker::GetNSColorFromHexString(const nsAString& aColor)
 {
-  NSString* str = nsCocoaUtils::ToNSString(aColor);
+  nsCSSValue value;
+  nsCSSParser parser;
+  if (!parser.ParseColorString(aColor, nullptr, 0, value)) {
+    return [NSColor colorWithDeviceRed: 0 green: 0 blue: 0 alpha: 1];
+  }
 
-  double red = HexStrToInt([str substringWithRange:NSMakeRange(1, 2)]) / 255.0;
-  double green = HexStrToInt([str substringWithRange:NSMakeRange(3, 2)]) / 255.0;
-  double blue = HexStrToInt([str substringWithRange:NSMakeRange(5, 2)]) / 255.0;
+  nscolor color;
+  if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
+    return [NSColor colorWithDeviceRed: 0 green: 0 blue: 0 alpha: 1];
+  }
 
-  return [NSColor colorWithDeviceRed: red green: green blue: blue alpha: 1.0];
+  return [NSColor colorWithRed: ((float)NS_GET_R(color))/255.0
+                         green: ((float)NS_GET_G(color))/255.0
+                          blue: ((float)NS_GET_B(color))/255.0
+                         alpha: ((float)NS_GET_A(color))/255.0];
 }
 
 /* static */ void
 nsColorPicker::GetHexStringFromNSColor(NSColor* aColor, nsAString& aResult)
 {
-  CGFloat redFloat, greenFloat, blueFloat;
-  [aColor getRed: &redFloat green: &greenFloat blue: &blueFloat alpha: nil];
-
-  nsCocoaUtils::GetStringForNSString([NSString stringWithFormat:@"#%02x%02x%02x",
-                                       (int)(redFloat * 255),
-                                       (int)(greenFloat * 255),
-                                       (int)(blueFloat * 255)],
-                                     aResult);
+  CGFloat redFloat, greenFloat, blueFloat, alphaFloat;
+  [aColor getRed: &redFloat green: &greenFloat blue: &blueFloat alpha: &alphaFloat];
+  if (alphaFloat < 1.0f) {
+    nsCocoaUtils::GetStringForNSString([NSString stringWithFormat:@"rgba(%d, %d, %d, %1.2f)",
+                                         (int)(redFloat * 255 + 0.5f),
+                                         (int)(greenFloat * 255 + 0.5f),
+                                         (int)(blueFloat * 255 + 0.5f),
+                                         (float) alphaFloat],
+                                       aResult);
+  }
+  else {
+    nsCocoaUtils::GetStringForNSString([NSString stringWithFormat:@"#%02x%02x%02x",
+                                         (int)(redFloat * 255 + 0.5f),
+                                         (int)(greenFloat * 255 + 0.5f),
+                                         (int)(blueFloat * 255 + 0.5f)],
+                                       aResult);
+  }
 }
 
 NS_IMETHODIMP
 nsColorPicker::Open(nsIColorPickerShownCallback* aCallback)
 {
   MOZ_ASSERT(aCallback);
   mCallback = aCallback;
 
   [sColorPanelWrapper open:GetNSColorFromHexString(mColor)
-              title:nsCocoaUtils::ToNSString(mTitle)];
+              title:nsCocoaUtils::ToNSString(mTitle)
+              showsAlpha:mShowsAlpha];
 
   NS_ADDREF_THIS();
 
   return NS_OK;
 }
 
 void
 nsColorPicker::Update(NSColor* aColor)
 {
-  GetHexStringFromNSColor(aColor, mColor);
+  NSColor *color = aColor;
+  if ([[aColor colorSpaceName] isEqualToString:NSNamedColorSpace])        {
+    color = [aColor colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];
+  }
+
+  GetHexStringFromNSColor(color, mColor);
   mCallback->Update(mColor);
 }
 
 void
 nsColorPicker::DoneWithRetarget()
 {
   mCallback->Done(EmptyString());
   mCallback = nullptr;
diff --git a/widget/cocoa/nsDeviceContextSpecX.mm b/widget/cocoa/nsDeviceContextSpecX.mm
--- a/widget/cocoa/nsDeviceContextSpecX.mm
+++ b/widget/cocoa/nsDeviceContextSpecX.mm
@@ -152,17 +152,18 @@ NS_IMETHODIMP nsDeviceContextSpecX::GetS
 
     if (context) {
         // Initially, origin is at bottom-left corner of the paper.
         // Here, we translate it to top-left corner of the paper.
         CGContextTranslateCTM(context, 0, height);
         CGContextScaleCTM(context, 1.0, -1.0);
         newSurface = new gfxQuartzSurface(context, gfxSize(width, height));
     } else {
-        newSurface = new gfxQuartzSurface(gfxSize((int32_t)width, (int32_t)height), SurfaceFormat::A8R8G8B8_UINT32);
+        newSurface = new gfxQuartzSurface(gfxSize((int32_t)width, (int32_t)height),
+                                          mozilla::gfx::SurfaceFormat::A8R8G8B8_UINT32);
     }
 
     if (!newSurface)
         return NS_ERROR_FAILURE;
 
     *surface = newSurface;
     NS_ADDREF(*surface);
 
diff --git a/widget/cocoa/nsMenuItemX.mm b/widget/cocoa/nsMenuItemX.mm
--- a/widget/cocoa/nsMenuItemX.mm
+++ b/widget/cocoa/nsMenuItemX.mm
@@ -254,16 +254,39 @@ void nsMenuItemX::SetKeyEquiv()
         }
       }
 
       nsAutoString modifiersStr;
       keyContent->GetAttr(kNameSpaceID_None, nsGkAtoms::modifiers, modifiersStr);
       uint8_t modifiers = nsMenuUtilsX::GeckoModifiersForNodeAttribute(modifiersStr);
 
       unsigned int macModifiers = nsMenuUtilsX::MacModifiersForGeckoModifiers(modifiers);
+      // If we're empty, try the keyCode instead.
+      if (keyChar.Equals(NS_LITERAL_STRING(" ")) || keyChar.IsEmpty()) {
+
+        keyContent->GetAttr(kNameSpaceID_None, nsGkAtoms::keycode, keyChar);
+
+        if (keyChar.Equals(NS_LITERAL_STRING("VK_F2"))) {
+          unichar ch[1];
+          ch[0] = NSF2FunctionKey;
+          macModifiers |= NSFunctionKeyMask;
+          [mNativeMenuItem setKeyEquivalentModifierMask:macModifiers];
+          [mNativeMenuItem setKeyEquivalent:[NSString stringWithCharacters:ch length:1]];
+          return;
+        }
+        else if (keyChar.Equals(NS_LITERAL_STRING("VK_F4"))) {
+          unichar ch[1];
+          ch[0] = NSF4FunctionKey;
+          macModifiers |= NSFunctionKeyMask;
+          [mNativeMenuItem setKeyEquivalentModifierMask:macModifiers];
+          [mNativeMenuItem setKeyEquivalent:[NSString stringWithCharacters:ch length:1]];
+          return;
+        }
+      }
+
       [mNativeMenuItem setKeyEquivalentModifierMask:macModifiers];
 
       NSString *keyEquivalent = [[NSString stringWithCharacters:(unichar*)keyChar.get()
                                                          length:keyChar.Length()] lowercaseString];
       if ([keyEquivalent isEqualToString:@" "])
         [mNativeMenuItem setKeyEquivalent:@""];
       else
         [mNativeMenuItem setKeyEquivalent:keyEquivalent];
diff --git a/widget/cocoa/nsNativeThemeCocoa.mm b/widget/cocoa/nsNativeThemeCocoa.mm
--- a/widget/cocoa/nsNativeThemeCocoa.mm
+++ b/widget/cocoa/nsNativeThemeCocoa.mm
@@ -2705,17 +2705,17 @@ nsNativeThemeCocoa::DrawWidgetBackground
     }
       break;
 
     case NS_THEME_WINDOW_TITLEBAR: {
       NSWindow* win = NativeWindowForFrame(aFrame);
       BOOL isMain = [win isMainWindow];
       float unifiedToolbarHeight = [win isKindOfClass:[ToolbarWindow class]] ?
         [(ToolbarWindow*)win unifiedToolbarHeight] : macRect.size.height;
-      DrawNativeTitlebar(cgContext, macRect, unifiedToolbarHeight, isMain, YES);
+      // DrawNativeTitlebar(cgContext, macRect, unifiedToolbarHeight, isMain, YES);
     }
       break;
 
     case NS_THEME_STATUSBAR: 
       DrawStatusBar(cgContext, macRect, aFrame);
       break;
 
     case NS_THEME_DROPDOWN:
diff --git a/widget/cocoa/nsScreenCocoa.mm b/widget/cocoa/nsScreenCocoa.mm
--- a/widget/cocoa/nsScreenCocoa.mm
+++ b/widget/cocoa/nsScreenCocoa.mm
@@ -39,64 +39,64 @@ nsScreenCocoa::GetId(uint32_t *outId)
   NS_OBJC_END_TRY_ABORT_BLOCK;
 }
 
 NS_IMETHODIMP
 nsScreenCocoa::GetRect(int32_t *outX, int32_t *outY, int32_t *outWidth, int32_t *outHeight)
 {
   NSRect frame = [mScreen frame];
 
-  LayoutDeviceIntRect r =
+  mozilla::LayoutDeviceIntRect r =
     nsCocoaUtils::CocoaRectToGeckoRectDevPix(frame, BackingScaleFactor());
 
   *outX = r.x;
   *outY = r.y;
   *outWidth = r.width;
   *outHeight = r.height;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsScreenCocoa::GetAvailRect(int32_t *outX, int32_t *outY, int32_t *outWidth, int32_t *outHeight)
 {
   NSRect frame = [mScreen visibleFrame];
 
-  LayoutDeviceIntRect r =
+  mozilla::LayoutDeviceIntRect r =
     nsCocoaUtils::CocoaRectToGeckoRectDevPix(frame, BackingScaleFactor());
 
   *outX = r.x;
   *outY = r.y;
   *outWidth = r.width;
   *outHeight = r.height;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsScreenCocoa::GetRectDisplayPix(int32_t *outX, int32_t *outY, int32_t *outWidth, int32_t *outHeight)
 {
   NSRect frame = [mScreen frame];
 
-  DesktopIntRect r = nsCocoaUtils::CocoaRectToGeckoRect(frame);
+  mozilla::DesktopIntRect r = nsCocoaUtils::CocoaRectToGeckoRect(frame);
 
   *outX = r.x;
   *outY = r.y;
   *outWidth = r.width;
   *outHeight = r.height;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsScreenCocoa::GetAvailRectDisplayPix(int32_t *outX, int32_t *outY, int32_t *outWidth, int32_t *outHeight)
 {
   NSRect frame = [mScreen visibleFrame];
 
-  DesktopIntRect r = nsCocoaUtils::CocoaRectToGeckoRect(frame);
+  mozilla::DesktopIntRect r = nsCocoaUtils::CocoaRectToGeckoRect(frame);
 
   *outX = r.x;
   *outY = r.y;
   *outWidth = r.width;
   *outHeight = r.height;
 
   return NS_OK;
 }
diff --git a/widget/cocoa/nsScreenManagerCocoa.mm b/widget/cocoa/nsScreenManagerCocoa.mm
--- a/widget/cocoa/nsScreenManagerCocoa.mm
+++ b/widget/cocoa/nsScreenManagerCocoa.mm
@@ -145,8 +145,28 @@ nsScreenManagerCocoa::ScreenForNativeWid
         return NS_OK;
     }
 
     *outScreen = nullptr;
     return NS_OK;
 
     NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
 }
+
+NS_IMETHODIMP
+nsScreenManagerCocoa::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+    NS_OBJC_BEGIN_TRY_ABORT_BLOCK_NSRESULT;
+
+    uint32_t numberOfScreens;
+    GetNumberOfScreens(&numberOfScreens);
+    if (aIndex >= numberOfScreens)
+        return NS_ERROR_FAILURE;
+  
+    NSScreen *sc = [[NSScreen screens] objectAtIndex: aIndex];
+  
+    *outScreen = ScreenForCocoaScreen(sc);
+    NS_ADDREF(*outScreen);
+  
+    return NS_OK;
+  
+    NS_OBJC_END_TRY_ABORT_BLOCK_NSRESULT;
+}
diff --git a/widget/gtk/nsColorPicker.cpp b/widget/gtk/nsColorPicker.cpp
--- a/widget/gtk/nsColorPicker.cpp
+++ b/widget/gtk/nsColorPicker.cpp
@@ -1,21 +1,24 @@
 /* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include <gtk/gtk.h>
+#include <gtk/gtkcolorsel.h>
 
 #include "nsColor.h"
 #include "nsColorPicker.h"
 #include "nsGtkUtils.h"
 #include "nsIWidget.h"
 #include "WidgetUtils.h"
 
+#include "nsCSSParser.h"
+
 NS_IMPL_ISUPPORTS(nsColorPicker, nsIColorPicker)
 
 #if defined(ACTIVATE_GTK3_COLOR_PICKER) && GTK_CHECK_VERSION(3,4,0)
 int nsColorPicker::convertGdkRgbaComponent(gdouble color_component) {
   // GdkRGBA value is in range [0.0..1.0]. We need something in range [0..255]
   return color_component * 255 + 0.5;
 }
 
@@ -54,38 +57,39 @@ GtkColorSelection* nsColorPicker::Widget
 {
   return GTK_COLOR_SELECTION(gtk_color_selection_dialog_get_color_selection(
                              GTK_COLOR_SELECTION_DIALOG(widget)));
 }
 #endif
 
 NS_IMETHODIMP nsColorPicker::Init(mozIDOMWindowProxy *aParent,
                                   const nsAString& title,
-                                  const nsAString& initialColor)
+                                  const nsAString& initialColor,
+                                  bool aShowsAlpha)
 {
   auto* parent = nsPIDOMWindowOuter::From(aParent);
   mParentWidget = mozilla::widget::WidgetUtils::DOMWindowToWidget(parent);
   mTitle = title;
   mInitialColor = initialColor;
+  mShowsAlpha = aShowsAlpha;
 
   return NS_OK;
 }
 
 NS_IMETHODIMP nsColorPicker::Open(nsIColorPickerShownCallback *aColorPickerShownCallback)
 {
 
-  // Input color string should be 7 length (i.e. a string representing a valid
-  // simple color)
-  if (mInitialColor.Length() != 7) {
+  nsCSSValue value;
+  nsCSSParser parser;
+  if (!parser.ParseColorString(mInitialColor, nullptr, 0, value)) {
     return NS_ERROR_FAILURE;
   }
 
-  const nsAString& withoutHash  = StringTail(mInitialColor, 6);
   nscolor color;
-  if (!NS_HexToRGB(withoutHash, &color)) {
+  if (!nsRuleNode::ComputeColor(value, nullptr, nullptr, color)) {
     return NS_ERROR_FAILURE;
   }
 
   if (mCallback) {
     // It means Open has already been called: this is not allowed
     NS_WARNING("mCallback is already set. Open called twice?");
     return NS_ERROR_FAILURE;
   }
@@ -113,16 +117,18 @@ NS_IMETHODIMP nsColorPicker::Open(nsICol
   GtkWidget *color_chooser = gtk_color_selection_dialog_new(title);
   
   if (parent_window) {
     GtkWindow *window = GTK_WINDOW(color_chooser);
     gtk_window_set_transient_for(window, parent_window);
     gtk_window_set_destroy_with_parent(window, TRUE);
   }
 
+  gtk_color_selection_set_has_opacity_control(WidgetGetColorSelection(color_chooser),
+                                              mShowsAlpha);
   GdkColor color_gdk = convertToGdkColor(color);
   gtk_color_selection_set_current_color(WidgetGetColorSelection(color_chooser),
                                         &color_gdk);
   
   g_signal_connect(WidgetGetColorSelection(color_chooser), "color-changed",
                    G_CALLBACK(OnColorChanged), this);
 #endif
 
@@ -176,20 +182,38 @@ nsColorPicker::Update(GtkColorSelection*
   }
 }
 
 void nsColorPicker::ReadValueFromColorSelection(GtkColorSelection* colorselection)
 {
   GdkColor rgba;
   gtk_color_selection_get_current_color(colorselection, &rgba);
 
-  mColor.Assign('#');
-  mColor += ToHexString(convertGdkColorComponent(rgba.red));
-  mColor += ToHexString(convertGdkColorComponent(rgba.green));
-  mColor += ToHexString(convertGdkColorComponent(rgba.blue));
+  guint16 alphaValue = 65535;
+  if (mShowsAlpha) {
+    alphaValue = gtk_color_selection_get_current_alpha(colorselection);
+  }
+
+  if (alphaValue == 65535) {
+    mColor.Assign('#');
+    mColor += ToHexString(convertGdkColorComponent(rgba.red));
+    mColor += ToHexString(convertGdkColorComponent(rgba.green));
+    mColor += ToHexString(convertGdkColorComponent(rgba.blue));
+  }
+  else {
+    mColor.AssignWithConversion("rgba(");
+    mColor.AppendInt(convertGdkColorComponent(rgba.red), 10);
+    mColor.AppendLiteral(", ");
+    mColor.AppendInt(convertGdkColorComponent(rgba.green), 10);
+    mColor.AppendLiteral(", ");
+    mColor.AppendInt(convertGdkColorComponent(rgba.blue), 10);
+    mColor.AppendLiteral(", ");
+    mColor.AppendFloat(((float)alphaValue / 65535));
+    mColor.AppendLiteral(")");
+  }
 }
 #endif
 
 /* static */ void
 nsColorPicker::OnResponse(GtkWidget* color_chooser, gint response_id,
                           gpointer user_data)
 {
   static_cast<nsColorPicker*>(user_data)->
diff --git a/widget/gtk/nsColorPicker.h b/widget/gtk/nsColorPicker.h
--- a/widget/gtk/nsColorPicker.h
+++ b/widget/gtk/nsColorPicker.h
@@ -63,11 +63,12 @@ private:
 
   void Done(GtkWidget* dialog, gint response_id);
 
   nsCOMPtr<nsIWidget> mParentWidget;
   nsCOMPtr<nsIColorPickerShownCallback> mCallback;
   nsString mTitle;
   nsString mColor;
   nsString mInitialColor;
+  bool mShowsAlpha;
 };
 
 #endif // nsColorPicker_h__
diff --git a/widget/gtk/nsScreenManagerGtk.cpp b/widget/gtk/nsScreenManagerGtk.cpp
--- a/widget/gtk/nsScreenManagerGtk.cpp
+++ b/widget/gtk/nsScreenManagerGtk.cpp
@@ -358,8 +358,20 @@ nsScreenManagerGtk :: ScreenForNativeWid
     gdk_window_get_origin(GDK_WINDOW(aWidget), &x, &y);
     rv = ScreenForRect(x, y, width, height, outScreen);
   } else {
     rv = GetPrimaryScreen(outScreen);
   }
 
   return rv;
 }
+
+NS_IMETHODIMP
+nsScreenManagerGtk::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+    uint32_t numberOfScreens;
+    GetNumberOfScreens(&numberOfScreens);
+    if (aIndex >= numberOfScreens)
+        return NS_ERROR_FAILURE;
+
+    NS_IF_ADDREF(*outScreen = mCachedScreenArray[aIndex]);
+    return NS_OK;
+}
diff --git a/widget/nsColorPickerProxy.cpp b/widget/nsColorPickerProxy.cpp
--- a/widget/nsColorPickerProxy.cpp
+++ b/widget/nsColorPickerProxy.cpp
@@ -9,26 +9,27 @@
 #include "mozilla/dom/TabChild.h"
 
 using namespace mozilla::dom;
 
 NS_IMPL_ISUPPORTS(nsColorPickerProxy, nsIColorPicker)
 
 NS_IMETHODIMP
 nsColorPickerProxy::Init(mozIDOMWindowProxy* aParent, const nsAString& aTitle,
-                         const nsAString& aInitialColor)
+                         const nsAString& aInitialColor, bool aShowsAlpha)
 {
   TabChild* tabChild = TabChild::GetFrom(aParent);
   if (!tabChild) {
     return NS_ERROR_FAILURE;
   }
 
   tabChild->SendPColorPickerConstructor(this,
                                         nsString(aTitle),
-                                        nsString(aInitialColor));
+                                        nsString(aInitialColor),
+                                        aShowsAlpha);
   NS_ADDREF_THIS();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsColorPickerProxy::Open(nsIColorPickerShownCallback* aColorPickerShownCallback)
 {
   NS_ENSURE_STATE(!mCallback);
diff --git a/widget/nsIColorPicker.idl b/widget/nsIColorPicker.idl
--- a/widget/nsIColorPicker.idl
+++ b/widget/nsIColorPicker.idl
@@ -11,17 +11,17 @@ interface mozIDOMWindowProxy;
 /**
  * nsIColorPicker is representing colors as strings because the internal
  * representation will depend on the underlying backend.
  * The format of the colors taken in input and returned will always follow the
  * format of the <input type='color'> value as described in the HTML
  * specifications.
  */
 
-[scriptable, uuid(d2ce78d1-40b5-49d1-b66d-5801fcb9a385)]
+[scriptable, uuid(645FAD1F-2B55-42E1-AC15-DB4A9DF27209)]
 interface nsIColorPickerShownCallback : nsISupports
 {
  /**
   * Callback called when the color picker requests a color update.
   * This callback can not be called after done() was called.
   * When this callback is used, the consumer can assume that the color value has
   * changed.
   *
@@ -57,16 +57,17 @@ interface nsIColorPicker : nsISupports
   *
   * @param      parent       nsIDOMWindow parent. This dialog will be dependent
   *                          on this parent. parent must be non-null.
   * @param      title        The title for the color picker widget.
   * @param      initialColor The color to show when the widget is opened. The
   *                          parameter has to follow the format specified on top
   *                          of this file.
   */
-  void init(in mozIDOMWindowProxy parent, in AString title, in AString initialColor);
+  void init(in mozIDOMWindowProxy parent, in AString title, in AString initialColor,
+            in boolean aShowAlpha);
 
  /**
   * Opens the color dialog asynchrounously.
   * The results are provided via the callback object.
   */
   void open(in nsIColorPickerShownCallback aColorPickerShownCallback);
 };
diff --git a/widget/nsIScreenManager.idl b/widget/nsIScreenManager.idl
--- a/widget/nsIScreenManager.idl
+++ b/widget/nsIScreenManager.idl
@@ -2,27 +2,29 @@
  *
  * This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsISupports.idl"
 #include "nsIScreen.idl"
 
-[scriptable, uuid(e8a96e60-6b61-4a14-bacc-53891604b502)]
+[scriptable, uuid(F9A056B8-A6CA-4F34-8C07-6ACF7ADAD038)]
 interface nsIScreenManager : nsISupports
 {
     //
     // Returns the screen that contains the rectangle. If the rect overlaps
     // multiple screens, it picks the screen with the greatest area of intersection.
     //
     // The coordinates are in pixels (not twips) and in screen coordinates.
     //
   nsIScreen screenForRect ( in long left, in long top, in long width, in long height ) ;
 
+  nsIScreen screenForIndex ( in unsigned long index);
+
     //
     // Returns the screen corresponding to the id. If no such screen exists,
     // this will throw NS_ERROR_FAILURE. The id is a unique numeric value
     // assigned to each screen, and is an attribute available on the nsIScreen
     // interface.
   nsIScreen screenForId ( in unsigned long id ) ;
 
     // The screen with the menubar/taskbar. This shouldn't be needed very
diff --git a/widget/nsScreenManagerProxy.cpp b/widget/nsScreenManagerProxy.cpp
--- a/widget/nsScreenManagerProxy.cpp
+++ b/widget/nsScreenManagerProxy.cpp
@@ -80,16 +80,24 @@ NS_IMETHODIMP
 nsScreenManagerProxy::ScreenForId(uint32_t aId, nsIScreen** outScreen)
 {
   // At this time, there's no need for child processes to query for
   // screens by ID.
   return NS_ERROR_NOT_IMPLEMENTED;
 }
 
 NS_IMETHODIMP
+nsScreenManagerProxy::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+  // At this time, there's no need for child processes to query for
+  // screens by ID.
+  return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+NS_IMETHODIMP
 nsScreenManagerProxy::ScreenForRect(int32_t inLeft,
                                     int32_t inTop,
                                     int32_t inWidth,
                                     int32_t inHeight,
                                     nsIScreen** outScreen)
 {
   bool success = false;
   ScreenDetails details;
diff --git a/widget/windows/nsColorPicker.cpp b/widget/windows/nsColorPicker.cpp
--- a/widget/windows/nsColorPicker.cpp
+++ b/widget/windows/nsColorPicker.cpp
@@ -187,22 +187,24 @@ nsColorPicker::~nsColorPicker()
 {
 }
 
 NS_IMPL_ISUPPORTS(nsColorPicker, nsIColorPicker)
 
 NS_IMETHODIMP
 nsColorPicker::Init(mozIDOMWindowProxy* parent,
                     const nsAString& title,
-                    const nsAString& aInitialColor)
+                    const nsAString& aInitialColor,
+                    bool aShowsAlpha)
 {
   NS_PRECONDITION(parent,
       "Null parent passed to colorpicker, no color picker for you!");
   mParentWidget =  WidgetUtils::DOMWindowToWidget(nsPIDOMWindowOuter::From(parent));
   mInitialColor = ColorStringToRGB(aInitialColor);
+  mShowsAlpha = aShowsAlpha;
   return NS_OK;
 }
 
 NS_IMETHODIMP
 nsColorPicker::Open(nsIColorPickerShownCallback* aCallback)
 {
   NS_ENSURE_ARG(aCallback);
   nsCOMPtr<nsIRunnable> event = new AsyncColorChooser(mInitialColor,
diff --git a/widget/windows/nsColorPicker.h b/widget/windows/nsColorPicker.h
--- a/widget/windows/nsColorPicker.h
+++ b/widget/windows/nsColorPicker.h
@@ -43,17 +43,19 @@ class nsColorPicker :
   virtual ~nsColorPicker();
 
 public:
   nsColorPicker();
 
   NS_DECL_ISUPPORTS
 
   NS_IMETHOD Init(mozIDOMWindowProxy* parent, const nsAString& title,
-                  const nsAString& aInitialColor);
+                  const nsAString& aInitialColor,
+                  bool aShowsAlpha);
   NS_IMETHOD Open(nsIColorPickerShownCallback* aCallback);
 
 private:
   COLORREF mInitialColor;
   nsCOMPtr<nsIWidget> mParentWidget;
+  bool mShowsAlpha;
 };
 
 #endif // nsColorPicker_h__
diff --git a/widget/windows/nsScreenManagerWin.cpp b/widget/windows/nsScreenManagerWin.cpp
--- a/widget/windows/nsScreenManagerWin.cpp
+++ b/widget/windows/nsScreenManagerWin.cpp
@@ -174,8 +174,22 @@ nsScreenManagerWin::GetSystemDefaultScal
 
 NS_IMETHODIMP
 nsScreenManagerWin::ScreenForNativeWidget(void *aWidget, nsIScreen **outScreen)
 {
   HMONITOR mon = MonitorFromWindow((HWND) aWidget, MONITOR_DEFAULTTOPRIMARY);
   *outScreen = CreateNewScreenObject(mon);
   return NS_OK;
 }
+
+NS_IMETHODIMP
+nsScreenManagerWin::ScreenForIndex(uint32_t aIndex, nsIScreen**outScreen)
+{
+  *outScreen = nullptr;
+
+  if (aIndex < mScreenList.Length()) {
+    ScreenListItem& curr = mScreenList[aIndex];
+    NS_IF_ADDREF(*outScreen = curr.mScreen.get());
+    return NS_OK;
+  }
+
+  return NS_ERROR_FAILURE;
+}
